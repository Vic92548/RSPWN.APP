const cardManager = {
    currentCard: null,
    cards: new Map(),
    isNavigating: false,
    previousPath: null,

    register(cardId, options = {}) {
        this.cards.set(cardId, {
            onShow: options.onShow || (() => {}),
            onHide: options.onHide || (() => {}),
            onLoad: options.onLoad || null,
            route: options.route || null,
            ...options
        });
    },

    async show(cardId) {
        const card = document.getElementById(cardId);
        if (!card) {
            console.error(`Card ${cardId} not found`);
            return;
        }

        if (window.hideMenu) hideMenu();

        this.previousPath = window.location.pathname;

        if (this.currentCard && this.currentCard !== cardId) {
            await this.hideCard(this.currentCard, true);
            await new Promise(resolve => setTimeout(resolve, 50));
        }

        const post = document.querySelector('.post');
        if (post) {
            post.style.display = 'none';
        }

        card.style.display = 'block';

        setTimeout(() => {
            card.classList.add('show');
        }, 10);

        this.currentCard = cardId;

        const config = this.cards.get(cardId) || {};

        if (config.route && window.router && !this.isNavigating) {
            const currentPath = window.location.pathname;
            if (currentPath !== config.route) {
                this.isNavigating = true;
                window.history.pushState(null, null, config.route);
                this.isNavigating = false;
            }
        }

        if (config.onLoad) {
            this.showLoading(cardId);
            try {
                await config.onLoad();
            } catch (error) {
                console.error(`Error loading card ${cardId}:`, error);
            } finally {
                this.hideLoading(cardId);
            }
        }

        if(config.onShow) config.onShow();
    },

    hide(cardId) {
        return this.hideCard(cardId, false);
    },

    hideCard(cardId, skipPostRestore = false) {
        return new Promise((resolve) => {
            const card = document.getElementById(cardId);
            if (!card) {
                resolve();
                return;
            }

            const config = this.cards.get(cardId) || {};

            if (cardId === 'downloads-card' && window.downloadManager) {
                window.downloadManager.pauseEventProcessing();
            }

            card.classList.remove('show');

            setTimeout(() => {
                card.style.display = 'none';

                if(config.onHide) {
                    try {
                        config.onHide();
                    } catch (error) {
                        console.error('Error in onHide:', error);
                    }
                }

                if (this.currentCard === cardId) {
                    this.currentCard = null;
                }

                if (cardId === 'downloads-card' && window.downloadManager) {
                    setTimeout(() => {
                        window.downloadManager.resumeEventProcessing();
                    }, 100);
                }

                if (!skipPostRestore) {
                    const post = document.querySelector('.post');
                    if (post) {
                        post.style.display = 'block';
                        post.style.transform = 'translate(0px, 0px) rotate(0deg)';
                    }

                    if (window.router && !this.isNavigating) {
                        let targetPath = '/';

                        if (window.current_post_id) {
                            targetPath = `/post/${window.current_post_id}`;
                        } else if (this.previousPath && this.previousPath !== window.location.pathname) {
                            targetPath = this.previousPath;
                        }

                        this.isNavigating = true;
                        window.history.pushState(null, null, targetPath);

                        if (targetPath === '/' || targetPath.startsWith('/post/')) {
                            if (window.showPost) window.showPost();
                            if (window.displayPost) {
                                if (targetPath.startsWith('/post/')) {
                                    const postId = targetPath.split('/')[2];
                                    window.displayPost(postId);
                                } else {
                                    window.displayPost();
                                }
                            }
                        }

                        this.isNavigating = false;
                    }
                }

                resolve();
            }, 300);
        });
    },

    showLoading(cardId) {
        const card = document.getElementById(cardId);

        if (cardId === 'analytics-card') {
            const loading = document.getElementById('analytics-loading');
            const content = document.querySelector('.analytics-body');
            if (loading) loading.style.display = 'block';
            if (content) content.style.opacity = '0.3';
        }
        else if (cardId === 'backgrounds-card') {
            const loading = document.getElementById('backgrounds-loading');
            const content = document.getElementById('backgroundsContent');
            if (loading) loading.style.display = 'block';
            if (content) content.style.opacity = '0.3';
        }
        else if (cardId === 'games-card') {
            const loading = document.getElementById('games-loading');
            const content = document.getElementById('gamesContent');
            if (loading) loading.style.display = 'block';
            if (content) content.style.opacity = '0.3';
        }
    },

    hideLoading(cardId) {
        const card = document.getElementById(cardId);

        if (cardId === 'analytics-card') {
            const loading = document.getElementById('analytics-loading');
            const content = document.querySelector('.analytics-body');
            if (loading) loading.style.display = 'none';
            if (content) content.style.opacity = '1';
        }
        else if (cardId === 'backgrounds-card') {
            const loading = document.getElementById('backgrounds-loading');
            const content = document.getElementById('backgroundsContent');
            if (loading) loading.style.display = 'none';
            if (content) content.style.opacity = '1';
        }
        else if (cardId === 'games-card') {
            const loading = document.getElementById('games-loading');
            const content = document.getElementById('gamesContent');
            if (loading) loading.style.display = 'none';
            if (content) content.style.opacity = '1';
        }
    }
};

window.cardManager = cardManager;
const DOM = {
    get: (id) => document.getElementById(id),
    query: (sel) => document.querySelector(sel),
    queryAll: (sel) => document.querySelectorAll(sel),
    create: (tag, attrs = {}, content = '') => {
        const el = document.createElement(tag);
        Object.entries(attrs).forEach(([k, v]) => {
            if (k === 'style' && typeof v === 'object') {
                Object.assign(el.style, v);
            } else if (k === 'class') {
                el.className = v;
            } else if (k.startsWith('on')) {
                el[k] = v;
            } else {
                el.setAttribute(k, v);
            }
        });
        if (content) el.innerHTML = content;
        return el;
    },
    show: (el, display = 'block') => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.style.display = display;
    },
    hide: (el) => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.style.display = 'none';
    },
    toggle: (el, display = 'block') => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.style.display = el.style.display === 'none' ? display : 'none';
    },
    setText: (el, text) => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.textContent = text;
    },
    setHTML: (el, html) => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.innerHTML = html;
    }
};

window.DOM = DOM;
window.analytics = {};
window.navigation = {
    goTo: (routeKey, params = {}, frontendOnly = true) => {
        if (window.router && window.router.navigateToRoute) {
            window.router.navigateToRoute(routeKey, params, frontendOnly);
        } else {
            const path = window.buildPath ? window.buildPath(routeKey, params) : null;
            if (path) {
                if (frontendOnly) {
                    history.pushState(null, null, path);
                    if (window.router && window.router.handleRoute) {
                        window.router.handleRoute();
                    }
                } else {
                    window.location.href = path;
                }
            }
        }
    },

    goToPost: (postId, frontendOnly = true) => {
        window.navigation.goTo('post', { id: postId }, frontendOnly);
    },

    goToProfile: (username, frontendOnly = true) => {
        window.navigation.goTo('profile', { username }, frontendOnly);
    },

    goToGame: (gameName, frontendOnly = true) => {
        window.navigation.goTo('games', { gameName }, frontendOnly);
    },

    goHome: (frontendOnly = true) => {
        window.navigation.goTo('home', {}, frontendOnly);
    },

    goToLibrary: (frontendOnly = true) => {
        window.navigation.goTo('library', {}, frontendOnly);
    },

    goToCreate: (frontendOnly = true) => {
        window.navigation.goTo('create', {}, frontendOnly);
    },

    goToAuth: (frontendOnly = true) => {
        window.navigation.goTo('auth', {}, frontendOnly);
    },

    goToStore: (frontendOnly = true) => {
        window.navigation.goTo('store', {}, frontendOnly);
    },

    goToTerms: (frontendOnly = true) => {
        window.navigation.goTo('terms', {}, frontendOnly);
    },

    goToPrivacy: (frontendOnly = true) => {
        window.navigation.goTo('privacy', {}, frontendOnly);
    },

    goToDownloads: (frontendOnly = true) => {
        window.navigation.goTo('downloads', {}, frontendOnly);
    },

    goToCreators: (frontendOnly = true) => {
        window.navigation.goTo('creators', {}, frontendOnly);
    },

    goToPartners: (frontendOnly = true) => {
        window.navigation.goTo('partners', {}, frontendOnly);
    },

    getCurrentRoute: () => {
        return window.router ? window.router.getCurrentRoute() : null;
    },

    getParams: () => {
        return window.router ? window.router.getParams() : {};
    },

    refresh: () => {
        if (window.router && window.router.handleRoute) {
            window.router.handleRoute();
        }
    }
};
console.log('Router initializing...');

class VAPRRouter {
    constructor() {
        this.currentRoute = null;
        this.params = {};
        this.previousRoute = null;
        this.authRetryCount = 0;
        this.initializeRoutes();
    }

    initializeRoutes() {
        console.log('Initializing unified routes...');
        if (typeof window.ROUTES !== 'undefined') {
            for (const [key, route] of Object.entries(window.ROUTES)) {
                console.log('ROUTE REGISTERED', { key, path: route.path, meta: route.meta });
            }
        } else {
            console.warn('Routes not yet loaded, will initialize when available');
        }
    }

    navigate(path, bIsFrontEndOnly = false) {
        if (bIsFrontEndOnly) {
            history.pushState(null, null, path);
            this.handleRoute();
        } else {
            loading.show();
            window.location.href = path;
        }
    }

    navigateToRoute(routeKey, params = {}, frontendOnly = true) {
        const path = window.buildPath ? window.buildPath(routeKey, params) : null;
        if (path) {
            this.navigate(path, frontendOnly);
        } else {
            console.error('Route not found:', routeKey);
        }
    }

    handleRoute() {
        console.log('ðŸ“ ROUTE handleRoute() called');
        const path = window.location.pathname;
        console.log('ðŸ“ Handling route for path:', path);
        console.log('ðŸ“ Current auth state - window.user:', window.user, 'loading_steps:', window.loading_steps);
        this.previousRoute = this.currentRoute;

        if (cardManager.currentCard && !cardManager.isNavigating) {
            cardManager.hide(cardManager.currentCard);
        }

        this.hideAllLegalPages();

        const routeMatch = window.getRouteByPath ? window.getRouteByPath(path) : null;
        console.log('Route match result:', routeMatch);

        if (routeMatch) {
            const { key, route } = routeMatch;
            const params = window.extractParams ? window.extractParams(route.path, path) : {};

            console.log('Executing route:', key, 'with params:', params);
            this.currentRoute = key;
            this.params = params;
            this.authRetryCount = 0;

            if (route.meta.requiresAuth && !isUserLoggedIn()) {
                console.log('Route requires auth but user not logged in');
                console.log('window.user:', window.user);
                console.log('isUserLoggedIn():', isUserLoggedIn());
                console.log('loading_steps:', window.loading_steps);

               
                if ((window.loading_steps > 0 || (localStorage.getItem('userData') && !window.user)) && this.authRetryCount < 5) {
                    this.authRetryCount++;
                    console.log('Auth not ready, retrying route in 500ms (attempt:', this.authRetryCount, ')');
                    setTimeout(() => {
                        this.handleRoute();
                    }, 500);
                    return;
                }

                console.log('Opening register modal');
                openRegisterModal();
                return;
            }

            if (route.frontend) {
                console.log('Calling route frontend handler');
                route.frontend(params);
            } else {
                console.log('No frontend handler for route');
            }
            return;
        } else {
            console.log('No route match found for path:', path);
        }

        this.handle404();
    }

    matchRoute(pattern, path) {
        return window.matchRoutePath ? window.matchRoutePath(pattern, path) : null;
    }

    handle404() {
        this.currentRoute = '404';
        console.log('No route found for:', window.location.pathname);
        showPost();
        displayPost();
    }

    getCurrentRoute() {
        return this.currentRoute;
    }

    getParams() {
        return this.params;
    }

    getRouteInfo(routeKey) {
        return window.ROUTES ? (window.ROUTES[routeKey] || null) : null;
    }

    hideAllLegalPages() {
        const legalPages = ['privacy-page', 'terms-page', 'store-page'];
        legalPages.forEach(pageId => {
            const page = DOM.get(pageId);
            if (page && page.style.display !== 'none') {
                page.style.display = 'none';
            }
        });
    }
}

console.log('ðŸ”§ Creating router, current auth state - window.user:', window.user, 'loading_steps:', window.loading_steps);
window.router = new VAPRRouter();

window.addEventListener('popstate', () => {
    router.handleRoute();
});
console.log('Routes are now defined in /shared/routes.js and automatically loaded by the unified router');
const ROUTES = {
    home: {
        path: '/',
        meta: {
            title: 'VAPR - The Gamer\'s Social Network',
            description: 'Join RSPWN - The Gamer\'s Social Network. Connect with gamers, share content, and grow your audience.',
            requiresAuth: false
        },
        frontend: () => {
            showInitialPost();
        }
    },

    post: {
        path: '/post/:id',
        meta: {
            title: 'VAPR Post',
            description: 'Check out this post on VAPR',
            requiresAuth: false
        },
        frontend: (params) => {
            showPost();
            displayPost(params.id);
        }
    },

    profile: {
        path: '/@:username',
        meta: {
            title: 'VAPR Profile',
            description: 'View this user\'s profile on VAPR',
            requiresAuth: false
        },
        frontend: async (params) => {
            hidePost();
            cardManager.show('profile-card');
        }
    },

    library: {
        path: '/library',
        meta: {
            title: 'My Library - VAPR',
            description: 'Your personal game library on VAPR',
            requiresAuth: true
        },
        frontend: async () => {
            hidePost();
            if (!isUserLoggedIn()) {
                openRegisterModal();
                return;
            }
            await cardManager.show('library-card');
        }
    },

    newPost: {
        path: '/new-post',
        meta: {
            title: 'Create New Post - VAPR',
            description: 'Share your content with the RSPWN community',
            requiresAuth: true
        },
        frontend: async () => {
            hidePost();
            openAddPostPage();
        }
    },

    create: {
        path: '/create',
        meta: {
            title: 'Create New Post - VAPR',
            description: 'Share your content with the RSPWN community',
            requiresAuth: true
        },
        frontend: async () => {
            hidePost();
            openAddPostPage();
        }
    },

    downloads: {
        path: '/downloads',
        meta: {
            title: 'Downloads - VAPR',
            description: 'Manage your game downloads',
            requiresAuth: true
        },
        frontend: async () => {
            hidePost();
            await openDownloadsPage();
        }
    },

    terms: {
        path: '/terms',
        meta: {
            title: 'Terms of Service - VAPR',
            description: 'VAPR Terms of Service - Read our platform guidelines and user agreement',
            requiresAuth: false
        },
        frontend: () => {
            console.log('Terms route handler called');
            console.log('hidePost function exists:', typeof hidePost);
            console.log('openTermsPage function exists:', typeof openTermsPage);

            if (typeof hidePost === 'function') {
                console.log('Calling hidePost...');
                hidePost();
                console.log('hidePost called');
            }

            if (typeof openTermsPage === 'function') {
                console.log('Calling openTermsPage...');
                openTermsPage();
                console.log('openTermsPage called');
            }
        }
    },

    privacy: {
        path: '/privacy',
        meta: {
            title: 'Privacy Policy - VAPR',
            description: 'VAPR Privacy Policy - Learn how we protect and handle your personal information',
            requiresAuth: false
        },
        frontend: () => {
            console.log('Privacy route handler called');
            console.log('hidePost function exists:', typeof hidePost);
            console.log('openPrivacyPage function exists:', typeof openPrivacyPage);
            hidePost();
            openPrivacyPage();
        }
    },

    store: {
        path: '/store',
        meta: {
            title: 'Game Store - VAPR',
            description: 'VAPR Game Store - Discover and purchase amazing games and digital content',
            requiresAuth: false
        },
        frontend: () => {
            hidePost();
            openStorePage();
        }
    },

    creators: {
        path: '/creators',
        meta: {
            title: 'Creator Program - VAPR',
            description: 'Join the VAPR Creator Program and monetize your content',
            requiresAuth: true
        },
        frontend: () => {
            hidePost();
            window.open('/creators', '_blank');
        }
    },

    partners: {
        path: '/partners',
        meta: {
            title: 'Partner Portal - VAPR',
            description: 'Manage your partnership with VAPR',
            requiresAuth: true
        },
        frontend: () => {
            hidePost();
            window.open('/partners', '_blank');
        }
    },


    signup: {
        path: '/signup',
        meta: {
            title: 'Sign Up - RSPWN',
            description: 'Create your RSPWN account',
            requiresAuth: false
        },
        frontend: () => {
            hidePost();
            openSignupPage();
        }
    },

    signin: {
        path: '/signin',
        meta: {
            title: 'Sign In - RSPWN',
            description: 'Sign in to your RSPWN account',
            requiresAuth: false
        },
        frontend: () => {
            hidePost();
            openSigninPage();
        }
    },

    games: {
        path: '/games/:gameName',
        meta: {
            title: 'Game - VAPR',
            description: 'View game details on VAPR',
            requiresAuth: false
        },
        frontend: (params) => {
            hidePost();
            if (typeof openGamePage === 'function') {
                openGamePage(params.gameName);
            } else {
                router.navigate(`/games/${params.gameName}`, false);
            }
        }
    },

    checkoutSuccess: {
        path: '/checkout/success',
        meta: {
            title: 'Purchase Successful - VAPR',
            description: 'Your purchase was successful',
            requiresAuth: false
        },
        frontend: () => {
            hidePost();
            if (typeof showCheckoutSuccess === 'function') {
                showCheckoutSuccess();
            }
        }
    },

    checkoutCancel: {
        path: '/checkout/cancel',
        meta: {
            title: 'Purchase Cancelled - VAPR',
            description: 'Your purchase was cancelled',
            requiresAuth: false
        },
        frontend: () => {
            hidePost();
            if (typeof showCheckoutCancel === 'function') {
                showCheckoutCancel();
            }
        }
    }
};

function getRouteByPath(path) {
    for (const [key, route] of Object.entries(ROUTES)) {
        if (matchRoutePath(route.path, path)) {
            return { key, route };
        }
    }
    return null;
}

function matchRoutePath(pattern, path) {
    const patternParts = pattern.split('/').filter(Boolean);
    const pathParts = path.split('/').filter(Boolean);

    if (patternParts.length !== pathParts.length) return false;

    const params = {};

    for (let i = 0; i < patternParts.length; i++) {
        if (patternParts[i].startsWith(':')) {
            const paramName = patternParts[i].slice(1);
            params[paramName] = decodeURIComponent(pathParts[i]);
        } else if (patternParts[i] !== pathParts[i]) {
            return false;
        }
    }

    return { params };
}

function extractParams(pattern, path) {
    const match = matchRoutePath(pattern, path);
    return match ? match.params : {};
}

function buildPath(routeKey, params = {}) {
    const route = ROUTES[routeKey];
    if (!route) return null;

    let path = route.path;
    for (const [key, value] of Object.entries(params)) {
        path = path.replace(`:${key}`, encodeURIComponent(value));
    }

    return path;
}

function getAllPaths() {
    return Object.values(ROUTES).map(route => route.path);
}

function getStaticPaths() {
    return Object.values(ROUTES)
        .filter(route => !route.path.includes(':'))
        .map(route => route.path);
}

window.ROUTES = ROUTES;
window.getRouteByPath = getRouteByPath;
window.matchRoutePath = matchRoutePath;
window.extractParams = extractParams;
window.buildPath = buildPath;
window.getAllPaths = getAllPaths;
window.getStaticPaths = getStaticPaths;

console.log('Unified routes system loaded with', Object.keys(ROUTES).length, 'routes');
class VAPRTemplateEngine {
    constructor() {
        this.templates = new Map();
        this.rendered = new WeakSet();
        this.hooks = new Map();
    }

    init() {
        this.loadTemplates();
        this.processDocument();
        this.observeDOM();
    }

    on(selector, event, callback) {
        const key = `${selector}:${event}`;
        if (!this.hooks.has(key)) {
            this.hooks.set(key, []);
        }
        this.hooks.get(key).push(callback);
    }

    emit(element, event) {
        const tagName = element.tagName.toLowerCase();
        const id = element.id;
        const classes = Array.from(element.classList);

        const selectors = [
            tagName,
            ...classes.map(c => `.${c}`),
            id ? `#${id}` : null
        ].filter(Boolean);

        selectors.forEach(selector => {
            const key = `${selector}:${event}`;
            if (this.hooks.has(key)) {
                this.hooks.get(key).forEach(callback => {
                    callback(element);
                });
            }
        });

        const customSelectors = element.getAttribute('data-hook');
        if (customSelectors) {
            customSelectors.split(' ').forEach(selector => {
                const key = `${selector}:${event}`;
                if (this.hooks.has(key)) {
                    this.hooks.get(key).forEach(callback => {
                        callback(element);
                    });
                }
            });
        }
    }

    loadTemplates() {
        const templates = document.querySelectorAll('template[data-vapr]');
        templates.forEach(template => {
            const name = template.dataset.vapr;
            this.templates.set(name.toLowerCase(), template.innerHTML.trim());
        });
        console.log(`VAPR: Loaded ${this.templates.size} templates`);
    }

    processDocument() {
        this.templates.forEach((template, name) => {
            this.processElements(name);
        });
    }

    processElements(tagName) {
        const elements = document.querySelectorAll(tagName);
        elements.forEach(element => {
            if (!this.rendered.has(element)) {
                this.renderElement(element, tagName);
            }
        });
    }

    processConditionals(html, attributes) {
        const processBlock = (text, isNegative) => {
            const regex = isNegative
                ? /\{\{\^([\w-]+)\}\}/g
                : /\{\{#([\w-]+)\}\}/g;

            let result = text;
            let match;

            const openings = [];
            while ((match = regex.exec(text)) !== null) {
                openings.push({
                    attr: match[1],
                    start: match.index,
                    end: match.index + match[0].length,
                    tag: match[0]
                });
            }

            for (let i = openings.length - 1; i >= 0; i--) {
                const opening = openings[i];
                const closingTag = `{{/${opening.attr}}}`;
                const closingIndex = result.indexOf(closingTag, opening.end);

                if (closingIndex !== -1) {
                    const content = result.substring(opening.end, closingIndex);
                    const value = attributes[opening.attr];

                    let shouldShow;
                    if (isNegative) {
                        shouldShow = !value || value === 'false' || value === '';
                    } else {
                        shouldShow = value && value !== 'false' && value !== '';
                    }

                    const replacement = shouldShow ? this.processConditionals(content, attributes) : '';

                    result = result.substring(0, opening.start) +
                        replacement +
                        result.substring(closingIndex + closingTag.length);
                }
            }

            return result;
        };

        html = processBlock(html, true);
        html = processBlock(html, false);

        return html;
    }

    renderElement(element, tagName) {
        const template = this.templates.get(tagName.toLowerCase());
        if (!template) return;

        const content = element.innerHTML;
        const attributes = {};

        for (let attr of element.attributes) {
            attributes[attr.name] = attr.value;
        }

        let html = template;

        html = html.replace(/<slot\s*\/?>/gi, content);

        html = this.processConditionals(html, attributes);

        html = html.replace(/\{\{([\w-]+)\}\}/g, (match, attrName) => {
            const value = attributes[attrName];
            return value !== undefined && value !== null ? value : '';
        });

        const wrapper = document.createElement('div');
        wrapper.innerHTML = html;

        let rootElement;
        let elementsToEmit = [];

        if (wrapper.children.length === 1) {
            const newElement = wrapper.firstElementChild;

            for (let attr of element.attributes) {
                if (!newElement.hasAttribute(attr.name)) {
                    newElement.setAttribute(attr.name, attr.value);
                }
            }

            element.replaceWith(newElement);
            rootElement = newElement;

            elementsToEmit = [newElement, ...newElement.querySelectorAll('*')];
        } else {
            element.innerHTML = wrapper.innerHTML;
            rootElement = element;

            elementsToEmit = [element, ...element.querySelectorAll('*')];
        }

        this.rendered.add(rootElement);

        elementsToEmit.forEach(el => {
            this.emit(el, 'created');
        });

        requestAnimationFrame(() => {
            if (rootElement.isConnected) {
                const connectedElements = wrapper.children.length === 1
                    ? [rootElement, ...rootElement.querySelectorAll('*')]
                    : [rootElement, ...rootElement.querySelectorAll('*')];

                connectedElements.forEach(el => {
                    if (el.isConnected) {
                        this.emit(el, 'mounted');
                    }
                });
            }
        });
    }

    observeDOM() {
        const observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === 1) {
                        const tagName = node.tagName?.toLowerCase();

                        if (tagName && this.templates.has(tagName)) {
                            if (!this.rendered.has(node)) {
                                this.renderElement(node, tagName);
                            }
                        }

                        this.templates.forEach((template, name) => {
                            const children = node.querySelectorAll(name);
                            children.forEach(child => {
                                if (!this.rendered.has(child)) {
                                    this.renderElement(child, name);
                                }
                            });
                        });
                    }
                });
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    }

    refresh() {
        this.rendered = new WeakSet();
        this.processDocument();
    }

    render(element) {
        const tagName = element.tagName.toLowerCase();
        if (this.templates.has(tagName)) {
            this.renderElement(element, tagName);
        }
    }

    querySelector(selector) {
        return document.querySelector(selector);
    }

    querySelectorAll(selector) {
        return document.querySelectorAll(selector);
    }

    createElement(tagName, attributes = {}) {
        const element = document.createElement(tagName);

        Object.entries(attributes).forEach(([key, value]) => {
            const attrName = key.replace(/([A-Z])/g, '-$1').toLowerCase();

            if (value === null || value === undefined) {
                return;
            } else if (typeof value === 'boolean') {
                element.setAttribute(attrName, value.toString());
            } else if (typeof value === 'object') {
                element.setAttribute(attrName, JSON.stringify(value));
            } else {
                element.setAttribute(attrName, value.toString());
            }
        });

        return element;
    }

    createElements(tagName, dataArray) {
        return dataArray.map(data => this.createElement(tagName, data));
    }

    appendElements(container, tagName, dataArray) {
        const elements = this.createElements(tagName, dataArray);
        elements.forEach(el => container.appendChild(el));
        return elements;
    }
}

window.VAPR = new VAPRTemplateEngine();
window.VAPR.init();

VAPR.on('.menu-section', 'mounted', (element) => {
    const title = element.querySelector('.menu-section-title');
    if (title && title.textContent === 'Desktop App' && typeof window.__TAURI__ !== 'undefined') {
        element.style.display = 'none';
    }
});
function createAddPostPage(content) {
    return `
    <section id="add-post-page" class="add-post-page-container" style="display:none;">
        <button id="add_post_menu_btn" class="create-post-btn glass_bt" onclick="openMenu()"><i class="fa-solid fa-bars"></i></button>

        <div class="add-post-header">
            <div class="add-post-header-content">
                <div class="add-post-title-section">
                    <h1 class="add-post-title">Create Post</h1>
                    <p class="add-post-subtitle">Share your content with the RSPWN community</p>
                </div>
            </div>
        </div>

        <div class="add-post-body">
            <div class="add-post-content">
                ${content}
            </div>
        </div>
    </section>`;
}

function openAddPostPage() {
    let addPostPage = DOM.get('add-post-page');
    const feed = DOM.get('feed');

   
    if (!addPostPage) {
        const addPostContent = createAddPostContent();
        const addPostPageHTML = createAddPostPage(addPostContent);

       
        const main = document.querySelector('main');
        if (main) {
            main.insertAdjacentHTML('beforeend', addPostPageHTML);
            addPostPage = DOM.get('add-post-page');
        }
    }

    if (addPostPage && feed) {
       
        feed.style.display = 'none';
        addPostPage.style.display = 'flex';

       
        const addPostBody = addPostPage.querySelector('.add-post-page-body');
        if (addPostBody) {
            addPostBody.scrollTop = 0;
        }

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'add-post'}, 'Create New Post - RSPWN', '/create');
        }

       
        document.title = 'Create New Post - RSPWN';

       
        if (window.user && window.user.backgroundId) {
            equipBackground(window.user.backgroundId, false);
        }

       
        setupCharacterCounter();
    }
}

function closeAddPostPage() {
    const addPostPage = DOM.get('add-post-page');
    const feed = DOM.get('feed');

    if (addPostPage && feed) {
       
        addPostPage.style.display = 'none';
        feed.style.display = 'block';

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'home'}, 'RSPWN', '/');
        }

       
        document.title = 'RSPWN';

       
        clearAddPostForm();
    }
}

function createAddPostContent() {
    return `
        <div class="add-post-form-container">
            <form id="postForm" class="add-post-form">
                <div class="quick-post-section">
                    <div class="title-input-group">
                        <input type="text" id="title" name="title" placeholder="What's on your mind?" required maxlength="100" class="quick-title-input">
                        <div class="character-count">
                            <span id="title-count">0</span>/100
                        </div>
                    </div>

                    <div class="upload-area" onclick="document.getElementById('file').click()">
                        <div class="upload-placeholder" id="upload-placeholder">
                            <div class="upload-content">
                                <div class="upload-icon">
                                    <i class="fa-solid fa-plus"></i>
                                </div>
                                <span>Add media</span>
                            </div>
                        </div>
                        <div class="upload-preview" id="upload-preview" style="display:none;">
                            <img id="preview_img" src="" alt="Preview">
                            <video id="preview_video" src="" controls></video>
                            <div class="preview-overlay">
                                <button type="button" class="change-media-btn glass-button" onclick="document.getElementById('file').click()">
                                    <i class="fa-solid fa-camera"></i>
                                </button>
                            </div>
                        </div>
                        <input type="file" id="file" name="file" hidden accept="image/*,video/*">
                    </div>

                    <div class="quick-actions">
                        <button type="submit" class="submit-btn glass-button primary" id="submit-post-btn" onclick="submitPost(event)">
                            <i class="fa-solid fa-paper-plane"></i>
                            Post
                        </button>
                    </div>
                </div>

                <div class="upload-progress" id="upload-progress" style="display:none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <p class="progress-text">Uploading your content...</p>
                </div>
            </form>
        </div>
    `;
}

function setupCharacterCounter() {
    const titleInput = DOM.get('title');
    const titleCount = DOM.get('title-count');

    if (titleInput && titleCount) {
        titleInput.addEventListener('input', function() {
            titleCount.textContent = this.value.length;
        });
    }
}

function clearAddPostForm() {
    const form = DOM.get('postForm');
    if (form) {
        form.reset();

       
        const titleCount = DOM.get('title-count');
        if (titleCount) {
            titleCount.textContent = '0';
        }

       
        const uploadPreview = DOM.get('upload-preview');
        const uploadPlaceholder = DOM.get('upload-placeholder');
        if (uploadPreview && uploadPlaceholder) {
            uploadPreview.style.display = 'none';
            uploadPlaceholder.style.display = 'flex';
        }
    }
}

window.addEventListener('popstate', function(event) {
    const path = window.location.pathname;

    if (path === '/create' || path === '/new-post') {
        openAddPostPage();
    } else {
        const addPostPage = DOM.get('add-post-page');
        if (addPostPage && addPostPage.style.display !== 'none') {
            closeAddPostPage();
        }
    }
});

document.addEventListener('DOMContentLoaded', function() {
    const path = window.location.pathname;
    if (path === '/create' || path === '/new-post') {
       
        setTimeout(() => {
            openAddPostPage();
        }, 100);
    }
});

if (typeof window !== 'undefined') {
    window.openAddPostPage = openAddPostPage;
    window.closeAddPostPage = closeAddPostPage;
    window.clearAddPostForm = clearAddPostForm;
}
class API {
    constructor() {
        this.baseURL = '';
        this.defaultHeaders = {
            'Content-Type': 'application/json'
        };
    }

    clearAuth() {
        localStorage.removeItem('userData');
        window.user = null;
    }

    async request(path, options = {}) {
        const {
            method = 'GET',
            body = null,
            requireAuth = true,
            headers = {},
            isFormData = false
        } = options;

        const requestHeaders = {
            ...(!isFormData ? this.defaultHeaders : {}),
            ...headers
        };

        try {
            const response = await fetch(path, {
                method,
                headers: requestHeaders,
                body: isFormData ? body : (body ? JSON.stringify(body) : null),
                credentials: 'include'
            });

            if (!response.ok) {
                if (response.status === 401 && requireAuth) {
                    this.clearAuth();
                   
                    throw new Error('Unauthorized');
                }
                throw new Error(`Network response was not ok: ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            throw error;
        }
    }

    get(path, requireAuth = true) {
        return this.request(path, { requireAuth });
    }

    post(path, body, options = {}) {
        return this.request(path, {
            method: 'POST',
            body,
            ...options
        });
    }

    async getMe() {
        return this.get('/me');
    }

    async getFeed() {
        return this.get('/feed', false);
    }

    async getPost(id) {
        if (!/^[a-f0-9-]{36}$/.test(id)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/posts/${id}`, false);
    }

    async createPost(formData) {
        return this.request('/posts', {
            method: 'POST',
            body: formData,
            isFormData: true,
            requireAuth: true
        });
    }

    async likePost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/like/${postId}`);
    }

    async dislikePost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/dislike/${postId}`);
    }

    async skipPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/skip/${postId}`);
    }

    async followPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/manage-follow?action=follow&postId=${postId}`);
    }

    async unfollowPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/manage-follow?action=unfollow&postId=${postId}`);
    }

    async checkFollowStatus(creatorId) {
        const data = await this.get(`/check-follow/${creatorId}`);
        return data.isFollowing || false;
    }

    async addReaction(postId, emoji) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        const allowedEmojis = ['ðŸ’©', 'ðŸ‘€', 'ðŸ˜‚', 'â¤ï¸', 'ðŸ’¯', 'null'];
        if (!allowedEmojis.includes(emoji)) {
            throw new Error('Invalid emoji');
        }
        return this.get(`/add-reaction?postId=${postId}&emoji=${encodeURIComponent(emoji)}`);
    }

    async getReactions(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/get-reactions?postId=${postId}`, false);
    }

    async registerView(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/register-view?postId=${postId}`, false);
    }

    async getMyPosts() {
        return this.get('/me/posts');
    }

    async updateBackground(backgroundUrl) {
        return this.get(`/me/update-background?backgroundId=${encodeURIComponent(backgroundUrl)}`);
    }

    async acceptInvitation(ambassadorUserId) {
        return this.get(`/accept-invitation?ambassadorUserId=${ambassadorUserId}`);
    }

    async getUserCount() {
        const response = await fetch('/api/user-count', {
            credentials: 'include'
        });
        return response.json();
    }

    async getUser(userId) {
        return this.get(`/api/user/${userId}`, false);
    }

    async getUserPosts(userId) {
        if (!userId) {
            throw new Error('userId required');
        }
        return this.get(`/api/user/${userId}/posts`, false);
    }

    async resolvePost(input) {
        if (!input) {
            throw new Error('id or url required');
        }
        if (typeof input === 'object') {
            if (input.id) {
                return this.get(`/api/post/resolve?id=${encodeURIComponent(input.id)}`, false);
            }
            if (input.url) {
                return this.get(`/api/post/resolve?url=${encodeURIComponent(input.url)}`, false);
            }
        }
        const str = String(input);
        if (/^[a-f0-9-]{36}$/i.test(str)) {
            return this.get(`/api/post/resolve?id=${encodeURIComponent(str)}`, false);
        }
        return this.get(`/api/post/resolve?url=${encodeURIComponent(str)}`, false);
    }

    async recordPlaytimeSession({ gameId, startedAt, endedAt, durationSeconds, executablePath }) {
        return this.post('/api/playtime/session', { gameId, startedAt, endedAt, durationSeconds, executablePath });
    }

    async getPlaytimeTotals() {
        return this.get('/api/playtime/totals');
    }
}

class APIHandler {
    static async handle(apiCall, options = {}) {
        const {
            onSuccess = () => {},
            onError = null,
            showLoading = false,
            successMessage = null,
            errorMessage = 'An error occurred',
            updateXP = false
        } = options;

        if (showLoading) showLoading();

        try {
            const data = await apiCall();

            if (updateXP && window.user && data.user) {
                const oldUser = {
                    xp: window.user.xp,
                    level: window.user.level,
                    xp_required: window.user.xp_required
                };
                window.user = data.user;
                setXPProgress(oldUser);
            }

            if (successMessage && window.notify) {
                window.notify.success(successMessage);
            }

            await onSuccess(data);
            return data;

        } catch (error) {
            console.error(error);

            if (onError) {
                await onError(error);
            } else if (window.notify) {
                window.notify.error('Error', errorMessage);
            }

            throw error;
        } finally {
            if (showLoading) hideLoading();
        }
    }
}

const api = new API();
window.api = api;
window.APIHandler = APIHandler;

window.makeApiRequest = function(path, requireAuth = true) {
    return api.get(path, requireAuth);
};

if (typeof window !== 'undefined' && window.__TAURI__ && window.__TAURI__.event && window.__TAURI__.core) {
    try {
        window.__TAURI__.event.listen('sdk-request', async (event) => {
            const { id, name, payload } = event.payload || {};
            if (!id || !name) return;
            try {
                let data;
                switch (name) {
                    case 'getFeed':
                        data = await api.getFeed();
                        break;
                    case 'getUserPosts':
                        data = await api.getUserPosts(payload && payload.userId);
                        break;
                    case 'resolvePost':
                        data = await api.resolvePost(payload);
                        break;
                    default:
                        throw new Error('Unknown sdk-request: ' + name);
                }
                await window.__TAURI__.core.invoke('sdk_response', { id, ok: true, data });
            } catch (err) {
                await window.__TAURI__.core.invoke('sdk_response', { id, ok: false, error: String(err && err.message || err) });
            }
        });
    } catch (e) {
        console.error('Failed to setup Tauri sdk-request listener', e);
    }
}
function loadUserData(){
    console.log('ðŸ”„ loadUserData() started');
    DOM.hide("sign_in");
    DOM.hide("add_post");

    api.getMe().then(function(data){
        console.log('âœ… api.getMe() success, setting window.user:', data);
        window.user = data;

        if (window.invalidateUserLoginCache) {
            window.invalidateUserLoginCache();
        }

        if (window.updateSDKUserInfo) {
            window.updateSDKUserInfo();
        }

        if (window.menuManager) {
            window.menuManager.updateMenu();
        }

        updateUsername();
        updateLevel();

        try {
            if (typeof updateApplyUIForAuth === 'function') updateApplyUIForAuth();
        } catch (e) { }

        const oldUser = {
            xp: 0,
            level: window.user.level,
            xp_required: window.user.xp_required
        };

        setXPProgress(oldUser, true);

        syncBackgroundFromBackend();

        DOM.hide("sign_in");
        DOM.show("add_post");

        DOM.show("xp_bar");

        loading_steps--;
        window.loading_steps = loading_steps;

        handleReferral();

        loadGamesData().then(() => {
            updateDeveloperSection();
            const accountSection = DOM.get('account_section');
            if (accountSection) DOM.show(accountSection);
            if (typeof showAuthRequiredElements === 'function') {
                showAuthRequiredElements();
            }
        });

        checkAndShowUpdates();
    }).catch(error => {
        console.log('âŒ api.getMe() failed, user not logged in:', error);

        if (window.invalidateUserLoginCache) {
            window.invalidateUserLoginCache();
        }

        DOM.show("sign_in");
        DOM.hide("add_post");
        DOM.get("add_post").onclick = openRegisterModal;
        loading_steps--;
        window.loading_steps = loading_steps;

        if (window.menuManager) {
            window.menuManager.updateMenu();
        }

        try {
            if (typeof updateApplyUIForAuth === 'function') updateApplyUIForAuth();
        } catch (e) { }

        const accountSection = DOM.get('account_section');
        if (accountSection) DOM.hide(accountSection);
        if (typeof hideAuthRequiredElements === 'function') {
            hideAuthRequiredElements();
        }
    })
}

function syncBackgroundFromBackend() {
    console.log(window.user);
    if (window.user && window.user.backgroundId) {
        equipBackground(window.user.backgroundId, false);
        console.log('Background synchronized from backend:', window.user.backgroundId);
    } else {
        const background_id = localStorage.getItem('background_id');
        if (background_id) {
            equipBackground(background_id, false);
        } else {
            setDefaultBackground();
        }
    }
}
async function equipBackground(postId, save = true) {
    let imageUrl = null;

    if (window.currentPostId === postId && window.currentPostImageUrl) {
        imageUrl = window.currentPostImageUrl;
    } else {
        imageUrl = await loadBackgroundFromPost(postId);
    }

    if (imageUrl) {
        document.body.style.backgroundImage = 'url(' + imageUrl + ')';

        localStorage.setItem('background_url', imageUrl);
        localStorage.setItem('background_id', postId);

        if (save && isUserLoggedIn() && navigator.onLine) {
            api.updateBackground(postId)
                .then(response => {
                    console.log('Background synced successfully:', response);
                    if (window.user) {
                        window.user.backgroundId = postId;
                    }
                })
                .catch(error => {
                    console.error('Failed to sync background:', error);
                });
        }
    }
}

async function loadBackgroundFromPost(postId) {
    try {
        const post = await api.resolvePost(postId);
        if (post && post.media) {
            document.body.style.backgroundImage = 'url(' + post.media + ')';
            return post.media;
        }
    } catch (error) {
        console.error('Failed to load background from post:', error);
    }
    return null;
}

function setDefaultBackground() {
    const defaultBgUrl = "2133e675-b741-4da0-9bd9-d519bfb72e1e";
    equipBackground(defaultBgUrl, true);
}
let discordMembersCache = null;
let discordMembersFetching = false;
const processedDiscordElements = new WeakSet();

async function updateDiscordMembers(element) {
    if (!element) {
        console.warn('Discord members element not found');
        return;
    }

    if (processedDiscordElements.has(element)) {
        return;
    }
    processedDiscordElements.add(element);

    if (discordMembersCache !== null) {
        element.innerHTML = `<i class="fa-solid fa-users"></i> ${discordMembersCache.toLocaleString()}`;
        return;
    }

    if (discordMembersFetching) {
        return;
    }

    discordMembersFetching = true;
    console.log('Fetching Discord members for element:', element);

    try {
        const response = await fetch('https://discord.com/api/guilds/1226141081964515449/widget.json');
        if (!response.ok) throw new Error('Discord API error');

        const data = await response.json();
        const memberCount = data.presence_count || 0;
        discordMembersCache = memberCount;

        console.log('Discord member count:', memberCount);

        document.querySelectorAll('#discord_members .menu-badge, .menu-badge.members').forEach(el => {
            el.innerHTML = `<i class="fa-solid fa-users"></i> ${memberCount.toLocaleString()}`;
        });
    } catch (error) {
        console.error('Failed to fetch Discord member count:', error);
        document.querySelectorAll('#discord_members .menu-badge, .menu-badge.members').forEach(el => {
            el.innerHTML = '<i class="fa-solid fa-users"></i> N/A';
        });
    } finally {
        discordMembersFetching = false;
    }
}

window.updateDiscordMembers = updateDiscordMembers;

if (window.VAPR) {
    VAPR.on('#discord_members', 'mounted', (element) => {
        updateDiscordMembers(element.querySelector('.menu-badge'));
    });
}
class DownloadManager {
    constructor() {
        this.downloads = new Map();
        this.queue = [];
        this.activeDownloads = new Set();
        this.maxConcurrentDownloads = 3;
        this.listeners = new Map();
        this.isActive = true;

        if (isRunningInTauri()) {
            this.initTauriListeners();
        }
    }

    pauseEventProcessing() {
        this.isActive = false;
    }

    resumeEventProcessing() {
        this.isActive = true;
    }

    async initTauriListeners() {
        await window.__TAURI__.event.listen('download-progress', (event) => {
            if (this.isActive) {
                this.handleProgress(event.payload);
            }
        });

        await window.__TAURI__.event.listen('download-status', (event) => {
            this.handleStatusChange(event.payload);
        });

        await window.__TAURI__.event.listen('download-complete', (event) => {
            this.handleCompletion(event.payload);
        });

        await window.__TAURI__.event.listen('download-error', (event) => {
            this.handleError(event.payload);
        });

        await window.__TAURI__.event.listen('update-complete', (event) => {
            this.handleUpdateComplete(event.payload);
        });
    }

    async processQueue() {
        while (this.activeDownloads.size < this.maxConcurrentDownloads && this.queue.length > 0) {
            const downloadId = this.queue.shift();
            const download = this.downloads.get(downloadId);

            if (download && download.status === 'queued') {
                await this.startDownload(downloadId);
            }
        }
    }

    async startDownload(downloadId) {
        const download = this.downloads.get(downloadId);
        if (!download) return;

        download.status = 'preparing';
        download.startTime = Date.now();
        this.activeDownloads.add(downloadId);

        this.emit('download-started', download);

        try {
            const result = await window.__TAURI__.core.invoke('start_download', {
                downloadId: downloadId,
                gameId: download.gameId,
                gameName: download.title,
                downloadUrl: download.downloadUrl,
                isUpdate: download.isUpdate,
                version: download.version
            });

            if (!result.success) {
                throw new Error(result.error || 'Download failed to start');
            }

            download.status = 'downloading';
            this.emit('download-status-changed', download);

        } catch (error) {
            download.status = 'error';
            download.error = error.message;
            this.activeDownloads.delete(downloadId);
            this.emit('download-error', download);
            this.processQueue();
        }
    }

    async pauseDownload(downloadId) {
        const download = this.downloads.get(downloadId);
        if (!download || download.status !== 'downloading') return;

        try {
            await window.__TAURI__.core.invoke('pause_download', { downloadId });
            download.status = 'paused';
            this.activeDownloads.delete(downloadId);
            this.emit('download-paused', download);
            this.processQueue();
        } catch (error) {
            console.error('Failed to pause download:', error);
        }
    }

    async resumeDownload(downloadId) {
        const download = this.downloads.get(downloadId);
        if (!download || download.status !== 'paused') return;

        if (this.activeDownloads.size >= this.maxConcurrentDownloads) {
            download.status = 'queued';
            this.queue.push(downloadId);
            this.emit('download-queued', download);
            return;
        }

        try {
            await window.__TAURI__.core.invoke('resume_download', { downloadId });
            download.status = 'downloading';
            this.activeDownloads.add(downloadId);
            this.emit('download-resumed', download);
        } catch (error) {
            console.error('Failed to resume download:', error);
        }
    }

    async cancelDownload(downloadId) {
        const download = this.downloads.get(downloadId);
        if (!download) return;

        try {
            await window.__TAURI__.core.invoke('cancel_download', { downloadId });

            this.activeDownloads.delete(downloadId);
            this.queue = this.queue.filter(id => id !== downloadId);

            if (download.status !== 'completed') {
                this.downloads.delete(downloadId);
                this.emit('download-cancelled', download);
            }

            this.processQueue();
        } catch (error) {
            console.error('Failed to cancel download:', error);
        }
    }

    handleProgress(payload) {
        const download = this.downloads.get(payload.download_id);
        if (!download) return;

        download.progress = payload.percentage;
        download.downloadedSize = payload.downloaded;
        download.totalSize = payload.total;
        download.speed = payload.speed;
        download.eta = payload.eta;
        download.status = 'downloading';

        this.emit('download-progress', download);
    }

    handleStatusChange(payload) {
        const download = this.downloads.get(payload.download_id);
        if (!download) return;

        download.status = payload.status;
        download.statusText = payload.message;

        this.emit('download-status-changed', download);
    }

    handleCompletion(payload) {
        const download = this.downloads.get(payload.download_id);
        if (!download) return;

        download.status = 'completed';
        download.progress = 100;
        download.endTime = Date.now();
        download.installPath = payload.install_path;
        download.executable = payload.executable;

        this.activeDownloads.delete(payload.download_id);
        this.emit('download-completed', download);
        this.processQueue();
    }

    handleError(payload) {
        const download = this.downloads.get(payload.download_id);
        if (!download) return;

        download.status = 'error';
        download.error = payload.error;

        this.activeDownloads.delete(payload.download_id);
        this.emit('download-error', download);

        this.processQueue();
    }

    async handleUpdateCompleted(payload) {
        if (window.gamesData) {
            window.gamesData.updatingGames.delete(payload.gameId);
            window.gamesData.updates = window.gamesData.updates.filter(u => u.gameId !== payload.gameId);

            const installedGame = window.gamesData.installedGames.find(g => g.id === payload.gameId);
            if (installedGame) {
                installedGame.version = payload.version;
            }
        }

        if (window.notify) {
            window.notify.success(`${payload.gameName} updated to v${payload.version}!`);
        }

        if (window.cardManager && window.cardManager.currentCard === 'library-card') {
            if (typeof window.loadLibraryData === 'function') {
                window.loadLibraryData();
            }
        }
    }

    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
    }

    off(event, callback) {
        if (!this.listeners.has(event)) return;

        const callbacks = this.listeners.get(event);
        const index = callbacks.indexOf(callback);
        if (index > -1) {
            callbacks.splice(index, 1);
        }
    }

    emit(event, data) {
        if (!this.listeners.has(event)) return;

        if (!this.isActive && !['download-completed', 'download-error'].includes(event)) {
            return;
        }

        this.listeners.get(event).forEach(callback => {
            try {
                callback(data);
            } catch (error) {
                console.error(`Error in download manager listener for ${event}:`, error);
            }
        });
    }

    getDownloads() {
        return Array.from(this.downloads.values());
    }

    getActiveDownloads() {
        return this.getDownloads().filter(d => d.status === 'downloading');
    }

    getQueuedDownloads() {
        return this.getDownloads().filter(d => d.status === 'queued');
    }

    getCompletedDownloads() {
        return this.getDownloads().filter(d => d.status === 'completed');
    }

    clearCompleted() {
        const completed = this.getCompletedDownloads();
        completed.forEach(download => {
            this.downloads.delete(download.id);
        });
        this.emit('downloads-cleared', completed);
    }

    addDownload(downloadInfo) {
        this.downloads.set(downloadInfo.id, downloadInfo);
        if (this.activeDownloads.size < this.maxConcurrentDownloads) {
            this.startDownload(downloadInfo.id);
        } else {
            downloadInfo.status = 'queued';
            this.queue.push(downloadInfo.id);
        }
    }
}

window.downloadManager = new DownloadManager();
async function openDownloadsPage() {
    if (!isRunningInTauri()) {
        notify.warning('Desktop App Required', 'The downloads manager requires the VAPR desktop app.');
        return;
    }

    hideMenu();

    try {
       
        await window.__TAURI__.core.invoke('open_downloads_window');
    } catch (error) {
        console.error('Failed to open downloads window:', error);
        notify.error('Failed to open downloads window');
    }
}
async function loadGamesData() {
    try {
        DOM.show('games-loading');

        const [gamesResponse, userGamesResponse, totalsResponse] = await Promise.all([
            api.request('/api/games'),
            isUserLoggedIn() ? api.request('/api/my-games') : Promise.resolve({ games: [] }),
            isUserLoggedIn() ? api.getPlaytimeTotals().catch(() => ({ success: false, totals: [] })) : Promise.resolve({ success: true, totals: [] })
        ]);

        gamesData.allGames = gamesResponse.games || [];
        gamesData.userGames = userGamesResponse.games || [];

        gamesData.playtimeTotals = {};
        if (totalsResponse && totalsResponse.totals) {
            for (const t of totalsResponse.totals) {
                gamesData.playtimeTotals[t.gameId] = t.totalSeconds || 0;
            }
        }

        if (isRunningInTauri()) {
            try {
                const installedGames = await window.__TAURI__.core.invoke('get_installed_games');
                gamesData.installedGames = installedGames || [];
            } catch (error) {
                console.error('Error loading installed games:', error);
                gamesData.installedGames = [];
            }
        }
    } catch (error) {
        console.error('Error loading games:', error);
    } finally {
        DOM.hide('games-loading');
    }
}

async function loadLibraryData() {
    try {
        DOM.show('library-loading');

       
        const response = await api.request('/api/my-games');
        gamesData.userGames = response.games || [];

       
        const totalsResponse = await api.getPlaytimeTotals().catch(() => ({ success: false, totals: [] }));
        gamesData.playtimeTotals = {};
        if (totalsResponse && totalsResponse.totals) {
            for (const t of totalsResponse.totals) {
                gamesData.playtimeTotals[t.gameId] = t.totalSeconds || 0;
            }
        }

       
        if (isRunningInTauri()) {
            try {
                const installedGames = await window.__TAURI__.core.invoke('get_installed_games');
                gamesData.installedGames = installedGames || [];

               
                gamesData.updatingGames.clear();
                gamesData.downloadingGames.clear();

               
                await checkAndShowUpdates();
            } catch (error) {
                console.error('Error loading installed games:', error);
                gamesData.installedGames = [];
            }
        }

        displayLibrary();
    } catch (error) {
        console.error('Error loading library:', error);
    } finally {
        DOM.hide('library-loading');
    }
}
function formatDurationShort(totalSeconds) {
    const seconds = Math.max(0, Math.floor(Number(totalSeconds || 0)));
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    if (hours > 0) return `${hours}h ${minutes}m`;
    if (minutes > 0) return `${minutes}m`;
    return `${secs}s`;
}

function displayLibrary() {
    const container = DOM.get('library-grid');
    container.innerHTML = '';

    if (gamesData.userGames.length === 0) {
        container.innerHTML += '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: rgba(255, 255, 255, 0.6);">No games in your library yet. Redeem a key to get started!</div>';
        return;
    }

    VAPR.appendElements(container, 'library-game-item',
        gamesData.userGames.map(game => {
            const installedGame = gamesData.installedGames.find(g => g.id === game.id);
            const isInstalled = !!installedGame;
            const isDownloading = gamesData.downloadingGames.has(game.id);
            const isUpdating = gamesData.updatingGames.has(game.id);

           
            let hasUpdate = false;
            let updateInfo = null;

            if (isInstalled && game.currentVersion) {
                const installedVersion = installedGame.version || '0.0.0';
                if (isNewerVersion(game.currentVersion, installedVersion)) {
                    hasUpdate = true;
                    updateInfo = {
                        fromVersion: installedVersion,
                        toVersion: game.currentVersion
                    };
                }
            }

            const totalSeconds = Number(gamesData.playtimeTotals?.[game.id] || 0);
            const totalPlaytime = formatDurationShort(totalSeconds);

            return {
                gameId: game.id,
                title: game.title,
                description: game.description,
                coverImage: game.coverImage,
                downloadUrl: game.downloadUrl || '',
                ownedAt: game.ownedAt,
                isInstalled: isInstalled ? 'true' : '',
                isDownloading: isDownloading ? 'true' : '',
                isUpdating: isUpdating ? 'true' : '',
                hasUpdate: hasUpdate ? 'true' : '',
                installedVersion: installedGame?.version || '',
                latestVersion: game.currentVersion || '',
                ...(installedGame?.executable && { executable: installedGame.executable.replaceAll('\\','/') }),
                ...(isDownloading && { downloadProgress: gamesData.downloadingGames.get(game.id) || 0 }),
                totalPlaytime,
                totalPlaytimeSeconds: totalSeconds
            };
        })
    );

    VAPR.refresh();
}
async function downloadGame(gameId, gameTitle, gameCover, downloadUrl, version = null) {
    if (!isRunningInTauri()) {
        notify.desktopAppPrompt(() => downloadDesktopApp());
        return;
    }

    try {
        const game = gamesData.userGames.find(g => g.id === gameId);
        if (!game) {
            throw new Error('Game not found');
        }

       
        if (!version) {
            version = game.currentVersion || game.version || '1.0.0';
        }

        const downloadId = `download-${Date.now()}-${gameId}`;

        await window.__TAURI__.core.invoke('start_download', {
            downloadId: downloadId,
            gameId: gameId,
            gameName: gameTitle,
            gameCover: gameCover,
            downloadUrl: downloadUrl,
            version: version
        });

        console.log({
            downloadId: downloadId,
            gameId: gameId,
            gameName: gameTitle,
            gameCover: gameCover,
            downloadUrl: downloadUrl
        });

        await window.__TAURI__.core.invoke('open_downloads_window');

        notify.success('Download started', `${gameTitle} has been added to your downloads.`);

    } catch (error) {
        console.error('Error starting download:', error);
        notify.error('Download Failed', error.message || 'Failed to start download');
    }
}

function updateGameDownloadProgress(gameId, progress) {
    const gameEl = DOM.get(`game-item-${gameId}`);
    if (!gameEl) return;

    const progressFill = DOM.get(`download-fill-${gameId}`);
    if (progressFill) {
        progressFill.style.width = `${progress.percentage}%`;
    }

    const progressEl = DOM.get(`download-progress-${gameId}`);
    if (progressEl) {
        progressEl.textContent = `${Math.round(progress.percentage)}%`;
    }

    const speedEl = DOM.get(`download-speed-${gameId}`);
    if (speedEl) {
        speedEl.textContent = `${progress.speed.toFixed(2)} MB/s`;
    }

    const sizeEl = DOM.get(`download-size-${gameId}`);
    if (sizeEl) {
        const downloaded = (progress.downloaded / 1024 / 1024).toFixed(2);
        const total = (progress.total / 1024 / 1024).toFixed(2);
        sizeEl.textContent = `${downloaded} MB / ${total} MB`;
    }

    const etaEl = DOM.get(`download-eta-${gameId}`);
    if (etaEl) {
        etaEl.textContent = formatTime(progress.eta);
    }
}

function updateGameDownloadStatus(gameId, statusText) {
    const gameEl = DOM.get(`game-item-${gameId}`);
    if (!gameEl) return;

    const subtitleEl = gameEl.querySelector('.download-progress-subtitle');
    if (subtitleEl) DOM.setText(subtitleEl, statusText);
}

function cancelDownload(gameId) {
    gamesData.downloadingGames.delete(gameId);
    gamesData.updatingGames.delete(gameId);
    displayLibrary();
}

async function uninstallGame(gameId, gameTitle, confirmed = false) {

    if(!confirmed){
        confirmed = await notify.confirmDanger(
            'Uninstall Game?',
            `Are you sure you want to uninstall ${gameTitle}? This will remove all game files from your computer.`,
            'Yes, uninstall'
        );
    }


    if (confirmed) {
        try {
            await window.__TAURI__.core.invoke('uninstall_game', { gameId });
            notify.success(`${gameTitle} uninstalled successfully`);
            await loadLibraryData();
        } catch (error) {
            console.error('Error uninstalling game:', error);
            notify.error('Uninstall Failed', error.message || 'Failed to uninstall the game. Please try again.');
        }
    }
}

async function launchGame(executablePath) {

    if (!isRunningInTauri()) return;

    const button = event.target.closest('button');
    const originalContent = button.innerHTML;
    button.disabled = true;
    button.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Launching...';

    try {
        console.log({executablePath});
        await window.__TAURI__.core.invoke('launch_game', {
            executablePath: executablePath
        });
        notify.success("Game launched!");
    } catch (error) {
        console.error('Error launching game:', error);
        notify.error('Launch Failed', error.message || 'Failed to launch the game. Please try again.');
    } finally {
        button.disabled = false;
        button.innerHTML = originalContent;
    }
}

async function downloadUpdate(gameId, version, gameTitle, gameCover, downloadUrl) {
    if (!isRunningInTauri()) {
        notify.desktopAppPrompt(() => downloadDesktopApp());
        return;
    }

    await uninstallGame(gameId, gameTitle, true);
    downloadGame(gameId, gameTitle, gameCover, downloadUrl, version);
}

function formatTime(seconds) {
    if (seconds === 0) return 'Calculating...';

    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
        return `${hours}h ${minutes}m remaining`;
    } else if (minutes > 0) {
        return `${minutes}m ${secs}s remaining`;
    } else {
        return `${secs}s remaining`;
    }
}

let __vaprPlaytimeUnlisten = null;
async function initPlaytimeListener() {
    if (!isRunningInTauri() || __vaprPlaytimeUnlisten) return;
    __vaprPlaytimeUnlisten = await window.__TAURI__.event.listen('playtime-session', async (event) => {
        try {
            const p = event.payload || {};
           
            const startedAt = p.started_at || p.startedAt;
            const endedAt = p.ended_at || p.endedAt;
            const durationSeconds = Number(p.duration_seconds ?? p.durationSeconds ?? 0);
            const executablePath = p.executable_path || p.executablePath || '';

            let gameId = p.game_id || p.gameId || null;
            if (!gameId && Array.isArray(gamesData.installedGames)) {
                const norm = (s) => String(s || '').replaceAll('\\','/').toLowerCase();
                const match = gamesData.installedGames.find(g => norm(g.executable) === norm(executablePath));
                if (match && match.id) gameId = match.id;
            }

            if (!gameId || !durationSeconds || durationSeconds <= 0) {
                console.warn('Skipping playtime session post due to missing data', p);
                return;
            }

            await APIHandler.handle(
                () => api.recordPlaytimeSession({ gameId, startedAt, endedAt, durationSeconds, executablePath }),
                {
                    onSuccess: async () => {
                        try {
                            const res = await api.getPlaytimeTotals();
                            if (res && res.totals) {
                                gamesData.playtimeTotals = {};
                                for (const t of res.totals) {
                                    gamesData.playtimeTotals[t.gameId] = t.totalSeconds || 0;
                                }
                               
                                if (typeof displayLibrary === 'function') displayLibrary();
                            }
                        } catch (e) {
                            console.error('Failed to refresh playtime totals:', e);
                        }
                    },
                    onError: (e) => console.error('Failed to record playtime session:', e),
                    showLoading: false,
                }
            );
        } catch (err) {
            console.error('Error handling playtime-session event:', err);
        }
    });
}

if (isRunningInTauri()) {
    initPlaytimeListener();
}

window.downloadGame = downloadGame;
window.updateGameDownloadProgress = updateGameDownloadProgress;
window.updateGameDownloadStatus = updateGameDownloadStatus;
window.cancelDownload = cancelDownload;
window.uninstallGame = uninstallGame;
window.launchGame = launchGame;
window.downloadUpdate = downloadUpdate;
cardManager.register('library-card', {
    route: '/library',
    onLoad: async () => {
        await loadLibraryData();
    },
    onShow: () => {
        if (isRunningInTauri()) {
            window.__TAURI__.core.invoke('get_installed_games').then(installedGames => {
                if (installedGames && JSON.stringify(installedGames) !== JSON.stringify(gamesData.installedGames)) {
                    gamesData.installedGames = installedGames;
                    displayLibrary();
                }
            }).catch(console.error);
        }
    }
});

function initGameEventListeners() {
    const gamesGrid = DOM.get('games-grid');
    if (gamesGrid) {
        gamesGrid.addEventListener('click', (e) => {
            const gameItem = e.target.closest('.game-item');
            if (gameItem && !e.target.closest('button')) {
                const gameId = gameItem.id.replace('game-item-', '');
                const game = gamesData.allGames.find(g => g.id === gameId);
                if (game && game.externalLink) {
                    window.open(game.externalLink, '_blank');
                }
            }
        });
    }
}

async function openMyLibrary() {
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }
    hideMenu();
    router.navigate('/library', true);
}

function closeLibraryCard() {
    cardManager.hide('library-card');
}

function openRedeemModal() {
    DOM.show('redeem-modal', 'flex');
    DOM.get('game-key-input').value = '';
    DOM.get('game-key-input').focus();
}

function closeRedeemModal() {
    DOM.hide('redeem-modal');
}

async function redeemKey(event) {
    event.preventDefault();

    const keyInput = DOM.get('game-key-input');
    const key = keyInput.value.trim();

    try {
        const response = await api.request('/api/games/redeem-key', {
            method: 'POST',
            body: { key }
        });

        if (response.success) {
            closeRedeemModal();

            await notify.confirm(
                'Success!',
                `You now own ${response.game.title}!`,
                {
                    icon: 'success',
                    confirmButtonText: 'View Library',
                    showCancelButton: false
                }
            );
            openMyLibrary();
            await loadLibraryData();
        }
    } catch (error) {
        notify.error('Invalid Key', error.message || 'The key you entered is invalid or has already been used.');
    }
}

VAPR.on('.game-tag-item', 'mounted', (element) => {
    const titleEl = element.querySelector('.game-tag-item-title');
    if (titleEl) {
        const gameTitle = titleEl.textContent;
        const toSlug = (s) => String(s)
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
        const slug = toSlug(gameTitle);

        element.onclick = (e) => {
            e.preventDefault();
            router.navigate(`/games/${slug}`, true);
        };
    }
});

window.openTaggedGame = async function() {
    loading.show();
    if (window.currentPostTaggedGame && window.currentPostTaggedGame.id) {
        if (current_post && current_post.id) {
            try {
                const gameId = window.currentPostTaggedGame.id;
                console.log('Tracking game click for game:', gameId, 'post:', current_post.id);

                await api.request('/api/creators/track-game-click', {
                    method: 'POST',
                    body: {
                        gameId: gameId,
                        postId: current_post.id
                    }
                });
                console.log('Successfully tracked game click for creator attribution');
            } catch (error) {
                console.error('Failed to track game click:', error);
            }
        }

        if (!gamesData.tebexGames || gamesData.tebexGames.length === 0) {
            await loadTebexGames();
        }

        const toSlug = (s) => String(s)
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
        const slug = toSlug(window.currentPostTaggedGame.title);

        loading.hide();
        router.navigate(`/games/${slug}`, true);
    }
};

document.addEventListener('DOMContentLoaded', () => {
    initGameEventListeners();
    if (isUserLoggedIn()) {
        setTimeout(checkAndShowUpdates, 3000);
    }
});

setInterval(() => {
    if (isUserLoggedIn()) {
        checkAndShowUpdates();
    }
}, 5 * 60 * 1000);
function openRedeemModal() {
    document.getElementById('redeem-modal').style.display = 'flex';
    document.getElementById('game-key-input').value = '';
    document.getElementById('game-key-input').focus();
}

function closeRedeemModal() {
    document.getElementById('redeem-modal').style.display = 'none';
}

async function redeemKey(event) {
    event.preventDefault();

    const keyInput = document.getElementById('game-key-input');
    const key = keyInput.value.trim();

    try {
        const response = await api.request('/api/games/redeem-key', {
            method: 'POST',
            body: { key }
        });

        if (response.success) {
            closeRedeemModal();

            await notify.confirm(
                'Success!',
                `You now own ${response.game.title}!`,
                {
                    icon: 'success',
                    confirmButtonText: 'View Library',
                    showCancelButton: false
                }
            );

            closeGamesCard();
            openMyLibrary();
            await loadLibraryData();
        }
    } catch (error) {
        notify.error('Invalid Key', error.message || 'The key you entered is invalid or has already been used.');
    }
}
window.gamesData = {
    allGames: [],
    userGames: [],
    currentManagingGame: null,
    installedGames: [],
    downloadingGames: new Map(),
    currentKeyFilter: 'all',
    allKeys: [],
    updates: [],
    versions: [],
    updatingGames: new Map(),
   
    playtimeTotals: {}
};
async function loadTebexGames() {
    try {
       
        const tebexResponse = await tebexAPI.getAllPackages();
        const tebexGames = tebexResponse.data || [];

        console.log('Loaded games from multiple Tebex stores:', tebexGames);

        const transformedGames = transformTebexGames(tebexGames);

        gamesData.tebexGames = transformedGames;

        displayGames();
    } catch (error) {
        console.error('Error loading Tebex games:', error);
    }
}

function transformTebexGames(tebexPackages) {
    return tebexPackages.map(pkg => ({
        id: `tebex-${pkg.id}`,
        title: pkg.name,
        description: pkg.description,
        coverImage: pkg.image || 'https://via.placeholder.com/300x169',
        price: pkg.total_price,
        currency: pkg.currency,
        isTebexProduct: true,
        tebexId: pkg.id,
        category: pkg.category?.name || 'Games',
        onSale: pkg.discount > 0,
        originalPrice: pkg.base_price,
        salePrice: pkg.total_price,
        discount: pkg.discount,
       
        storeInfo: pkg.storeInfo,
        developer: pkg.storeInfo?.username || 'Unknown'
    }));
}
async function findGameIdFromPackageId(packageId) {
    const tebexGame = gamesData.tebexGames?.find(g => g.tebexId === packageId);
    if (tebexGame) {
        const vaprGameId = await findVAPRGameIdByTitle(tebexGame.title);
        return vaprGameId;
    }
    return null;
}

function handleCheckoutSuccess() {
    notify.success('Purchase completed successfully!');

    if (window.loadLibraryData) {
        loadLibraryData();
    }
}

function handleCheckoutCancel() {
    notify.info('Checkout cancelled');
}

document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);

    if (window.location.pathname === '/checkout/success') {
        handleCheckoutSuccess();
        window.history.replaceState({}, '', '/');
    } else if (window.location.pathname === '/checkout/cancel') {
        handleCheckoutCancel();
        window.history.replaceState({}, '', '/');
    }
});

const originalLoadUserData = window.loadUserData;
window.loadUserData = function() {
    originalLoadUserData();
};
async function checkForGameUpdates() {
    return api.request('/api/updates/check');
}

async function markUpdateSeen(gameId) {
    return api.request(`/api/updates/${gameId}/seen`, {
        method: 'POST'
    });
}

async function markUpdateDownloaded(gameId, version) {
    return api.request(`/api/updates/${gameId}/downloaded`, {
        method: 'POST',
        body: { version }
    });
}

async function checkAndShowUpdates() {
    if (!isUserLoggedIn() || !isRunningInTauri()) return;

    try {
       
        const installedGames = await window.__TAURI__.core.invoke('get_installed_games');
        gamesData.installedGames = installedGames || [];

       
        const response = await api.request('/api/my-games');
        if (!response.success || !response.games) return;

        const updates = [];

       
        for (const installedGame of gamesData.installedGames) {
           
            const serverGame = response.games.find(g => g.id === installedGame.id);

            if (serverGame && serverGame.currentVersion) {
                const installedVersion = installedGame.version || '0.0.0';
                const latestVersion = serverGame.currentVersion;

               
                if (isNewerVersion(latestVersion, installedVersion)) {
                    updates.push({
                        gameId: installedGame.id,
                        gameName: installedGame.name || serverGame.title,
                        fromVersion: installedVersion,
                        toVersion: latestVersion,
                        downloadUrl: serverGame.downloadUrl
                    });
                }
            }
        }

        gamesData.updates = updates;

        if (updates.length > 0) {
            showUpdateNotification(updates.length);
        }
    } catch (error) {
        console.error('Error checking for updates:', error);
    }
}

function isNewerVersion(latest, current) {
   
    const latestParts = latest.split('.').map(n => parseInt(n) || 0);
    const currentParts = current.split('.').map(n => parseInt(n) || 0);

    for (let i = 0; i < Math.max(latestParts.length, currentParts.length); i++) {
        const latestPart = latestParts[i] || 0;
        const currentPart = currentParts[i] || 0;

        if (latestPart > currentPart) return true;
        if (latestPart < currentPart) return false;
    }

    return false;
}

function showUpdateNotification(count) {
    const libraryMenuItems = DOM.queryAll('.menu-item');
    libraryMenuItems.forEach(item => {
        const icon = item.querySelector('.menu-item-icon.library');
        if (icon && !icon.querySelector('.update-badge')) {
            const badge = DOM.create('span', {
                class: 'update-badge'
            }, count);
            icon.appendChild(badge);
        }
    });
}
function isRunningInTauri() {
    return typeof window.__TAURI__ !== 'undefined';
}

function isGameDeveloper() {
    if (!window.user) return false;

    return gamesData.allGames.some(game => game.ownerId === window.user.id);
}

async function findVAPRGameIdByTitle(title) {
    if (!title) return null;

    try {
        let vaprGames = gamesData.allGames;

        if (!vaprGames || vaprGames.length === 0) {
            const response = await api.request('/api/games');
            if (response.success) {
                vaprGames = response.games;
            } else {
                return null;
            }
        }

        const matchedGame = vaprGames.find(g =>
            g.title.toLowerCase() === title.toLowerCase()
        );

        return matchedGame?.id || null;
    } catch (error) {
        console.error('Error finding VAPR game by title:', error);
        return null;
    }
}

window.findVAPRGameIdByTitle = findVAPRGameIdByTitle;
let githubStarsCache = null;
let githubStarsFetching = false;
const processedGithubElements = new WeakSet();

async function updateGitHubStars(element) {
    if (!element) {
        console.warn('GitHub stars element not found');
        return;
    }

    if (processedGithubElements.has(element)) {
        return;
    }
    processedGithubElements.add(element);

    if (githubStarsCache !== null) {
        element.innerHTML = `<i class="fa-solid fa-star"></i> ${githubStarsCache}`;
        return;
    }

    if (githubStarsFetching) {
        return;
    }

    githubStarsFetching = true;
    console.log('Fetching GitHub stars for element:', element);

    try {
        const response = await fetch('https://api.github.com/repos/Vic92548/VAPR');
        if (!response.ok) throw new Error('GitHub API error');

        const data = await response.json();
        const stars = data.stargazers_count;
        githubStarsCache = stars;

        console.log('GitHub stars count:', stars);

        document.querySelectorAll('#github_stars .menu-badge, .menu-badge.stars').forEach(el => {
            el.innerHTML = `<i class="fa-solid fa-star"></i> ${stars}`;
        });
    } catch (error) {
        console.error('Failed to fetch GitHub stars:', error);
        document.querySelectorAll('#github_stars .menu-badge, .menu-badge.stars').forEach(el => {
            el.innerHTML = '<i class="fa-solid fa-star"></i> N/A';
        });
    } finally {
        githubStarsFetching = false;
    }
}

window.updateGitHubStars = updateGitHubStars;

if (window.VAPR) {
    VAPR.on('#github_stars', 'mounted', (element) => {
        const badgeElement = element.querySelector('.menu-badge');
        if (badgeElement) {
            updateGitHubStars(badgeElement);
        }
    });
}

function createLegalPage(config) {
    const {
        pageId,
        pageTitle,
        lastUpdated,
        version = "1.0",
        closeFunction,
        content
    } = config;

    return `
    <section id="${pageId}" class="legal-container" style="display:none;">
        <button id="legal_menu_btn" class="create-post-btn glass_bt" onclick="openMenu()"><i class="fa-solid fa-bars"></i></button>
        <div class="legal-header">
            <div class="legal-header-content">
                <button class="legal-back-btn" onclick="${closeFunction}()">
                    <i class="fa-solid fa-arrow-left"></i>
                </button>
                <div class="legal-title-section">
                    <h1 class="legal-title">${pageTitle}</h1>
                    <p class="legal-subtitle">${lastUpdated}</p>
                </div>
            </div>
        </div>

        <div class="legal-body">
            <div class="legal-content">
                ${content}
            </div>

            <div class="legal-footer">
                <div class="legal-footer-content">
                    <div class="legal-contact">
                        <h3>Contact Information</h3>
                        <p>For questions regarding this document, please contact us:</p>
                        <div class="legal-contact-links">
                            <a href="https://discord.gg/vtsnj3zphd" target="_blank" class="legal-contact-btn">
                                <i class="fa-brands fa-discord"></i>
                                <span>Discord Server</span>
                            </a>
                            <a href="mailto:legal@vapr.club" class="legal-contact-btn">
                                <i class="fa-solid fa-envelope"></i>
                                <span>legal@vapr.club</span>
                            </a>
                        </div>
                    </div>

                    <div class="legal-nav">
                        <h3>Legal Documents</h3>
                        <div class="legal-nav-links">
                            <a href="#" onclick="openTermsPage()" class="legal-nav-link">
                                <i class="fa-solid fa-scale-balanced"></i>
                                <span>Terms of Service</span>
                            </a>
                            <a href="#" onclick="openPrivacyPage()" class="legal-nav-link">
                                <i class="fa-solid fa-shield-halved"></i>
                                <span>Privacy Policy</span>
                            </a>
                        </div>
                    </div>
                </div>

                <div class="legal-copyright">
                    <p>&copy; 2025 VAPR. All rights reserved. Document version ${version} - ${lastUpdated}</p>
                </div>
            </div>
        </div>
    </section>`;
}

function createLegalSection(title, content) {
    return `
    <div class="legal-section">
        <h2 class="section-header">${title}</h2>
        ${content}
    </div>`;
}

function createLegalList(items) {
    const listItems = items.map(item => `<li>${item}</li>`).join('');
    return `<ul class="legal-list">${listItems}</ul>`;
}

if (typeof window !== 'undefined') {
    window.createLegalPage = createLegalPage;
    window.createLegalSection = createLegalSection;
    window.createLegalList = createLegalList;
}
function initPlayerPreferences() {
    if (!window.user) {
        const backgroundUrl = localStorage.getItem('background_url');

        if(backgroundUrl){
            equipBackground(backgroundUrl, false);
        }
    }
}

initPlayerPreferences();
let feed_posts = [];
let loading_steps = 1;
window.loading_steps = loading_steps;
let post_seen = 0;
let creators = {};

function showInitialPost() {
    const path = window.location.pathname.split('/');
    showPost();
    if(path.length < 3){
        displayPost();
    }else if(path[1] === "post"){
        displayPost(path[2]);
    }
}

let userLoginStatusCache = null;
let userLoginStatusCacheTime = 0;
const USER_LOGIN_CACHE_DURATION = 1000;

function isUserLoggedIn(){
    const now = Date.now();

    if (userLoginStatusCache !== null && (now - userLoginStatusCacheTime) < USER_LOGIN_CACHE_DURATION) {
        return userLoginStatusCache;
    }

    const result = window.user ? true : false;
    userLoginStatusCache = result;
    userLoginStatusCacheTime = now;

    console.log('isUserLoggedIn() called:', result, 'window.user:', window.user);
    return result;
}

window.invalidateUserLoginCache = function() {
    userLoginStatusCache = null;
    userLoginStatusCacheTime = 0;
};

function updateUsername() {
    const level_elements = document.getElementsByClassName("username");
    for (let i = 0; i < level_elements.length; i++) {
        level_elements[i].textContent = user.username;
        console.log("updated username : " + user.username);
    }
}

console.log("ðŸš€ Starting authentication flow");
loadUserData();

let current_post_id = undefined;
let current_post = undefined;

function hidePost() {
    DOM.get("post_video").children[0].src = "";
    document.getElementsByClassName("post")[0].style.transform = "translateY(100vh)";
}

function opeNewPostModel() {
    if (isUserLoggedIn()) {
        hideMenu();
        router.navigate('/create');
    } else {
        openRegisterModal();
    }
}

function closeAddPostCard() {
    if (typeof window.closeAddPostPage === 'function') {
        window.closeAddPostPage();
    }
}

function openRegisterModal() {
    DOM.show("register", "flex");
}

async function updateFollowButton() {
    const follow_bt = DOM.get("follow");

    if(isUserLoggedIn()){
        let following;

        console.log("CURRENT POST");
        console.log(current_post);

        if(creators[current_post.userId]){
            following = creators[current_post.userId].following;
        }else{
            creators[current_post.userId] = {
                following: false
            }
        }

        if(following === undefined){
            following = await checkUserFollowsCreator(current_post.userId);
            creators[current_post.userId].following = following;
        }

        follow_bt.style.opacity = "0";
        follow_bt.style.display = "inline-block";

        if(following){
            follow_bt.innerHTML = '<i class="fa-solid fa-user-minus"></i>';
            follow_bt.onclick = unfollowPost;
            follow_bt.style.border = "1px solid rgb(206 220 247 / 42%)";
            follow_bt.style.backgroundColor = "rgb(190 213 255 / 40%)";
        }else{
            follow_bt.innerHTML = '<i class="fa-solid fa-user-plus"></i>';
            follow_bt.onclick = followPost;
            follow_bt.style.border = "1px solid rgb(77 137 245)";
            follow_bt.style.backgroundColor = "rgb(95 148 243)";
        }

        follow_bt.style.opacity = "1";

        if(current_post.userId === user.id){
            follow_bt.style.opacity = "0";
            follow_bt.style.display = "none";
        }
    }else{
        follow_bt.onclick = openRegisterModal;
    }
}

function followPost() {
    creators[current_post.userId].following = true;
    updateFollowButton();
    if(isUserLoggedIn()){
        APIHandler.handle(
            () => api.followPost(current_post.id),
            {
                errorMessage: 'Error when trying to follow. Please try again.'
            }
        );
    }else{
        openRegisterModal();
    }
}

function unfollowPost() {
    creators[current_post.userId].following = false;
    updateFollowButton();
    if(isUserLoggedIn()){
        APIHandler.handle(
            () => api.unfollowPost(current_post.id)
        );
    }else{
        openRegisterModal();
    }
}

async function checkUserFollowsCreator(creatorId) {
    try {
        const isFollowing = await api.checkFollowStatus(creatorId);
        console.log('Check follow status:', isFollowing);
        return isFollowing;
    } catch (error) {
        console.error('Error checking follow status:', error);
        return false;
    }
}


if(window.innerWidth >= 768){
    DOM.show("menu", 'flex');
}

function processJoinQueryParam() {
    const url = new URL(window.location.href);
    const params = url.searchParams;

    if (params.has('join')) {
        const joinValue = params.get('join');
        console.log("Join param found with value = " + joinValue);
        localStorage.setItem('referrerId', joinValue);
        params.delete('join');
        window.history.replaceState({}, '', url.toString());
    }
}

function handleReferral() {
    const referrerId = localStorage.getItem('referrerId');

    if (referrerId) {
        APIHandler.handle(
            () => api.acceptInvitation(referrerId),
            {
                onSuccess: (data) => {
                    console.log('Invitation processed:', data);
                    if(creators[referrerId]){
                        creators[referrerId].following = true;
                        updateFollowButton();
                    }
                    localStorage.removeItem('referrerId');
                },
                onError: (error) => {
                    localStorage.removeItem('referrerId');
                }
            }
        );
    }
}

function closeTextModal() {
    DOM.hide("text_modal");
}

function copyReferrerId() {
    if(isUserLoggedIn()){
        const referralUrl = `https://vapr.club?join=${user.id}`;
        notify.copyToClipboard(referralUrl, "Invitation link copied to clipboard!");
    }else{
        openRegisterModal();
    }
}

processJoinQueryParam();

function navigateToMyProfile() {
    if (window.navigation) {
        window.navigation.goToProfile(window.user.username, false);
    } else {
        router.navigate(`/@${window.user.username}`, false);
    }
}

window.closeProfileCard = function() {
    cardManager.hide('profile-card');
};

console.log('ðŸŽ¯ main.js - delaying router until auth completes');

let authRouteHandled = false;

function waitForAuthThenRoute() {
    if (authRouteHandled) {
        return;
    }

    if (window.loading_steps <= 0) {
        console.log('ðŸŽ¯ Auth completed, now handling route - window.user:', window.user);
        authRouteHandled = true;
        router.handleRoute();
    } else {
        console.log('ðŸŽ¯ Auth still loading, waiting 100ms... loading_steps:', window.loading_steps);
        setTimeout(waitForAuthThenRoute, 100);
    }
}

waitForAuthThenRoute();
const menuLoader = {
    async loadMenuSystem() {
        try {
            if (!window.menuManager) {
                const script = document.createElement('script');
                script.src = '/src/js/menu-manager.js';
                script.onload = () => {
                    this.initializeMenuManager();
                };
                document.head.appendChild(script);
            } else {
                this.initializeMenuManager();
            }
        } catch (error) {
            console.error('Failed to load menu system:', error);
        }
    },

    initializeMenuManager() {
        if (window.menuManager && window.menuManager.menuConfig) {
            this.setupMenuUpdateListeners();
        } else {
            setTimeout(() => this.initializeMenuManager(), 100);
        }
    },

    setupMenuUpdateListeners() {
        const originalLoadUserData = window.loadUserData;
        if (originalLoadUserData) {
            window.loadUserData = function() {
                originalLoadUserData.apply(this, arguments);
                setTimeout(() => {
                    if (window.menuManager) {
                        window.menuManager.updateMenu();
                    }
                }, 500);
            };
        }

        window.addEventListener('userLoggedIn', () => {
            if (window.menuManager) {
                window.menuManager.updateMenu();
            }
        });

        window.addEventListener('userLoggedOut', () => {
            if (window.menuManager) {
                window.menuManager.updateMenu();
            }
        });

        window.addEventListener('resize', () => {
            setTimeout(() => {
                if (window.menuManager) {
                    window.menuManager.updateMenu();
                }
            }, 250);
        });
    }
};

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        menuLoader.loadMenuSystem();
    });
}

window.menuLoader = menuLoader;
class MenuManager {
    constructor() {
        this.menuConfig = null;
        this.isCollapsed = false;
        this.loadConfig();
    }

    async loadConfig() {
        try {
            const response = await fetch('/menu-config.json');
            this.menuConfig = await response.json();
            this.updateMenu();
        } catch (error) {
            console.error('Failed to load menu configuration:', error);
        }
    }

    isItemVisible(item, userContext = {}) {
        const visibility = item.visibility || {};
        const platform = this.detectPlatform();

        if (visibility.hideOnMobile && platform === 'mobile') return false;
        if (visibility.hideOnDesktop && platform === 'desktop') return false;
        if (visibility.hideOnWeb && platform === 'web') return false;

        if (visibility.requireAuth && !userContext.isLoggedIn) return false;
        if (visibility.showOnlyWhenLoggedOut && userContext.isLoggedIn) return false;
        if (visibility.showOnlyWhenLoggedIn && !userContext.isLoggedIn) return false;
        if (visibility.requireDeveloper && !userContext.isDeveloper) return false;

        return true;
    }

    isSectionVisible(section, userContext = {}) {
        const visibility = section.visibility || {};
        const platform = this.detectPlatform();

        if (visibility.hideOnMobile && platform === 'mobile') return false;
        if (visibility.hideOnDesktop && platform === 'desktop') return false;
        if (visibility.hideOnWeb && platform === 'web') return false;

        if (visibility.requireAuth && !userContext.isLoggedIn) return false;
        if (visibility.showOnlyWhenLoggedOut && userContext.isLoggedIn) return false;
        if (visibility.showOnlyWhenLoggedIn && !userContext.isLoggedIn) return false;
        if (visibility.requireDeveloper && !userContext.isDeveloper) return false;

        const visibleItems = section.items.filter(item => this.isItemVisible(item, userContext));
        return visibleItems.length > 0;
    }

    detectPlatform() {
        if (typeof window.__TAURI__ !== 'undefined') return 'desktop';
        if (window.innerWidth <= 768) return 'mobile';
        return 'web';
    }

    isSpecialButton(item) {
        const url = item.action || '';
        const specialType = item.specialType || '';

        if (specialType === 'discord' || url.includes('discord')) {
            return 'discord';
        }
        if (specialType === 'github' || url.includes('github')) {
            return 'github';
        }
        return null;
    }

    renderMenuItem(item, userContext = {}) {
        if (!this.isItemVisible(item, userContext)) return '';

        const specialType = this.isSpecialButton(item);
        const iconClass = item.iconClass ? ` ${item.iconClass}` : '';
        const badgeClass = item.badgeClass ? ` ${item.badgeClass}` : '';
        const elementId = item.elementId ? ` id="${item.elementId}"` : '';
        const badgeId = item.badgeId ? ` id="${item.badgeId}"` : '';

        let badgeHtml = '';
        if (item.badge) {
            badgeHtml = `<span class="menu-badge${badgeClass}"${badgeId}>${item.badge}</span>`;
        }

        let arrowHtml = '';
        if (item.arrow) {
            arrowHtml = '<i class="fa-solid fa-chevron-right menu-item-arrow"></i>';
        }

        return `
            <li class="menu-item glass-secondary glass-shimmer" onclick="${item.action}"${elementId}>
                <div class="menu-item-icon${iconClass}">
                    <i class="${item.icon}"></i>
                </div>
                <div class="menu-item-content">
                    <span class="menu-item-title">${item.title}</span>
                    ${item.subtitle ? `<span class="menu-item-desc">${item.subtitle}</span>` : ''}
                </div>
                ${badgeHtml}
                ${arrowHtml}
            </li>
        `;
    }

    renderMenuSection(section, userContext = {}) {
        if (!this.isSectionVisible(section, userContext)) return '';

        const sectionId = section.sectionId ? ` id="${section.sectionId}"` : '';
        const authClass = section.visibility?.requireAuth ? ' auth-required' : '';
        const developerClass = section.visibility?.requireDeveloper ? ' developer-section' : '';

        const items = section.items
            .filter(item => this.isItemVisible(item, userContext))
            .map(item => this.renderMenuItem(item, userContext))
            .join('');

        if (!items) return '';

        return `
            <div class="menu-section${authClass}${developerClass}"${sectionId}>
                <h4 class="menu-section-title">${section.category}</h4>
                <ul class="menu-list">
                    ${items}
                </ul>
            </div>
        `;
    }

    renderMenu(userContext = {}) {
        if (!this.menuConfig) return '';

        const sections = this.menuConfig.menuSections
            .filter(section => this.isSectionVisible(section, userContext))
            .map(section => this.renderMenuSection(section, userContext))
            .join('');

        return sections;
    }

    updateMenu() {
        const userContext = this.getUserContext();
        const menuNav = document.querySelector('.menu-nav');

        if (!menuNav || !this.menuConfig) return;

        const menuContent = this.renderMenu(userContext);
        menuNav.innerHTML = menuContent;

        this.initializeSpecialButtons();
        this.addMenuAnimations();
    }

    getUserContext() {
        const context = {
            isLoggedIn: isUserLoggedIn ? isUserLoggedIn() : false,
            isDeveloper: isGameDeveloper ? isGameDeveloper() : false,
            user: window.user || null
        };
        console.log('Menu user context:', context);
        return context;
    }

    initializeSpecialButtons() {
        if (this.specialButtonsInitialized) {
            return;
        }
        this.specialButtonsInitialized = true;

        setTimeout(() => {
            console.log('Initializing special buttons...');

            const githubStars = document.getElementById('github_stars');
            console.log('GitHub stars element:', githubStars);
            if (githubStars && window.updateGitHubStars) {
                console.log('Updating GitHub stars...');
                const badgeElement = githubStars.querySelector('.menu-badge');
                if (badgeElement) {
                    window.updateGitHubStars(badgeElement);
                }
            }

            const discordMembers = document.getElementById('discord_members');
            console.log('Discord members element:', discordMembers);
            if (discordMembers && window.updateDiscordMembers) {
                console.log('Updating Discord members...');
                const badgeElement = discordMembers.querySelector('.menu-badge');
                if (badgeElement) {
                    window.updateDiscordMembers(badgeElement);
                }
            }
        }, 100);
    }

    addMenuAnimations() {
        const menuItems = document.querySelectorAll('.menu-item');

        menuItems.forEach((item, index) => {
            item.style.opacity = '0';
            item.style.transform = 'translateX(-20px)';

            setTimeout(() => {
                item.style.transition = 'all 0.3s ease';
                item.style.opacity = '1';
                item.style.transform = 'translateX(0)';
            }, index * 50);
        });
    }

    updateMenuTooltips(isCollapsed) {
        const menuItems = document.querySelectorAll('.menu-item');

        menuItems.forEach(item => {
            if (isCollapsed) {
                const title = item.querySelector('.menu-item-title');
                if (title) {
                    item.setAttribute('data-tooltip', title.textContent);
                }
            } else {
                item.removeAttribute('data-tooltip');
            }
        });
    }

    addItemToConfig(sectionName, item) {
        if (!this.menuConfig) return false;

        const section = this.menuConfig.menuSections.find(s => s.category === sectionName);
        if (section) {
            section.items.push(item);
            return true;
        }
        return false;
    }

    removeItemFromConfig(sectionName, itemTitle) {
        if (!this.menuConfig) return false;

        const section = this.menuConfig.menuSections.find(s => s.category === sectionName);
        if (section) {
            const itemIndex = section.items.findIndex(item => item.title === itemTitle);
            if (itemIndex !== -1) {
                section.items.splice(itemIndex, 1);
                return true;
            }
        }
        return false;
    }

    updateItemVisibility(sectionName, itemTitle, visibilityOptions) {
        if (!this.menuConfig) return false;

        const section = this.menuConfig.menuSections.find(s => s.category === sectionName);
        if (section) {
            const item = section.items.find(item => item.title === itemTitle);
            if (item) {
                item.visibility = { ...item.visibility, ...visibilityOptions };
                return true;
            }
        }
        return false;
    }

    getMenuConfig() {
        return this.menuConfig;
    }
}

window.menuManager = new MenuManager();
let menuInitialized = false;

function initMenu() {
    if (menuInitialized) {
        return;
    }
    menuInitialized = true;

    if (window.menuManager) {
        window.menuManager.updateMenu();
    }

    if (isUserLoggedIn()) {
        updateMenuUserInfo();
        showMenuUserElements();
        showAuthRequiredElements();
    } else {
        hideAuthRequiredElements();
        showPublicMenuElements();
    }

    updateOnlineUsers();

    if (window.innerWidth >= 769) {
        initMenuCollapseState();
        addCollapsedMenuInteractions();
    }
}

function updateDeveloperSection() {
    const devSection = DOM.query('.menu-section[title="Developer"]');
    if (devSection) {
        devSection.style.display = isGameDeveloper() ? 'block' : 'none';
    }
}

function toggleMenuCollapse() {
    const menuContainer = DOM.query('.menu-container');
    const mainElement = DOM.query('main');
    const toggleButton = DOM.query('.menu-toggle i');

    if (!menuContainer) return;

    menuContainer.classList.toggle('collapsed');

    if (mainElement) {
        mainElement.classList.toggle('menu-collapsed');
    }

    const isCollapsed = menuContainer.classList.contains('collapsed');
    localStorage.setItem('menuCollapsed', isCollapsed);

    updateMenuTooltips(isCollapsed);

    if (toggleButton) {
        toggleButton.style.transform = isCollapsed ? 'rotate(180deg)' : 'rotate(0deg)';
    }
}

function updateMenuTooltips(isCollapsed) {
    if (window.menuManager) {
        window.menuManager.updateMenuTooltips(isCollapsed);
        return;
    }

    const menuItems = DOM.queryAll('.menu-item');

    menuItems.forEach(item => {
        if (isCollapsed) {
            const title = item.querySelector('.menu-item-title');
            if (title) {
                item.setAttribute('data-tooltip', title.textContent);
            }
        } else {
            item.removeAttribute('data-tooltip');
        }
    });
}

function initMenuCollapseState() {
    const savedState = localStorage.getItem('menuCollapsed');
    const menuContainer = DOM.query('.menu-container');
    const mainElement = DOM.query('main');

    if (savedState === 'true' && menuContainer) {
        menuContainer.classList.add('collapsed');
        if (mainElement) {
            mainElement.classList.add('menu-collapsed');
        }
        updateMenuTooltips(true);

        const toggleButton = DOM.query('.menu-toggle i');
        if (toggleButton) {
            toggleButton.style.transform = 'rotate(180deg)';
        }
    }
}

function addCollapsedMenuInteractions() {
    const menuContainer = DOM.query('.menu-container');
    if (!menuContainer) return;
}

function updateMenuUserInfo() {
    if (!window.user) return;

    const menuAvatar = DOM.get('menu_user_avatar');
    if (menuAvatar && window.user.avatar) {
        menuAvatar.src = `https://cdn.discordapp.com/avatars/${window.user.id}/${window.user.avatar}.png?size=128`;
    } else if (menuAvatar) {
        menuAvatar.src = 'https://vapr-club.b-cdn.net/default_vapr_avatar.png';
    }

    const menuUsername = DOM.get('menu_username');
    if (menuUsername) {
        menuUsername.textContent = '@' + window.user.username;
    }

    const menuLevel = DOM.get('menu_user_level');
    if (menuLevel) {
        menuLevel.textContent = window.user.level || 0;
    }

    updateMenuXPBar();
}

function updateMenuXPBar() {
    if (!window.user) return;

    const xp = window.user.xp || 0;
    const xpRequired = window.user.xp_required || 700;
    const xpPercentage = (xp / xpRequired) * 100;

    const xpBar = DOM.get('menu_xp_bar');
    const xpText = DOM.get('menu_xp_text');

    if (xpBar) {
        xpBar.style.width = xpPercentage + '%';
    }

    if (xpText) {
        xpText.textContent = `${xp} / ${xpRequired} XP`;
    }
}

function showMenuUserElements() {
    const userCard = DOM.get('menu_user_info');
    const accountSection = DOM.get('account_section');
    const publicAuthSection = DOM.get('public_auth_section');

    if (userCard) DOM.show(userCard, 'flex');
    if (accountSection) DOM.show(accountSection);

   
    if (publicAuthSection) DOM.hide(publicAuthSection);
}

function showAuthRequiredElements() {
    const authElements = DOM.queryAll('.auth-required');
    authElements.forEach(element => {
        DOM.show(element);
    });
}

function hideAuthRequiredElements() {
    const authElements = DOM.queryAll('.auth-required');
    authElements.forEach(element => {
        DOM.hide(element);
    });
}

function showPublicMenuElements() {
   
    const publicSections = DOM.queryAll('menu-section:not(.auth-required):not(.developer-section):not([id="account_section"])');
    publicSections.forEach(section => {
        DOM.show(section);
    });

   
    const publicAuthSection = DOM.get('public_auth_section');
    if (publicAuthSection) {
        DOM.show(publicAuthSection);
    }

   
    const publicMenuItems = [
       
        DOM.query('menu-item[onclick*="store"]'),
       
        DOM.query('menu-item[onclick*="github"]'),
        DOM.query('menu-item[onclick*="discord"]'),
       
        DOM.query('menu-item[onclick*="terms"]'),
        DOM.query('menu-item[onclick*="privacy"]')
    ];

    publicMenuItems.forEach(item => {
        if (item && !item.classList.contains('auth-required')) {
            DOM.show(item);
        }
    });
}

async function updateOnlineUsers() {
    try {
        const data = await api.getUserCount();

        const onlineEl = DOM.get('online_users');
        if (onlineEl && data.count) {
            onlineEl.textContent = data.count.toLocaleString() + ' users';
        }
    } catch (error) {
        console.error('Error fetching online users:', error);
    }
}

function addMenuAnimations() {
    if (window.menuManager) {
        window.menuManager.addMenuAnimations();
        return;
    }

    const menuItems = DOM.queryAll('.menu-item');

    menuItems.forEach((item, index) => {
        item.style.opacity = '0';
        item.style.transform = 'translateX(-20px)';

        setTimeout(() => {
            item.style.transition = 'all 0.3s ease';
            item.style.opacity = '1';
            item.style.transform = 'translateX(0)';
        }, index * 50);

        item.addEventListener('mouseenter', () => {
        });
    });
}

function isRunningInTauri() {
    return typeof window.__TAURI__ !== 'undefined';
}

function getLatestVersion() {
    const versionElement = DOM.query('.menu-version span');
    if (versionElement) {
        const versionText = versionElement.textContent;
        const versionMatch = versionText.match(/v(\d+\.\d+\.\d+)/);
        if (versionMatch) {
            return versionMatch[1];
        }
    }
    return '1.1.19';
}

function downloadDesktopApp() {
    const version = getLatestVersion();
    const downloadUrl = `https://github.com/Vic92548/VAPR/releases/download/v${version}/VAPR_${version}_x64_en-US.msi`;

    if (window.analytics && window.analytics.track) {
        window.analytics.track('desktop_app_download_clicked', {
            version: version,
            platform: 'windows'
        });
    }

    window.open(downloadUrl, '_blank');

    notify.info("Download started!", `The VAPR desktop app download should begin shortly.<br><small>Windows 64-bit â€¢ v${version}</small>`, {
        timer: 5000
    });
}

function openMenu() {
    const menu = DOM.get('menu');
    if (!menu) return;

    DOM.show(menu, 'flex');

    if (window.menuManager) {
        window.menuManager.updateMenu();
    }

    if (isUserLoggedIn()) {
        updateMenuUserInfo();
        showMenuUserElements();
        showAuthRequiredElements();
    } else {
        const accountSection = DOM.get('account_section');
        if (accountSection) DOM.hide(accountSection);
        hideAuthRequiredElements();
        showPublicMenuElements();
    }

    const menuContainer = menu.querySelector('.menu-container');
    if (menuContainer) {
        menuContainer.style.transform = 'translateX(-100%)';
        menuContainer.style.opacity = '0';

        setTimeout(() => {
            menuContainer.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
            menuContainer.style.transform = 'translateX(0)';
            menuContainer.style.opacity = '1';
        }, 10);
    }

    addMenuAnimations();
}

function hideMenu() {
    const menu = DOM.get('menu');
    if (!menu) return;

    const menuContainer = menu.querySelector('.menu-container');
    if (menuContainer) {
        menuContainer.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        menuContainer.style.transform = 'translateX(-100%)';
        menuContainer.style.opacity = '0';

        setTimeout(() => {
            DOM.hide(menu);
        }, 300);
    } else {
        DOM.hide(menu);
    }
}

async function logout() {
    const confirmed = await notify.confirm('Logout', 'Are you sure you want to logout?');

    if (confirmed) {
        try {
            await fetch('/logout', {
                method: 'POST',
                credentials: 'include'
            });

            localStorage.removeItem('userData');

            if (window.clearSDKUserInfo) {
                window.clearSDKUserInfo();
            }

            window.user = null;
            router.navigate('/', true);
        } catch (error) {
            console.error('Logout error:', error);
            router.navigate('/', true);
        }
    }
}

let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        if (window.innerWidth < 769) {
            const menuContainer = DOM.query('.menu-container');
            const mainElement = DOM.query('main');

            if (menuContainer) {
                menuContainer.classList.remove('collapsed');
            }
            if (mainElement) {
                mainElement.classList.remove('menu-collapsed');
            }
        } else {
            initMenuCollapseState();
        }
    }, 250);
});

const originalOpenNewPostModel = window.opeNewPostModel;
window.opeNewPostModel = function() {
    hideMenu();
    router.navigate('/create');
};

const originalOpenAnalytics = window.openAnalytics;
window.openAnalytics = function() {
    hideMenu();
    originalOpenAnalytics();
};

const originalOpenLeaderboardModal = window.openLeaderboardModal;
window.openLeaderboardModal = function() {
    hideMenu();
    originalOpenLeaderboardModal();
};

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        initMenu();

        if (window.innerWidth >= 769) {
            initMenuCollapseState();
        }

        if (window.user && window.VAPR) {
            insertVAPRUserInfo();
        }
    });

    const originalLoadUserData = window.loadUserData;
    window.loadUserData = function() {
        originalLoadUserData();
        setTimeout(() => {
            initMenu();
            if (window.menuManager) {
                window.menuManager.updateMenu();
            }
            if (window.user && window.VAPR) {
                insertVAPRUserInfo();
            }
        }, 500);
    };
}

if (window.VAPR && typeof window.VAPR.on === 'function') {
    const toggleAccountSection = (el) => {
        if (isUserLoggedIn()) {
            DOM.show(el);
        } else {
            DOM.hide(el);
        }
    };

    window.VAPR.on('#account_section', 'created', toggleAccountSection);
    window.VAPR.on('#account_section', 'mounted', toggleAccountSection);
}

function insertVAPRUserInfo() {
    const menuHeader = DOM.query('.menu-header');
    if (!menuHeader) return;

    const container = menuHeader.parentElement;
    const menuNav = container.querySelector('.menu-nav');

    const existingUserInfo = DOM.get('menu_user_info');
    if (existingUserInfo) existingUserInfo.remove();

    const avatarUrl = window.user.avatar
        ? `https://cdn.discordapp.com/avatars/${window.user.id}/${window.user.avatar}.png?size=128`
        : 'https://vapr-club.b-cdn.net/default_vapr_avatar.png';

    const xpPercent = ((window.user.xp || 0) / (window.user.xp_required || 700)) * 100;

    const userInfo = DOM.create('user-info-card', {
        id: 'menu_user_info',
        avatar: avatarUrl,
        username: '@' + window.user.username,
        level: window.user.level || 0,
        xp: window.user.xp || 0,
        'xp-required': window.user.xp_required || 700,
        'xp-percent': xpPercent.toFixed(1)
    });

    container.insertBefore(userInfo, menuNav);
}
function drawPost(data){
    displayReactions();

    APIHandler.handle(
        () => api.registerView(data.id),
        {
            onSuccess: (data) => {
                console.log(data);
                console.log("Views updated");
            }
        }
    );

    post_seen++;
    showPost();
    console.log("Post DATA:");
    console.log(data);

    updateFollowButton();

    const titleEl = DOM.get("post_title");
    const showMoreButtonEl = DOM.get("post_title_show_more");
    titleEl.textContent = data.title;

    requestAnimationFrame(() => {
        const isClamped = titleEl.scrollHeight > titleEl.clientHeight;

        if (isClamped) {
            showMoreButtonEl.style.display = "inline-block";
            showMoreButtonEl.onclick = () => {
                titleEl.classList.toggle("expanded");
                const isExpanded = titleEl.classList.contains("expanded");
                showMoreButtonEl.innerHTML = isExpanded
                    ? `<i class="fa-solid fa-chevron-up"></i> Show less`
                    : `<i class="fa-solid fa-chevron-down"></i> Show more`;

                if (isExpanded) {
                    titleEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            };
        } else {
            showMoreButtonEl.style.display = "none";
        }
    });

    const username = data.username;
    DOM.setText("post_username", "@" + username);

    const avatarImg = DOM.get("user_avatar_img");
    const avatarLetter = DOM.get("avatar_letter");
    const avatarEl = DOM.get("user_avatar");

    function showLetterAvatar() {
        DOM.hide(avatarImg);
        DOM.show(avatarLetter, "flex");
        avatarLetter.textContent = username.charAt(0).toUpperCase();

        const hue = username.charCodeAt(0) * 3 % 360;
        avatarEl.style.background = `linear-gradient(135deg, hsl(${hue}, 70%, 50%), hsl(${hue + 30}, 70%, 60%))`;
    }

    function showDiscordAvatar(avatarHash) {
        if (avatarHash) {
            avatarImg.src = `https://cdn.discordapp.com/avatars/${data.userId}/${avatarHash}.png?size=128`;
            DOM.show(avatarImg);
            DOM.hide(avatarLetter);
            avatarEl.style.background = "none";

            avatarImg.onerror = () => {
                console.log("Failed to load Discord avatar, showing fallback");
                showLetterAvatar();
            };
        } else {
            showLetterAvatar();
        }
    }

    if (data.userAvatar !== undefined) {
        showDiscordAvatar(data.userAvatar);

        if (!window.creators) {
            window.creators = {};
        }
        if (!window.creators[data.userId]) {
            window.creators[data.userId] = {};
        }
        window.creators[data.userId].avatar = data.userAvatar;
        window.creators[data.userId].username = data.username;
        window.creators[data.userId].level = data.userLevel || 0;
    }
    else if (window.creators && window.creators[data.userId] && window.creators[data.userId].avatar !== undefined) {
        showDiscordAvatar(window.creators[data.userId].avatar);
    }
    else {
        APIHandler.handle(
            () => api.getUser(data.userId),
            {
                onSuccess: (userInfo) => {
                    if (!window.creators) {
                        window.creators = {};
                    }
                    if (!window.creators[data.userId]) {
                        window.creators[data.userId] = {};
                    }

                    window.creators[data.userId].avatar = userInfo.avatar || null;
                    window.creators[data.userId].username = userInfo.username;
                    window.creators[data.userId].level = userInfo.level || 0;

                    showDiscordAvatar(userInfo.avatar);
                },
                onError: (error) => {
                    console.error("Failed to fetch user info:", error);
                    showLetterAvatar();

                    if (!window.creators) {
                        window.creators = {};
                    }
                    if (!window.creators[data.userId]) {
                        window.creators[data.userId] = {};
                    }
                    window.creators[data.userId].avatar = null;
                }
            }
        );
    }

    DOM.setText("post_time", timeAgo(data.timestamp));

    animateViewCount(data.views);

    if(!data.content){
        data.content = "https://vapr.b-cdn.net/posts/200w.gif";
    }

    if(data.content.split("/posts/")[0] === "https://vapr-club.b-cdn.net"){
        DOM.get("post_image").src = data.content;
        DOM.show("post_image");
        DOM.hide("post_content");
        DOM.hide("post_video");

        const imageEl = DOM.get("post_image");
        imageEl.style.filter = "blur(10px)";
        imageEl.onload = () => {
            imageEl.style.filter = "none";
            imageEl.style.transition = "filter 0.3s ease";
        };

        window.currentPostImageUrl = data.content;
        window.currentPostId = data.id;
        updateSetBackgroundButton();
    }else if(data.content.includes("iframe.mediadelivery.net")){
        DOM.show("post_video");
        setTimeout(() => {
            DOM.get("post_video").children[0].src = data.content;
        }, 100);
        DOM.hide("post_content");
        DOM.hide("post_image");
        window.currentPostImageUrl = null;
        window.currentPostId = null;
        updateSetBackgroundButton();
    }

    DOM.get("post_image").onclick = function () {
        toggleImageZoom(DOM.get("post_image"));
    }

    const headerGameButton = DOM.get("header_game_button");

    DOM.hide(headerGameButton);

    if(data.taggedGame && data.taggedGame.id) {
        window.currentPostTaggedGame = data.taggedGame;
        DOM.show(headerGameButton, 'inline-flex');
        headerGameButton.innerHTML = `<i class="fa-solid fa-gamepad"></i><span>${data.taggedGame.title}</span>`;

        headerGameButton.style.opacity = '0';
        headerGameButton.style.transform = 'translateY(10px)';

        setTimeout(() => {
            headerGameButton.style.transition = 'all 0.3s ease';
            headerGameButton.style.opacity = '1';
            headerGameButton.style.transform = 'translateY(0)';
        }, 100);
    } else {
        window.currentPostTaggedGame = null;
    }
}

function updateSetBackgroundButton() {
    let setBackgroundBtn = DOM.get("set_background_btn");

    if (!setBackgroundBtn) {
        setBackgroundBtn = DOM.create('button', {
            id: 'set_background_btn',
            class: 'glass-button set-background-btn',
            onclick: () => setPostAsBackground()
        });
        setBackgroundBtn.innerHTML = '<i class="fa-solid fa-image"></i><span>Set as Background</span>';

        const actionBar = DOM.query('.action-bar');
        if (actionBar) {
            actionBar.appendChild(setBackgroundBtn);
        }
    }

    if (window.currentPostImageUrl && window.currentPostId) {
        DOM.show(setBackgroundBtn, 'inline-flex');

        const currentBackgroundId = localStorage.getItem('background_id');
        if (currentBackgroundId === window.currentPostId) {
            setBackgroundBtn.innerHTML = '<i class="fa-solid fa-check"></i><span>Current Background</span>';
            setBackgroundBtn.classList.add('active');
            setBackgroundBtn.disabled = true;
        } else {
            setBackgroundBtn.innerHTML = '<i class="fa-solid fa-image"></i><span>Set as Background</span>';
            setBackgroundBtn.classList.remove('active');
            setBackgroundBtn.disabled = false;
        }
    } else {
        DOM.hide(setBackgroundBtn);
    }
}

function setPostAsBackground() {
    if (!window.currentPostImageUrl || !window.currentPostId) return;

    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }

   
    equipBackground(window.currentPostId, true);

    updateSetBackgroundButton();
    notify.success("Background updated!");

    if (typeof confetti !== 'undefined') {
        confetti({
            particleCount: 50,
            spread: 50,
            origin: { y: 0.6 },
            colors: ['#4ecdc4', '#44a3aa', '#3d9a92']
        });
    }
}

window.openTaggedGame = async function() {
    loading.show();
    if (window.currentPostTaggedGame && window.currentPostTaggedGame.id) {
        if (current_post && current_post.id) {
            try {
                const gameId = window.currentPostTaggedGame.id;
                console.log('Tracking game click for game:', gameId, 'post:', current_post.id);

                await api.request('/api/creators/track-game-click', {
                    method: 'POST',
                    body: {
                        gameId: gameId,
                        postId: current_post.id
                    }
                });
                console.log('Successfully tracked game click for creator attribution');
            } catch (error) {
                console.error('Failed to track game click:', error);
            }
        }

        if (!gamesData.tebexGames || gamesData.tebexGames.length === 0) {
            await loadTebexGames();
        }

        const toSlug = (s) => String(s)
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
        const slug = toSlug(window.currentPostTaggedGame.title);

        loading.hide();
        router.navigate(`/games/${slug}`, true);
    }
}

function navigateToProfile() {
    if (current_post && current_post.username) {
        router.navigate(`/@${current_post.username}`);
    }
}

function animateViewCount(targetViews) {
    const viewsEl = DOM.get("post_views");
    const startViews = parseInt(viewsEl.textContent) || 0;
    const duration = 1000;
    const startTime = performance.now();

    function updateViews(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        const easeOutQuart = 1 - Math.pow(1 - progress, 4);

        const currentViews = Math.floor(startViews + (targetViews - startViews) * easeOutQuart);
        viewsEl.textContent = formatViews(currentViews);

        if (progress < 1) {
            requestAnimationFrame(updateViews);
        }
    }

    requestAnimationFrame(updateViews);
}

function toggleImageZoom(img) {
    if (img.classList.contains('zoomed')) {
        img.classList.remove('zoomed');
        DOM.query('.image-overlay')?.remove();
    } else {
        const overlay = DOM.create('div', {
            class: 'image-overlay',
            onclick: () => toggleImageZoom(img)
        });

        const zoomedImg = img.cloneNode();
        zoomedImg.className = 'zoomed-image';

        overlay.appendChild(zoomedImg);
        document.body.appendChild(overlay);

        img.classList.add('zoomed');

        requestAnimationFrame(() => {
            overlay.classList.add('active');
        });
    }
}
function showPost() {
    const post = document.getElementsByClassName("post")[0];
    post.style.transform = "translate(0px, 0px) rotate(0deg)";
    post.style.backgroundColor = "";
    post.style.boxShadow = "";
    post.style.animation = 'none';
}

function displayPost(postId = undefined){
    hidePost();
    if(!postId){
        if(feed_posts.length > 0){
            const data = feed_posts.shift();
            current_post_id = data.id;
            current_post = data;
            drawPost(data);
            if (!cardManager.isNavigating) {
                history.pushState(null, null, "/post/" + data.id);
            }
        }else{
            APIHandler.handle(
                () => api.getFeed(),
                {
                    onSuccess: (data) => {
                        console.log(data);
                        feed_posts = data.sort((a, b) => 0.5 - Math.random());
                        console.log(data);
                        displayPost();
                    }
                }
            );
        }
    }else{
        APIHandler.handle(
            () => api.getPost(postId),
            {
                onSuccess: (data) => {
                    current_post_id = data.id;
                    current_post = data;
                    drawPost(data);
                    if (!cardManager.isNavigating) {
                        history.pushState(null, null, "/post/" + data.id);
                    }
                }
            }
        );
    }
}
function openPrivacyPage() {
    console.log('openPrivacyPage function called');
    let privacyPage = DOM.get('privacy-page');
    const feed = DOM.get('feed');
    console.log('privacyPage element:', privacyPage);
    console.log('feed element:', feed);

   
    if (!privacyPage) {
        console.log('Creating privacy page...');
        console.log('createPrivacyContent exists:', typeof createPrivacyContent);
        console.log('createLegalPage exists:', typeof createLegalPage);

        const privacyContent = createPrivacyContent();
        console.log('Privacy content created, length:', privacyContent.length);

        const privacyPageHTML = createLegalPage({
            pageId: 'privacy-page',
            pageTitle: 'Privacy Policy',
            lastUpdated: 'Last updated: January 17, 2025',
            version: '1.0',
            closeFunction: 'closePrivacyPage',
            content: privacyContent
        });
        console.log('Privacy page HTML created, length:', privacyPageHTML.length);

       
        const main = document.querySelector('main');
        console.log('Main element found:', !!main);
        if (main) {
            main.insertAdjacentHTML('beforeend', privacyPageHTML);
            privacyPage = DOM.get('privacy-page');
            console.log('Privacy page after insertion:', privacyPage);
        }
    }

    if (privacyPage && feed) {
       
        feed.style.display = 'none';
        privacyPage.style.display = 'flex';

       
        const privacyBody = privacyPage.querySelector('.legal-body');
        if (privacyBody) {
            privacyBody.scrollTop = 0;
        }

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'privacy'}, 'Privacy Policy - VAPR', '/privacy');
        }

       
        document.title = 'Privacy Policy - VAPR';
    }
}

function closePrivacyPage() {
    const privacyPage = DOM.get('privacy-page');
    const feed = DOM.get('feed');

    if (privacyPage && feed) {
       
        privacyPage.style.display = 'none';
        feed.style.display = 'block';

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'home'}, 'VAPR - The Gamer\'s Social Network', '/');
        }

       
        document.title = 'VAPR';
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const path = window.location.pathname;
    if (path === '/privacy') {
       
        setTimeout(() => {
            openPrivacyPage();
        }, 100);
    }
});

function createPrivacyContent() {
    return `
        ${createLegalSection('1. Information We Collect', `
            <p>We collect information you provide directly to us, such as when you create an account, post content, or contact us. This includes:</p>
            ${createLegalList([
                'Discord account information (username, email, profile picture)',
                'Content you post on our platform (text, images, videos)',
                'Messages and communications with us',
                'Usage data and analytics information'
            ])}
        `)}

        ${createLegalSection('2. How We Use Your Information', `
            <p>We use the information we collect to provide, maintain, and improve our services:</p>
            ${createLegalList([
                'Operating and maintaining the VAPR platform',
                'Personalizing your experience and content feed',
                'Communicating with you about updates and features',
                'Ensuring platform security and preventing abuse',
                'Analytics and improving our services'
            ])}
        `)}

        ${createLegalSection('3. Information Sharing', `
            <p>We do not sell, trade, or otherwise transfer your personal information to third parties, except in the following circumstances:</p>
            ${createLegalList([
                'With your explicit consent',
                'To comply with legal obligations or court orders',
                'To protect our rights and prevent fraud or abuse',
                'With service providers who assist in operating our platform',
                'In connection with business transfers or acquisitions'
            ])}
        `)}

        ${createLegalSection('4. Data Storage and Security', `
            <p>We implement appropriate security measures to protect your personal information:</p>
            ${createLegalList([
                'Encrypted data transmission using industry-standard protocols',
                'Secure server infrastructure and database protection',
                'Regular security audits and vulnerability assessments',
                'Limited access to personal data on a need-to-know basis',
                'Incident response procedures for potential data breaches'
            ])}
        `)}

        ${createLegalSection('5. Discord Integration', `
            <p>VAPR uses Discord for authentication and user identification. By using our service, you acknowledge:</p>
            ${createLegalList([
                'We access basic Discord profile information for account creation',
                'Discord\'s Privacy Policy also applies to authentication data',
                'We do not store Discord passwords or sensitive authentication tokens',
                'You can revoke Discord access through your Discord account settings'
            ])}
        `)}

        ${createLegalSection('6. Cookies and Tracking', `
            <p>We use cookies and similar technologies to enhance your experience:</p>
            ${createLegalList([
                'Essential cookies for platform functionality and security',
                'Analytics cookies to understand usage patterns (via Umami and PostHog)',
                'Preference cookies to remember your settings',
                'You can control cookie preferences through your browser settings'
            ])}
        `)}

        ${createLegalSection('7. Your Rights and Choices', `
            <p>You have certain rights regarding your personal information:</p>
            ${createLegalList([
                'Access and review your personal data',
                'Request correction of inaccurate information',
                'Delete your account and associated data',
                'Export your content and data',
                'Opt out of non-essential communications'
            ])}
        `)}

        ${createLegalSection('8. Data Retention', `
            <p>We retain your information for as long as necessary to provide our services and comply with legal obligations. Specifically:</p>
            ${createLegalList([
                'Account data is retained while your account is active',
                'Content may be retained for platform integrity after account deletion',
                'Analytics data is anonymized and retained for service improvement',
                'Legal compliance may require longer retention periods'
            ])}
        `)}

        ${createLegalSection('9. International Data Transfers', `
            <p>VAPR operates globally, and your information may be transferred to and processed in countries other than your own. We ensure appropriate safeguards are in place for international transfers.</p>
        `)}

        ${createLegalSection('10. Children\'s Privacy', `
            <p>Our service is not intended for children under 13 years of age. We do not knowingly collect personal information from children under 13. If we become aware of such collection, we will take steps to delete the information.</p>
        `)}

        ${createLegalSection('11. Changes to Privacy Policy', `
            <p>We may update this Privacy Policy from time to time. We will notify you of any material changes by posting the new Privacy Policy on this page and updating the "Last updated" date. Your continued use of the service after changes constitutes acceptance of the updated policy.</p>
        `)}

        ${createLegalSection('12. Contact Information', `
            <p>If you have questions about this Privacy Policy or our data practices, please contact us using the information provided in the footer below.</p>
        `)}
    `;
}

if (typeof window !== 'undefined') {
    window.openPrivacyPage = openPrivacyPage;
    window.closePrivacyPage = closePrivacyPage;
}
let user_previous_reaction = null;
let isProcessingReaction = false;
let isEmojiDropdownOpen = false;

function initEnhancedReactions() {
   
    document.addEventListener('click', (e) => {
        const emojiOverlay = DOM.query('.emoji-reaction-overlay');
        if (emojiOverlay && !emojiOverlay.contains(e.target) && isEmojiDropdownOpen) {
            closeEmojiDropdown();
        }
    });

   
    updateEmojiTrigger();
}

function toggleEmojiDropdown() {
    if (!isUserLoggedIn()) {
        const emojiTrigger = DOM.get('emoji-trigger');
        emojiTrigger.style.animation = 'shake 0.5s ease';
        setTimeout(() => {
            emojiTrigger.style.animation = '';
            openRegisterModal();
        }, 500);
        return;
    }

    const dropdown = DOM.get('emoji-dropdown');
    const triggerBtn = DOM.get('emoji-trigger');

    if (isEmojiDropdownOpen) {
        closeEmojiDropdown();
    } else {
        openEmojiDropdown();
    }
}

function openEmojiDropdown() {
    const dropdown = DOM.get('emoji-dropdown');
    const triggerBtn = DOM.get('emoji-trigger');

    dropdown.style.display = 'block';
    triggerBtn.classList.add('active');
    isEmojiDropdownOpen = true;

   
    updateDropdownCounts();
}

function closeEmojiDropdown() {
    const dropdown = DOM.get('emoji-dropdown');
    const triggerBtn = DOM.get('emoji-trigger');

    dropdown.style.display = 'none';
    triggerBtn.classList.remove('active');
    isEmojiDropdownOpen = false;
}

function selectReaction(emoji) {
    if (isProcessingReaction) return;

   
    closeEmojiDropdown();

   
    addReaction(emoji);
}

function createRipple(event, button) {
    const rect = button.getBoundingClientRect();
    const size = Math.max(rect.width, rect.height);
    const x = event.clientX - rect.left - size / 2;
    const y = event.clientY - rect.top - size / 2;

    const ripple = DOM.create('span', {
        style: {
            position: 'absolute',
            width: `${size}px`,
            height: `${size}px`,
            borderRadius: '50%',
            background: 'rgba(255, 255, 255, 0.5)',
            pointerEvents: 'none',
            transform: `translate(${x}px, ${y}px) scale(0)`,
            animation: 'rippleEffect 0.6s ease-out'
        }
    });

    button.appendChild(ripple);
    setTimeout(() => ripple.remove(), 600);
}

function incrementEmoji(emoji) {
    const emoji_count = DOM.get(`count-${emoji}`);
    if (!emoji_count) return;

    const currentCount = parseInt(emoji_count.textContent);
    const newCount = currentCount + 1;

    emoji_count.style.transform = 'scale(1.5)';
    emoji_count.style.color = '#4ecdc4';

    setTimeout(() => {
        emoji_count.textContent = newCount;
        emoji_count.style.transform = 'scale(1)';
        emoji_count.style.color = '';
    }, 200);
}

function decrementEmoji(emoji) {
    const emoji_count = DOM.get(`count-${emoji}`);
    if (!emoji_count) return;

    const currentCount = parseInt(emoji_count.textContent);
    const newCount = Math.max(0, currentCount - 1);

    emoji_count.style.transform = 'scale(0.8)';
    emoji_count.style.color = '#e74c3c';

    setTimeout(() => {
        emoji_count.textContent = newCount;
        emoji_count.style.transform = 'scale(1)';
        emoji_count.style.color = '';
    }, 200);
}

function resetEmoji(emoji) {
    const emoji_count = DOM.get(`count-${emoji}`);
    if (emoji_count) {
        emoji_count.textContent = "0";
    }
}

function updateEmojiTrigger() {
    const currentEmojiEl = DOM.get('current-emoji');
    if (!currentEmojiEl) return;

    if (user_previous_reaction) {
        currentEmojiEl.textContent = user_previous_reaction;
    } else {
        currentEmojiEl.textContent = 'ðŸ˜Š';
    }
}

function updateDropdownCounts() {
   
    const emojis = ['ðŸ’©', 'ðŸ‘€', 'ðŸ˜‚', 'ðŸ’¯'];
    emojis.forEach(emoji => {
        const countEl = DOM.get(`count-${emoji}`);
        if (countEl) {
           
           
        }
    });

   
    DOM.queryAll('.emoji-option').forEach(btn => {
        btn.classList.remove('active');
    });

    if (user_previous_reaction) {
        const activeBtn = DOM.query(`[data-reaction="${user_previous_reaction}"]`);
        if (activeBtn) {
            activeBtn.classList.add('active');
        }
    }
}

function addReaction(emoji) {
    if (!isUserLoggedIn()) {
        const emojiTrigger = DOM.get('emoji-trigger');
        emojiTrigger.style.animation = 'shake 0.5s ease';
        setTimeout(() => {
            emojiTrigger.style.animation = '';
            openRegisterModal();
        }, 500);
        return;
    }

    if (isProcessingReaction) return;

    isProcessingReaction = true;

   
    if (user_previous_reaction && user_previous_reaction !== emoji) {
        decrementEmoji(user_previous_reaction);
    }

   
    let wasRemoving = false;
    if (emoji === null || (user_previous_reaction === emoji)) {
       
        if (user_previous_reaction) {
            decrementEmoji(user_previous_reaction);
        }
        emoji = null;
        wasRemoving = true;
    } else {
       
        incrementEmoji(emoji);
        createFloatingReaction(emoji);
    }

    APIHandler.handle(
        () => api.addReaction(current_post_id, emoji),
        {
            onSuccess: (data) => {
                console.log('Reaction updated:', data);
                user_previous_reaction = emoji;
                updateEmojiTrigger();
                isProcessingReaction = false;
            },
            onError: (error) => {
                console.error('Error updating reaction:', error);
               
                if (wasRemoving && user_previous_reaction) {
                    incrementEmoji(user_previous_reaction);
                } else if (!wasRemoving && emoji) {
                    decrementEmoji(emoji);
                }
                isProcessingReaction = false;
            }
        }
    );
}

function animateReactionIcon(icon) {
    icon.style.animation = 'none';
    setTimeout(() => {
        icon.style.animation = 'bounce 0.5s ease';
    }, 10);
}

function createFloatingReaction(emoji) {
    const triggerBtn = DOM.get('emoji-trigger');
    if (!triggerBtn) return;

    const rect = triggerBtn.getBoundingClientRect();

    const floater = DOM.create('div', {
        class: 'floating-reaction',
        style: {
            position: 'fixed',
            left: `${rect.left + rect.width / 2}px`,
            top: `${rect.top}px`,
            fontSize: '30px',
            pointerEvents: 'none',
            zIndex: '1000',
            animation: 'floatUp 1s ease-out forwards'
        }
    }, emoji);

    document.body.appendChild(floater);
    setTimeout(() => floater.remove(), 1000);
}

function displayReactions() {
   
    resetEmoji('ðŸ’©');
    resetEmoji('ðŸ‘€');
    resetEmoji('ðŸ˜‚');
    resetEmoji('ðŸ’¯');

    console.log("Post id : " + current_post_id);

    APIHandler.handle(
        () => api.getReactions(current_post_id),
        {
            onSuccess: (data) => {
                console.log('Reactions received:', data);
                user_previous_reaction = null;

                data.reactions.forEach((reaction, index) => {
                    setTimeout(() => {
                        incrementEmoji(reaction.emoji);

                        if (reaction.userId === window.user?.id) {
                            user_previous_reaction = reaction.emoji;
                        }
                    }, index * 50);
                });

               
                setTimeout(() => {
                    updateEmojiTrigger();
                }, data.reactions.length * 50 + 100);
            }
        }
    );
}

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', initEnhancedReactions);
}
function closeRegisterModal() {
   
    openSignupPage();
}

function openRegisterModal() {
    openSignupPage();
}

document.addEventListener('DOMContentLoaded', function() {
    const userCountEl = DOM.get('user_count');
    const userCountCtaEl = DOM.get('user_count_cta');

    if (userCountEl && userCountCtaEl) {
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'childList' || mutation.type === 'characterData') {
                    userCountCtaEl.textContent = userCountEl.textContent;
                }
            });
        });

        observer.observe(userCountEl, { childList: true, characterData: true, subtree: true });
    }
});

if (typeof window !== 'undefined') {
    window.closeRegisterModal = closeRegisterModal;
    window.openRegisterModal = openRegisterModal;
}
function setXPProgress(old_user, disable_xp_notif = false, force_update = false) {
    if (!user.xp) user.xp = 0;
    if (!user.level) user.level = 0;

    const total_xp = user.xp;
    const xp = Math.min(total_xp - old_user.xp, old_user.xp_required);

    updateLevel();
    updateXPDisplay();

    if (xp > 0 || force_update) {
        const diff = (xp / old_user.xp_required) * 100;
        const new_value = (total_xp / old_user.xp_required) * 100;

        const xp_bar_progress_visual = DOM.get("xp_bar_progress_visual");
        const xp_bar_progress = DOM.get("xp_bar_progress");

        xp_bar_progress_visual.style.width = diff + "%";
        xp_bar_progress_visual.style.left = (new_value - diff) + "%";

        if (!disable_xp_notif) {
            notify.showXP(xp);

            setTimeout(() => {
                if (old_user.level < user.level) {
                    notify.levelUp(user.level);
                    setXPProgress(window.user, true, true);
                }
            }, 1500);
        }

        setTimeout(() => {
            xp_bar_progress.style.width = new_value + "%";
            xp_bar_progress_visual.style.width = "0%";
            xp_bar_progress_visual.style.left = new_value + "%";
        }, 300);
    }
}

function updateLevel() {
    const level_elements = document.getElementsByClassName("xp_level");
    for (let i = 0; i < level_elements.length; i++) {
        level_elements[i].textContent = user.level;
    }

    const xp_level_elements = document.getElementsByClassName("xp-level");
    for (let i = 0; i < xp_level_elements.length; i++) {
        xp_level_elements[i].textContent = user.level;
    }
}

function updateXPDisplay() {
    const username = DOM.query('.xp-username');

    if (username) username.textContent = user.username || 'username';

    const oldUsername = DOM.query('.username');
    if (oldUsername) oldUsername.textContent = user.username || 'username';
}
async function updateSDKUserInfo() {
    if (!isRunningInTauri() || !window.user) return;

    try {
        let avatarHash = null;
        if (window.user.avatar) {
            avatarHash = window.user.avatar;
        } else if (window.user.avatar_url) {
            const match = window.user.avatar_url.match(/avatars\/\d+\/([^.]+)/);
            if (match) {
                avatarHash = match[1];
            }
        }

        await window.__TAURI__.core.invoke('update_sdk_user_info', {
            userId: window.user.id,
            username: window.user.username,
            level: window.user.level || 0,
            xp: window.user.xp || 0,
            xpRequired: window.user.xp_required || 700,
            avatar: avatarHash
        });

        console.log('SDK user info updated');
    } catch (error) {
        console.error('Failed to update SDK user info:', error);
    }
}

async function clearSDKUserInfo() {
    if (!isRunningInTauri()) return;

    try {
        await window.__TAURI__.core.invoke('clear_sdk_user_info');
        console.log('SDK user info cleared');
    } catch (error) {
        console.error('Failed to clear SDK user info:', error);
    }
}

async function getSDKConnectedSessions() {
    if (!isRunningInTauri()) return [];

    try {
        const sessions = await window.__TAURI__.core.invoke('get_sdk_connected_sessions');
        return sessions;
    } catch (error) {
        console.error('Failed to get connected sessions:', error);
        return [];
    }
}

async function monitorSDKConnections() {
    if (!isRunningInTauri()) return;

    setInterval(async () => {
        const sessions = await getSDKConnectedSessions();
        if (sessions.length > 0) {
            console.log(`Games connected via SDK: ${sessions.length}`);
        }
    }, 30000);
}

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        monitorSDKConnections();
    });
}
function createSigninPageTemplate(content) {
    return `
    <section id="signin-page" class="auth-container" style="display:none;">
        <button id="signin_menu_btn" class="create-post-btn glass_bt" onclick="openMenu()"><i class="fa-solid fa-bars"></i></button>

        <div class="auth-body">
            <div class="auth-content signin-content">
                ${content}
            </div>
        </div>
    </section>`;
}

function createSigninContent() {
    return `
        <div class="auth-step-container">
            <div class="auth-step-content">
                <div class="step-header">
                    <h2 class="step-title">Sign In</h2>
                    <p class="step-description">Welcome back! Sign in to your RSPWN account using your email address.</p>
                </div>

                <div class="auth-form">
                    <div class="input-group">
                        <div class="input-container">
                            <div class="input-icon">
                                <i class="fa-solid fa-envelope"></i>
                            </div>
                            <input type="email" id="signin-email" placeholder="Enter your email address" class="auth-input" autocomplete="email">
                        </div>
                    </div>

                    <div class="auth-methods">
                        <button onclick="signinWithMagicLink()" class="auth-btn signin-style magic-link-method">
                            <div class="btn-content">
                                <i class="fa-solid fa-link"></i>
                                <span>Send Magic Link</span>
                            </div>
                        </button>

                        <div class="method-divider">
                            <span>or continue with</span>
                        </div>

                        <div class="social-auth-grid">
                            <button onclick="signinWithDiscord()" class="social-auth-btn discord">
                                <i class="fa-brands fa-discord"></i>
                                <span>Discord</span>
                            </button>

                            <button onclick="signinWithTwitch()" class="social-auth-btn twitch">
                                <i class="fa-brands fa-twitch"></i>
                                <span>Twitch</span>
                            </button>

                            <button onclick="signinWithGoogle()" class="social-auth-btn google">
                                <i class="fa-brands fa-google"></i>
                                <span>Google</span>
                            </button>

                            <button onclick="signinWithApple()" class="social-auth-btn apple">
                                <i class="fa-brands fa-apple"></i>
                                <span>Apple</span>
                            </button>

                            <button onclick="signinWithFacebook()" class="social-auth-btn facebook">
                                <i class="fa-brands fa-facebook"></i>
                                <span>Facebook</span>
                            </button>

                            <button onclick="signinWithLinkedin()" class="social-auth-btn linkedin">
                                <i class="fa-brands fa-linkedin"></i>
                                <span>LinkedIn</span>
                            </button>
                        </div>
                    </div>

                    <div id="signin-otp-section" class="otp-verification" style="display: none;">
                        <div class="input-group">
                            <div class="input-container">
                                <div class="input-icon">
                                    <i class="fa-solid fa-lock"></i>
                                </div>
                                <input type="text" id="signin-otp-input" placeholder="Enter 6-digit code" class="auth-input otp-input" maxlength="6" pattern="[0-9]{6}">
                            </div>
                        </div>
                        <button onclick="verifySigninOTP()" class="auth-btn signin-style verify-btn">
                            <div class="btn-content">
                                <i class="fa-solid fa-right-to-bracket"></i>
                                <span>Sign In</span>
                            </div>
                        </button>
                    </div>

                    <div id="signin-status" class="status-message"></div>
                </div>

                <div class="auth-footer">
                    <p>Don't have an account? <button onclick="openSignupPage()" class="link-button">Create one here</button></p>
                </div>
            </div>
        </div>
    `;
}

function openSigninPage() {
    let signinPage = DOM.get('signin-page');
    const feed = DOM.get('feed');

    if (!signinPage) {
        const signinContent = createSigninContent();
        const signinPageHTML = createSigninPageTemplate(signinContent);

        const main = document.querySelector('main');
        if (main) {
            main.insertAdjacentHTML('beforeend', signinPageHTML);
            signinPage = DOM.get('signin-page');
        }
    }

    if (signinPage && feed) {
        hideAllPages();
        signinPage.style.display = 'flex';

        const signinBody = signinPage.querySelector('.auth-body');
        if (signinBody) {
            signinBody.scrollTop = 0;
        }

       
        applyUserBackground();

        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'signin'}, 'Sign In - RSPWN', '/signin');
        }

        document.title = 'Sign In - RSPWN';
    }
}

function applyUserBackground() {
    const backgroundUrl = localStorage.getItem('background_url');
    const backgroundId = localStorage.getItem('background_id');

    if (backgroundUrl) {
        document.body.style.backgroundImage = 'url(' + backgroundUrl + ')';
        document.body.style.backgroundSize = 'cover';
        document.body.style.backgroundPosition = 'center';
        document.body.style.backgroundRepeat = 'no-repeat';
    } else if (backgroundId) {
       
        if (typeof equipBackground === 'function') {
            equipBackground(backgroundId, false);
        }
    } else {
       
        if (typeof setDefaultBackground === 'function') {
            setDefaultBackground();
        } else {
           
            document.body.style.backgroundImage = 'linear-gradient(135deg, #0A0A0A 0%, #1A1A1A 100%)';
        }
    }
}

async function signinWithMagicLink() {
    const emailInput = document.getElementById('signin-email');
    const email = emailInput?.value?.trim();

    if (!email) {
        showSigninStatus('Please enter your email address', true);
        return;
    }

    if (!isValidEmail(email)) {
        showSigninStatus('Please enter a valid email address', true);
        return;
    }

    try {
        const response = await fetch('/api/auth/magic-link', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ email })
        });

        const result = await response.json();

        if (result.success) {
            showSigninStatus('Magic link sent! Check your email and click the link to sign in.');
        } else {
            showSigninStatus(result.message || 'Failed to send magic link', true);
        }
    } catch (error) {
        console.error('Error sending signin magic link:', error);
        showSigninStatus('Failed to send magic link', true);
    }
}

async function signinWithOTP() {
    const emailInput = document.getElementById('signin-email');
    const email = emailInput?.value?.trim();

    if (!email) {
        showSigninStatus('Please enter your email address', true);
        return;
    }

    if (!isValidEmail(email)) {
        showSigninStatus('Please enter a valid email address', true);
        return;
    }

    try {
        const response = await fetch('/api/auth/otp', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ email })
        });

        const result = await response.json();

        if (result.success) {
            showSigninStatus('OTP sent! Check your email for the 6-digit code.');
            document.getElementById('signin-otp-section').style.display = 'block';
            document.getElementById('signin-otp-input').focus();
        } else {
            showSigninStatus(result.message || 'Failed to send OTP', true);
        }
    } catch (error) {
        console.error('Error sending signin OTP:', error);
        showSigninStatus('Failed to send OTP', true);
    }
}

async function verifySigninOTP() {
    const emailInput = document.getElementById('signin-email');
    const otpInput = document.getElementById('signin-otp-input');
    const email = emailInput?.value?.trim();
    const code = otpInput?.value?.trim();

    if (!email || !code) {
        showSigninStatus('Please enter both email and OTP code', true);
        return;
    }

    if (code.length !== 6) {
        showSigninStatus('OTP code must be 6 digits', true);
        return;
    }

    try {
        const response = await fetch('/api/auth/verify-otp', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ email, code })
        });

        const result = await response.json();

        if (result.success) {
            showSigninStatus('Sign in successful! Redirecting...');
            setTimeout(() => {
                window.location.href = '/';
            }, 1000);
        } else {
            showSigninStatus(result.message || 'Invalid OTP code', true);
        }
    } catch (error) {
        console.error('Error verifying signin OTP:', error);
        showSigninStatus('Failed to verify OTP', true);
    }
}

function signinWithDiscord() {
    showSigninStatus('Discord authentication coming soon!', true);
}

function signinWithTwitch() {
    showSigninStatus('Twitch authentication coming soon!', true);
}

function signinWithGoogle() {
    showSigninStatus('Google authentication coming soon!', true);
}

function signinWithApple() {
    showSigninStatus('Apple authentication coming soon!', true);
}

function signinWithFacebook() {
    showSigninStatus('Facebook authentication coming soon!', true);
}

function signinWithLinkedin() {
    showSigninStatus('LinkedIn authentication coming soon!', true);
}

function showSigninStatus(message, isError = false) {
    const statusDiv = document.getElementById('signin-status');
    if (statusDiv) {
        statusDiv.textContent = message;
        statusDiv.className = `status-message ${isError ? 'error' : 'success'}`;
        statusDiv.style.display = 'block';
        setTimeout(() => {
            statusDiv.style.display = 'none';
        }, 5000);
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const path = window.location.pathname;
    if (path === '/signin' || path === '/login') {
        setTimeout(() => {
            openSigninPage();
        }, 100);
    }
});

if (typeof window !== 'undefined') {
    window.openSigninPage = openSigninPage;
    window.signinWithMagicLink = signinWithMagicLink;
    window.signinWithOTP = signinWithOTP;
    window.signinWithDiscord = signinWithDiscord;
    window.verifySigninOTP = verifySigninOTP;
}
function createSignupPageTemplate(content) {
    return `
    <section id="signup-page" class="auth-container" style="display:none;">
        <button id="signup_menu_btn" class="create-post-btn glass_bt" onclick="openMenu()"><i class="fa-solid fa-bars"></i></button>

        <div class="auth-body">
            <div class="auth-content signup-content">
                ${content}
            </div>
        </div>
    </section>`;
}

function createSignupContent() {
    return `
        <!-- Step Indicator -->
        <div class="signup-progress-section">
            <div class="step-indicator">
                <div class="step active" id="step-1-indicator">
                    <div class="step-number">1</div>
                    <span>Choose Username</span>
                </div>
                <div class="step-line">
                    <div class="step-line-fill"></div>
                </div>
                <div class="step" id="step-2-indicator">
                    <div class="step-number">2</div>
                    <span>Verify Email</span>
                </div>
            </div>
        </div>

        <!-- Step 1: Username Selection -->
        <div class="auth-step-container" id="signup-step-1">
            <div class="auth-step-content">
                <div class="step-header">
                    <h2 class="step-title">Create Your Account</h2>
                    <p class="step-description">Choose a unique username to represent you in the RSPWN community.</p>
                </div>

                <div class="auth-form">
                    <div class="input-group">
                        <div class="input-container">
                            <div class="input-icon">
                                <i class="fa-solid fa-user"></i>
                            </div>
                            <input type="text" id="signup-username" placeholder="Choose your username" class="auth-input" maxlength="20" autocomplete="username">
                        </div>
                        <div class="input-feedback" id="username-feedback"></div>
                    </div>

                    <button onclick="checkUsernameAndProceed()" class="auth-btn primary" id="continue-btn" disabled>
                        <div class="btn-content">
                            <span>Continue</span>
                            <i class="fa-solid fa-arrow-right"></i>
                        </div>
                        <div class="btn-ripple"></div>
                    </button>

                    <div id="signup-status-step1" class="status-message"></div>
                </div>

                <div class="auth-footer">
                    <p>Already have an account? <button onclick="openSigninPage()" class="link-button">Sign in here</button></p>
                </div>
            </div>
        </div>

        <!-- Step 2: Email Authentication -->
        <div class="auth-step-container" id="signup-step-2" style="display: none;">
            <div class="auth-step-content">
                <div class="step-header">
                    <h2 class="step-title">Verify Your Email</h2>
                    <p class="step-description">Great choice! Username <strong id="chosen-username" class="highlight-text"></strong> is yours. Now let's verify your email address.</p>
                </div>

                <div class="auth-form">
                    <div class="input-group">
                        <div class="input-container">
                            <div class="input-icon">
                                <i class="fa-solid fa-envelope"></i>
                            </div>
                            <input type="email" id="signup-email" placeholder="Enter your email address" class="auth-input" autocomplete="email">
                        </div>
                    </div>

                    <div class="auth-methods">
                        <button onclick="signupWithMagicLink()" class="auth-btn primary magic-link-method">
                            <div class="btn-content">
                                <i class="fa-solid fa-link"></i>
                                <span>Send Magic Link</span>
                            </div>
                            <div class="btn-ripple"></div>
                        </button>
                    </div>

                    <div id="signup-otp-section" class="otp-verification" style="display: none;">
                        <div class="input-group">
                            <div class="input-container">
                                <div class="input-icon">
                                    <i class="fa-solid fa-lock"></i>
                                </div>
                                <input type="text" id="signup-otp-input" placeholder="Enter 6-digit code" class="auth-input otp-input" maxlength="6" pattern="[0-9]{6}">
                            </div>
                        </div>
                        <button onclick="verifySignupOTP()" class="auth-btn success">
                            <div class="btn-content">
                                <i class="fa-solid fa-check"></i>
                                <span>Create Account</span>
                            </div>
                            <div class="btn-ripple"></div>
                        </button>
                    </div>

                    <button onclick="goBackToStep1()" class="back-button">
                        <i class="fa-solid fa-arrow-left"></i>
                        <span>Back to Username</span>
                    </button>

                    <div id="signup-status" class="status-message"></div>
                </div>
            </div>
        </div>
    `;
}

function openSignupPage() {
    let signupPage = DOM.get('signup-page');
    const feed = DOM.get('feed');

    if (!signupPage) {
        const signupContent = createSignupContent();
        const signupPageHTML = createSignupPageTemplate(signupContent);

        const main = document.querySelector('main');
        if (main) {
            main.insertAdjacentHTML('beforeend', signupPageHTML);
            signupPage = DOM.get('signup-page');
        }
    }

    if (signupPage && feed) {
        hideAllPages();
        signupPage.style.display = 'flex';

        const signupBody = signupPage.querySelector('.auth-body');
        if (signupBody) {
            signupBody.scrollTop = 0;
        }

       
        applyUserBackground();

        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'signup'}, 'Sign Up - RSPWN', '/signup');
        }

        document.title = 'Sign Up - RSPWN';

       
        setTimeout(() => {
            setupUsernameValidation();
        }, 100);
    }
}

function applyUserBackground() {
    const backgroundUrl = localStorage.getItem('background_url');
    const backgroundId = localStorage.getItem('background_id');

    if (backgroundUrl) {
        document.body.style.backgroundImage = 'url(' + backgroundUrl + ')';
        document.body.style.backgroundSize = 'cover';
        document.body.style.backgroundPosition = 'center';
        document.body.style.backgroundRepeat = 'no-repeat';
    } else if (backgroundId) {
       
        if (typeof equipBackground === 'function') {
            equipBackground(backgroundId, false);
        }
    } else {
       
        if (typeof setDefaultBackground === 'function') {
            setDefaultBackground();
        } else {
           
            document.body.style.backgroundImage = 'linear-gradient(135deg, #0A0A0A 0%, #1A1A1A 100%)';
        }
    }
}

function hideAllPages() {
    const pages = ['feed', 'auth-page', 'signup-page', 'signin-page'];
    pages.forEach(pageId => {
        const page = DOM.get(pageId);
        if (page) page.style.display = 'none';
    });
}

let selectedUsername = '';

function setupUsernameValidation() {
    const usernameInput = document.getElementById('signup-username');
    const continueBtn = document.getElementById('continue-btn');
    const feedbackDiv = document.getElementById('username-feedback');

    if (!usernameInput) return;

    let debounceTimer;

    usernameInput.addEventListener('input', function() {
        const username = this.value.trim();

        clearTimeout(debounceTimer);
        continueBtn.disabled = true;

        if (!username) {
            feedbackDiv.innerHTML = '';
            return;
        }

        if (username.length < 3) {
            feedbackDiv.innerHTML = '<div class="feedback error"><i class="fa-solid fa-times"></i> Username must be at least 3 characters</div>';
            return;
        }

        if (username.length > 20) {
            feedbackDiv.innerHTML = '<div class="feedback error"><i class="fa-solid fa-times"></i> Username must be 20 characters or less</div>';
            return;
        }

        if (!/^[a-zA-Z0-9_-]+$/.test(username)) {
            feedbackDiv.innerHTML = '<div class="feedback error"><i class="fa-solid fa-times"></i> Only letters, numbers, underscores, and hyphens allowed</div>';
            return;
        }

        feedbackDiv.innerHTML = '<div class="feedback checking"><i class="fa-solid fa-spinner fa-spin"></i> Checking availability...</div>';

        debounceTimer = setTimeout(() => checkUsernameAvailability(username), 500);
    });
}

async function checkUsernameAvailability(username) {
    const feedbackDiv = document.getElementById('username-feedback');
    const continueBtn = document.getElementById('continue-btn');

    try {
        const response = await fetch('/api/auth/check-username', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ username })
        });

        const result = await response.json();

        if (result.success) {
            feedbackDiv.innerHTML = '<div class="feedback success"><i class="fa-solid fa-check"></i> Username is available!</div>';
            continueBtn.disabled = false;
            selectedUsername = username;
        } else {
            feedbackDiv.innerHTML = `<div class="feedback error"><i class="fa-solid fa-times"></i> ${result.message}</div>`;
            continueBtn.disabled = true;
        }
    } catch (error) {
        feedbackDiv.innerHTML = '<div class="feedback error"><i class="fa-solid fa-times"></i> Error checking username</div>';
        continueBtn.disabled = true;
    }
}

function checkUsernameAndProceed() {
    if (!selectedUsername) return;

   
    document.getElementById('step-1-indicator').classList.remove('active');
    document.getElementById('step-1-indicator').classList.add('completed');
    document.getElementById('step-2-indicator').classList.add('active');

   
    document.getElementById('signup-step-1').style.display = 'none';
    document.getElementById('signup-step-2').style.display = 'block';

   
    document.getElementById('chosen-username').textContent = selectedUsername;

   
    setTimeout(() => {
        document.getElementById('signup-email').focus();
    }, 300);
}

function goBackToStep1() {
   
    document.getElementById('step-2-indicator').classList.remove('active');
    document.getElementById('step-1-indicator').classList.remove('completed');
    document.getElementById('step-1-indicator').classList.add('active');

   
    document.getElementById('signup-step-2').style.display = 'none';
    document.getElementById('signup-step-1').style.display = 'block';

   
    const otpSection = document.getElementById('signup-otp-section');
    if (otpSection) otpSection.style.display = 'none';
}

async function signupWithMagicLink() {
    const emailInput = document.getElementById('signup-email');
    const email = emailInput?.value?.trim();
    const button = document.querySelector('.magic-link-btn');

    if (!selectedUsername) {
        showSignupStatus('Please complete step 1 first', true);
        return;
    }

    if (!email) {
        showSignupStatus('Please enter your email address', true);
        return;
    }

    if (!isValidEmail(email)) {
        showSignupStatus('Please enter a valid email address', true);
        return;
    }

   
    const originalText = button.querySelector('span').textContent;
    button.querySelector('span').innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Sending...';
    button.disabled = true;

    try {
        const response = await fetch('/api/auth/signup/magic-link', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ username: selectedUsername, email })
        });

        const result = await response.json();

        if (result.success) {
            showSignupStatus('Magic link sent! Check your email and click the link to complete signup.');
            button.querySelector('span').innerHTML = '<i class="fa-solid fa-check"></i> Sent!';
        } else {
            showSignupStatus(result.message || 'Failed to send magic link', true);
            button.querySelector('span').textContent = originalText;
            button.disabled = false;
        }
    } catch (error) {
        console.error('Error sending signup magic link:', error);
        showSignupStatus('Failed to send magic link', true);
        button.querySelector('span').textContent = originalText;
        button.disabled = false;
    }
}

async function signupWithOTP() {
    const emailInput = document.getElementById('signup-email');
    const email = emailInput?.value?.trim();

    if (!selectedUsername) {
        showSignupStatus('Please complete step 1 first', true);
        return;
    }

    if (!email) {
        showSignupStatus('Please enter your email address', true);
        return;
    }

    if (!isValidEmail(email)) {
        showSignupStatus('Please enter a valid email address', true);
        return;
    }

    try {
        const response = await fetch('/api/auth/signup/otp', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ username: selectedUsername, email })
        });

        const result = await response.json();

        if (result.success) {
            showSignupStatus('OTP sent! Check your email for the 6-digit code.');
            document.getElementById('signup-otp-section').style.display = 'block';
            document.getElementById('signup-otp-input').focus();
        } else {
            showSignupStatus(result.message || 'Failed to send OTP', true);
        }
    } catch (error) {
        console.error('Error sending signup OTP:', error);
        showSignupStatus('Failed to send OTP', true);
    }
}

async function verifySignupOTP() {
    const emailInput = document.getElementById('signup-email');
    const otpInput = document.getElementById('signup-otp-input');
    const email = emailInput?.value?.trim();
    const code = otpInput?.value?.trim();

    if (!selectedUsername || !email || !code) {
        showSignupStatus('Please fill in all fields', true);
        return;
    }

    if (code.length !== 6) {
        showSignupStatus('OTP code must be 6 digits', true);
        return;
    }

    try {
        const response = await fetch('/api/auth/signup/verify-otp', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ username: selectedUsername, email, code })
        });

        const result = await response.json();

        if (result.success) {
            showSignupStatus('Account created successfully! Redirecting...');
            setTimeout(() => {
                window.location.href = '/';
            }, 1000);
        } else {
            showSignupStatus(result.message || 'Invalid OTP code', true);
        }
    } catch (error) {
        console.error('Error verifying signup OTP:', error);
        showSignupStatus('Failed to verify OTP', true);
    }
}

function signupWithDiscord() {
    showSignupStatus('Discord authentication coming soon!', true);
}

function showSignupStatus(message, isError = false) {
    const statusDiv = document.getElementById('signup-status');
    if (statusDiv) {
        statusDiv.textContent = message;
        statusDiv.className = `status-message ${isError ? 'error' : 'success'}`;
        statusDiv.style.display = 'block';
        setTimeout(() => {
            statusDiv.style.display = 'none';
        }, 5000);
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const path = window.location.pathname;
    if (path === '/signup' || path === '/register') {
        setTimeout(() => {
            openSignupPage();
        }, 100);
    }
});

if (typeof window !== 'undefined') {
    window.openSignupPage = openSignupPage;
    window.signupWithMagicLink = signupWithMagicLink;
    window.signupWithOTP = signupWithOTP;
    window.signupWithDiscord = signupWithDiscord;
    window.verifySignupOTP = verifySignupOTP;
}
function createStorePage(content) {
    return `
    <section id="store-page" class="store-container" style="display:none;">
        <button id="store_menu_btn" class="create-post-btn glass_bt" onclick="openMenu()"><i class="fa-solid fa-bars"></i></button>

        <div class="store-header">
            <div class="store-header-content">
                <div class="store-title-section">
                    <h1 class="store-title">RSPWN</h1>
                    <p class="store-subtitle">Discover amazing games and digital content</p>
                </div>
                <div class="store-header-search">
                    <div class="search-input-wrapper">
                        <i class="fa-solid fa-search search-icon"></i>
                        <input type="text" class="store-search-input" placeholder="Search games..." id="store-search-input">
                    </div>
                </div>
            </div>
        </div>

        <div class="store-body">
            <div class="store-content">
                ${content}
            </div>
        </div>
    </section>`;
}

function openStorePage() {
    let storePage = DOM.get('store-page');
    const feed = DOM.get('feed');

   
    if (!storePage) {
        const storeContent = createStoreContent();
        const storePageHTML = createStorePage(storeContent);

       
        const main = document.querySelector('main');
        if (main) {
            main.insertAdjacentHTML('beforeend', storePageHTML);
            storePage = DOM.get('store-page');
        }
    }

    if (storePage && feed) {
       
        feed.style.display = 'none';
        storePage.style.display = 'flex';

       
        const storeBody = storePage.querySelector('.store-body');
        if (storeBody) {
            storeBody.scrollTop = 0;
        }

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'store'}, 'Game Store - VAPR', '/store');
        }

       
        document.title = 'Game Store - VAPR';

       
        setTimeout(() => {
            initializeStore();
        }, 100);
    }
}

function closeStorePage() {
    const storePage = DOM.get('store-page');
    const feed = DOM.get('feed');

    if (storePage && feed) {
       
        storePage.style.display = 'none';
        feed.style.display = 'block';

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'home'}, 'RSPWN - The Gamer\'s Social Network', '/');
        }

       
        document.title = 'RSPWN';
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const path = window.location.pathname;
    if (path === '/store') {
       
        setTimeout(() => {
            openStorePage();
        }, 100);
    }
});

function createStoreContent() {
    return `
        <div class="featured-carousel-section">
            ${createFeaturedCarousel()}
        </div>

        <div class="store-filters" id="store-filters">
            ${createStoreFilters()}
        </div>

        <div class="store-grid" id="store-grid">
            ${createStoreGrid()}
        </div>
    `;
}

function createFeaturedCarousel() {
    const featuredGames = [
        {
            id: 'featured-1',
            title: 'Cyber Warriors 2077',
            description: 'Experience the ultimate cyberpunk adventure in a dystopian future. Battle through neon-lit streets, hack corporate systems, and uncover dark conspiracies that threaten humanity\'s last hope.',
            price: '$29.99',
            originalPrice: '$59.99',
            discount: '50%',
            category: 'action',
            rating: '4.8',
            reviews: '2.1k',
            image: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            backgroundImage: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            badge: 'featured',
            tags: ['Action', 'RPG', 'Cyberpunk', 'Open World']
        },
        {
            id: 'featured-2',
            title: 'Mystic Realms',
            description: 'Embark on an epic fantasy journey through magical worlds filled with ancient mysteries. Discover powerful artifacts, battle mythical creatures, and shape the destiny of entire realms.',
            price: '$24.99',
            originalPrice: '$39.99',
            discount: '37%',
            category: 'adventure',
            rating: '4.6',
            reviews: '1.8k',
            image: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            backgroundImage: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            badge: 'new',
            tags: ['Adventure', 'Fantasy', 'Magic', 'Story Rich']
        },
        {
            id: 'featured-3',
            title: 'Space Colony Alpha',
            description: 'Build and manage thriving colonies across the galaxy. Master resource management, research cutting-edge technologies, and ensure the survival of humanity among the stars.',
            price: '$27.99',
            originalPrice: '$44.99',
            discount: '38%',
            category: 'strategy',
            rating: '4.5',
            reviews: '780',
            image: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            backgroundImage: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            badge: 'featured',
            tags: ['Strategy', 'Simulation', 'Space', 'Colony Management']
        }
    ];

    return `
        <div class="featured-carousel">
            <div class="featured-main" id="featured-main">
                ${createFeaturedMainDisplay(featuredGames[0])}
            </div>
            <div class="featured-sidebar">
                <h3 class="featured-sidebar-title">Featured Games</h3>
                <div class="featured-list" id="featured-list">
                    ${featuredGames.map((game, index) => createFeaturedListItem(game, index)).join('')}
                </div>
            </div>
        </div>
    `;
}

function createFeaturedMainDisplay(game) {
    return `
        <div class="featured-main-bg" style="background-image: url('${game.image}')"></div>
        <div class="featured-main-overlay"></div>
        <div class="featured-main-content">
            <div class="featured-game-info">
                <h1 class="featured-title">${game.title}</h1>
                <div class="featured-price-section">
                    <div class="featured-discount">-${game.discount}</div>
                    <div class="featured-prices">
                        <span class="featured-original-price">${game.originalPrice}</span>
                        <span class="featured-current-price">${game.price}</span>
                    </div>
                </div>
                <div class="featured-actions">
                    <button class="featured-buy-btn" onclick="purchaseGame('${game.id}')">
                        <i class="fa-solid fa-shopping-cart"></i>
                        Buy Now
                    </button>
                    <button class="featured-wishlist-btn" onclick="addToWishlist('${game.id}')">
                        <i class="fa-solid fa-heart"></i>
                        Wishlist
                    </button>
                </div>
            </div>
        </div>
    `;
}

function createFeaturedListItem(game, index) {
    return `
        <div class="featured-list-item ${index === 0 ? 'active' : ''}" data-game-index="${index}" onclick="selectFeaturedGame(${index})">
            <div class="featured-item-image">
                <img src="${game.image}" alt="${game.title}" loading="lazy">
            </div>
            <div class="featured-item-info">
                <h4 class="featured-item-title">${game.title}</h4>
                <div class="featured-item-price">${game.price}</div>
            </div>
            <div class="featured-item-progress">
                <div class="progress-bar" id="progress-${index}">
                    <div class="progress-fill"></div>
                </div>
            </div>
        </div>
    `;
}

function createStoreFilters() {
    const filters = [
        { category: 'all', label: 'All Games', active: true },
        { category: 'action', label: 'Action', active: false },
        { category: 'adventure', label: 'Adventure', active: false },
        { category: 'strategy', label: 'Strategy', active: false },
        { category: 'indie', label: 'Indie', active: false },
        { category: 'featured', label: 'Featured', active: false }
    ];

    return filters.map(filter =>
        `<store-filter category="${filter.category}" label="${filter.label}" ${filter.active ? 'active="true"' : ''}></store-filter>`
    ).join('');
}

function createStoreGrid() {
    const mockGames = [
        {
            id: 'game-1',
            title: 'Cyber Warriors 2077',
            description: 'An epic cyberpunk adventure in a dystopian future. Battle through neon-lit streets and uncover corporate conspiracies.',
            price: '$29.99',
            category: 'action',
            rating: '4.8',
            reviews: '2.1k',
            image: 'https://via.placeholder.com/300x180/0066cc/ffffff?text=Cyber+Warriors',
            badge: 'featured',
            isFeatured: true
        },
        {
            id: 'game-2',
            title: 'Mystic Realms',
            description: 'Explore magical worlds filled with ancient mysteries and powerful artifacts. Your destiny awaits.',
            price: '$24.99',
            category: 'adventure',
            rating: '4.6',
            reviews: '1.8k',
            image: 'https://via.placeholder.com/300x180/8b5cf6/ffffff?text=Mystic+Realms',
            badge: 'new'
        },
        {
            id: 'game-3',
            title: 'Empire Builder',
            description: 'Build and manage your own civilization. Lead armies, research technologies, and conquer new lands.',
            price: '$34.99',
            category: 'strategy',
            rating: '4.7',
            reviews: '950',
            image: 'https://via.placeholder.com/300x180/059669/ffffff?text=Empire+Builder',
            badge: ''
        },
        {
            id: 'game-4',
            title: 'Neon Racer',
            description: 'High-speed racing through futuristic cities. Customize your vehicle and dominate the competition.',
            price: '$19.99',
            category: 'action',
            rating: '4.4',
            reviews: '1.2k',
            image: 'https://via.placeholder.com/300x180/dc2626/ffffff?text=Neon+Racer',
            badge: ''
        },
        {
            id: 'game-5',
            title: 'Pixel Quest',
            description: 'A charming indie adventure with retro graphics and modern gameplay. Perfect for casual gaming sessions.',
            price: '$14.99',
            category: 'indie',
            rating: '4.9',
            reviews: '3.4k',
            image: 'https://via.placeholder.com/300x180/f59e0b/ffffff?text=Pixel+Quest',
            badge: 'featured',
            isFeatured: true
        },
        {
            id: 'game-6',
            title: 'Space Colony Alpha',
            description: 'Manage resources and build thriving colonies across the galaxy. The future of humanity is in your hands.',
            price: '$27.99',
            category: 'strategy',
            rating: '4.5',
            reviews: '780',
            image: 'https://via.placeholder.com/300x180/7c3aed/ffffff?text=Space+Colony',
            badge: 'new'
        },
        {
            id: 'game-7',
            title: 'Shadow Legends',
            description: 'An epic fantasy RPG with deep character customization and engaging storylines.',
            price: '$39.99',
            category: 'adventure',
            rating: '4.3',
            reviews: '2.7k',
            image: 'https://via.placeholder.com/300x180/1f2937/ffffff?text=Shadow+Legends',
            badge: ''
        },
        {
            id: 'game-8',
            title: 'Retro Arcade Mix',
            description: 'A collection of classic arcade games reimagined for modern players. Nostalgia meets innovation.',
            price: '$12.99',
            category: 'indie',
            rating: '4.6',
            reviews: '1.5k',
            image: 'https://via.placeholder.com/300x180/ec4899/ffffff?text=Retro+Arcade',
            badge: ''
        }
    ];

    return mockGames.map(game => createStoreItem(game)).join('');
}

function createStoreItem(game) {
    const stars = 'â˜…'.repeat(Math.floor(parseFloat(game.rating)));

    return `<store-item
        id="${game.id}"
        title="${game.title}"
        description="${game.description}"
        price="${game.price}"
        category="${game.category}"
        rating="${game.rating}"
        reviews="${game.reviews}"
        image="${game.image}"
        stars="${stars}"
        ${game.badge ? `badge="${game.badge}"` : ''}
    ></store-item>`;
}

function initializeStore() {
   
    setTimeout(() => {
        initializeStoreFilters();
        initializeStoreSearch();
        initializeFeaturedCarousel();
    }, 100);
}

function initializeStoreFilters() {
   
    const filterBtns = document.querySelectorAll('.store-filter-btn');
    filterBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            const category = this.dataset.category;
            filterGames(category);

           
            filterBtns.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
        });
    });
}

function initializeStoreSearch() {
   
    const searchInput = document.getElementById('store-search-input');
    const mobileSearchInput = document.getElementById('store-search-mobile-input');

    if (searchInput) {
        searchInput.addEventListener('input', function() {
            searchGames(this.value);
        });
    }

    if (mobileSearchInput) {
        mobileSearchInput.addEventListener('input', function() {
            searchGames(this.value);
        });
    }

   
    if (window.innerWidth <= 768) {
        const mobileSearch = document.querySelector('.store-search-mobile');
        if (mobileSearch) {
            mobileSearch.style.display = 'block';
        }
    }
}

function filterGames(category) {
    const storeItems = document.querySelectorAll('.store-item');

    storeItems.forEach(item => {
        if (category === 'all' || item.dataset.category === category) {
            item.style.display = 'block';
        } else {
            item.style.display = 'none';
        }
    });
}

function searchGames(query) {
    const storeItems = document.querySelectorAll('.store-item');
    const lowercaseQuery = query.toLowerCase();

    storeItems.forEach(item => {
        const title = item.querySelector('.store-item-title').textContent.toLowerCase();
        const description = item.querySelector('.store-item-description').textContent.toLowerCase();
        const category = item.dataset.category.toLowerCase();

        if (title.includes(lowercaseQuery) ||
            description.includes(lowercaseQuery) ||
            category.includes(lowercaseQuery)) {
            item.style.display = 'block';
        } else {
            item.style.display = 'none';
        }
    });
}

function purchaseGame(gameId) {
   
    alert(`Purchase functionality for game ${gameId} would be implemented here`);
}


function addToWishlist(gameId) {
   
    alert(`Added ${gameId} to wishlist`);
}

let currentFeaturedIndex = 0;
let carouselInterval;
let progressIntervals = [];
const CAROUSEL_DURATION = 8000;

function initializeFeaturedCarousel() {
    const featuredGames = getFeaturedGamesData();

    if (featuredGames.length === 0) return;

   
    startCarouselTimer();

   
    startProgressBars();
}

function getFeaturedGamesData() {
   
    return [
        {
            id: 'featured-1',
            title: 'Cyber Warriors 2077',
            description: 'Experience the ultimate cyberpunk adventure in a dystopian future. Battle through neon-lit streets, hack corporate systems, and uncover dark conspiracies that threaten humanity\'s last hope.',
            price: '$29.99',
            originalPrice: '$59.99',
            discount: '50%',
            category: 'action',
            rating: '4.8',
            reviews: '2.1k',
            image: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            backgroundImage: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            badge: 'featured',
            tags: ['Action', 'RPG', 'Cyberpunk', 'Open World']
        },
        {
            id: 'featured-2',
            title: 'Mystic Realms',
            description: 'Embark on an epic fantasy journey through magical worlds filled with ancient mysteries. Discover powerful artifacts, battle mythical creatures, and shape the destiny of entire realms.',
            price: '$24.99',
            originalPrice: '$39.99',
            discount: '37%',
            category: 'adventure',
            rating: '4.6',
            reviews: '1.8k',
            image: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            backgroundImage: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            badge: 'new',
            tags: ['Adventure', 'Fantasy', 'Magic', 'Story Rich']
        },
        {
            id: 'featured-3',
            title: 'Space Colony Alpha',
            description: 'Build and manage thriving colonies across the galaxy. Master resource management, research cutting-edge technologies, and ensure the survival of humanity among the stars.',
            price: '$27.99',
            originalPrice: '$44.99',
            discount: '38%',
            category: 'strategy',
            rating: '4.5',
            reviews: '780',
            image: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            backgroundImage: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            badge: 'featured',
            tags: ['Strategy', 'Simulation', 'Space', 'Colony Management']
        }
    ];
}

function selectFeaturedGame(index) {
    const featuredGames = getFeaturedGamesData();

    if (index < 0 || index >= featuredGames.length) return;

    currentFeaturedIndex = index;

   
    updateFeaturedMainDisplay(featuredGames[index]);

   
    updateFeaturedListActive(index);

   
    resetCarouselTimer();
    resetProgressBars();
    startProgressBars();
}

function updateFeaturedMainDisplay(game) {
    const mainDisplay = document.getElementById('featured-main');
    if (mainDisplay) {
        mainDisplay.innerHTML = createFeaturedMainDisplay(game);
    }
}

function updateFeaturedListActive(activeIndex) {
    const listItems = document.querySelectorAll('.featured-list-item');
    listItems.forEach((item, index) => {
        if (index === activeIndex) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });
}

function startCarouselTimer() {
    carouselInterval = setInterval(() => {
        const featuredGames = getFeaturedGamesData();
        currentFeaturedIndex = (currentFeaturedIndex + 1) % featuredGames.length;
        selectFeaturedGame(currentFeaturedIndex);
    }, CAROUSEL_DURATION);
}

function resetCarouselTimer() {
    if (carouselInterval) {
        clearInterval(carouselInterval);
    }
    startCarouselTimer();
}

function startProgressBars() {
    const featuredGames = getFeaturedGamesData();

   
    progressIntervals.forEach(interval => clearInterval(interval));
    progressIntervals = [];

   
    featuredGames.forEach((_, index) => {
        const listItem = document.querySelector(`.featured-list-item[data-game-index="${index}"]`);
        if (listItem) {
            listItem.style.setProperty('--progress-width', '0%');
        }
    });

   
    startProgressForItem(currentFeaturedIndex);
}

function startProgressForItem(index) {
    const listItem = document.querySelector(`.featured-list-item[data-game-index="${index}"]`);
    if (!listItem) return;

    let progress = 0;
    const increment = 100 / (CAROUSEL_DURATION / 50);

    const interval = setInterval(() => {
        progress += increment;
        const progressWidth = Math.min(progress, 100);
        listItem.style.setProperty('--progress-width', `${progressWidth}%`);

        if (progress >= 100) {
            clearInterval(interval);
        }
    }, 50);

    progressIntervals.push(interval);
}

function resetProgressBars() {
   
    progressIntervals.forEach(interval => clearInterval(interval));
    progressIntervals = [];

   
    const featuredGames = getFeaturedGamesData();
    featuredGames.forEach((_, index) => {
        const listItem = document.querySelector(`.featured-list-item[data-game-index="${index}"]`);
        if (listItem) {
            listItem.style.setProperty('--progress-width', '0%');
        }
    });
}

if (typeof window.VAPR !== 'undefined') {
   
    VAPR.on('store-filter', 'mounted', (element) => {
        element.addEventListener('click', function() {
            const category = this.dataset.category;
            filterGames(category);

           
            const filterBtns = document.querySelectorAll('.store-filter-btn');
            filterBtns.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
        });
    });

   
    VAPR.on('store-item', 'mounted', (element) => {
       
        console.log('Store item mounted:', element.dataset.gameId);
    });
}

if (typeof window !== 'undefined') {
    window.openStorePage = openStorePage;
    window.closeStorePage = closeStorePage;
    window.purchaseGame = purchaseGame;
    window.addToWishlist = addToWishlist;
    window.selectFeaturedGame = selectFeaturedGame;
}
class TebexAPI {
    constructor() {
        this.baseURL = 'https://headless.tebex.io/api';
        this.configs = [];
    }

    async loadConfigs() {
        try {
            const response = await fetch('/api/tebex-configs', {
                credentials: 'include'
            });
            const data = await response.json();
            if (data.success) {
                this.configs = data.configs;
            }
        } catch (error) {
            console.error('Failed to load Tebex configurations:', error);
        }
    }

    async request(path, options = {}, webstoreToken = null) {
        const url = `${this.baseURL}${path}`;

        try {
            const response = await fetch(url, {
                ...options,
                headers: {
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            });

            if (!response.ok) {
                throw new Error(`Tebex API error: ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Tebex API request failed:', error);
            throw error;
        }
    }

    async getAllPackages() {
        await this.loadConfigs();

        const allPackages = [];

        for (const config of this.configs) {
            try {
                const response = await this.request(`/accounts/${config.webstoreToken}/packages`);
                const packages = response.data || [];

                const packagesWithStore = packages.map(pkg => ({
                    ...pkg,
                    storeInfo: {
                        userId: config.userId,
                        username: config.username,
                        storeName: config.storeName,
                        webstoreToken: config.webstoreToken
                    }
                }));

                allPackages.push(...packagesWithStore);
            } catch (error) {
                console.error(`Failed to load packages for store ${config.storeName}:`, error);
            }
        }

        return { data: allPackages };
    }

    async applyCreatorCode(basketIdent, creatorCode, webstoreToken) {
        return this.request(`/accounts/${webstoreToken}/baskets/${basketIdent}/creator-codes`, {
            method: 'POST',
            body: JSON.stringify({
                creator_code: creatorCode
            })
        });
    }
}

window.tebexAPI = new TebexAPI();
function handleCheckoutSuccess() {
    notify.success('Purchase completed successfully!');

    if (window.loadLibraryData) {
        loadLibraryData();
    }
}

function handleCheckoutCancel() {
    notify.info('Checkout cancelled');
}

document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);

    if (window.location.pathname === '/checkout/success') {
        handleCheckoutSuccess();
        window.history.replaceState({}, '', '/');
    } else if (window.location.pathname === '/checkout/cancel') {
        handleCheckoutCancel();
        window.history.replaceState({}, '', '/');
    }
});
function openTermsPage() {
    console.log('openTermsPage function called');
    let termsPage = DOM.get('terms-page');
    const feed = DOM.get('feed');
    console.log('termsPage element:', termsPage);
    console.log('feed element:', feed);

   
    if (!termsPage) {
        const termsContent = createTermsContent();
        const termsPageHTML = createLegalPage({
            pageId: 'terms-page',
            pageTitle: 'Terms of Service',
            lastUpdated: 'Last updated: January 17, 2025',
            version: '1.0',
            closeFunction: 'closeTermsPage',
            content: termsContent
        });

       
        const main = document.querySelector('main');
        if (main) {
            main.insertAdjacentHTML('beforeend', termsPageHTML);
            termsPage = DOM.get('terms-page');
        }
    }

    if (termsPage && feed) {
       
        feed.style.display = 'none';
        termsPage.style.display = 'flex';

       
        const termsBody = termsPage.querySelector('.legal-body');
        if (termsBody) {
            termsBody.scrollTop = 0;
        }

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'terms'}, 'Terms of Service - VAPR', '/terms');
        }

       
        document.title = 'Terms of Service - VAPR';
    }
}

function closeTermsPage() {
    const termsPage = DOM.get('terms-page');
    const feed = DOM.get('feed');

    if (termsPage && feed) {
       
        termsPage.style.display = 'none';
        feed.style.display = 'block';

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'home'}, 'VAPR - The Gamer\'s Social Network', '/');
        }

       
        document.title = 'VAPR';
    }
}


document.addEventListener('DOMContentLoaded', function() {
    const path = window.location.pathname;
    if (path === '/terms') {
       
        setTimeout(() => {
            openTermsPage();
        }, 100);
    }
});

function createTermsContent() {
    return `
        ${createLegalSection('1. Acceptance of Terms', `
            <p>By accessing and using VAPR ("the Service"), you accept and agree to be bound by the terms and provision of this agreement. If you do not agree to abide by the above, please do not use this service.</p>
        `)}

        ${createLegalSection('2. Description of Service', `
            <p>VAPR is a gamified social platform where creators share content through a swipe-based interface. The platform includes user authentication via Discord, content posting with reactions, and an XP/leveling system.</p>
            ${createLegalList([
                'Social content sharing and discovery',
                'Gamification features including XP and leveling',
                'Creator tools and analytics',
                'Game integration and digital marketplace'
            ])}
        `)}

        ${createLegalSection('3. User Accounts', `
            <p>To access certain features of the Service, you must create an account using Discord authentication. You are responsible for:</p>
            ${createLegalList([
                'Maintaining the confidentiality of your account',
                'All activities that occur under your account',
                'Notifying us immediately of any unauthorized use',
                'Ensuring your account information is accurate and up-to-date'
            ])}
        `)}

        ${createLegalSection('4. Content Guidelines', `
            <p>Users are responsible for all content they post. Prohibited content includes:</p>
            ${createLegalList([
                'Illegal, harmful, or offensive material',
                'Content that violates intellectual property rights',
                'Spam, harassment, or abusive behavior',
                'Adult content or material inappropriate for all audiences',
                'False or misleading information'
            ])}
            <p>We reserve the right to remove content and suspend accounts that violate these guidelines.</p>
        `)}

        ${createLegalSection('5. Creator Program', `
            <p>Our Creator Program allows eligible users to monetize their content. Participation requires:</p>
            ${createLegalList([
                'Compliance with all platform guidelines',
                'Original, high-quality content creation',
                'Active engagement with the community',
                'Valid payment information for revenue sharing'
            ])}
            <p>Creator Program terms may change with notice to participants.</p>
        `)}

        ${createLegalSection('6. Game Integration', `
            <p>VAPR integrates with various games and digital platforms. Users acknowledge:</p>
            ${createLegalList([
                'Game keys and digital items are subject to third-party terms',
                'We are not responsible for external platform policies',
                'Digital purchases are final and non-refundable unless required by law',
                'Game availability may change without notice'
            ])}
        `)}

        ${createLegalSection('7. Privacy and Data', `
            <p>Your privacy is important to us. Please review our Privacy Policy for details on how we collect, use, and protect your information. By using VAPR, you consent to our data practices as outlined in our Privacy Policy.</p>
        `)}

        ${createLegalSection('8. Intellectual Property', `
            <p>The Service and its original content, features, and functionality are owned by VAPR and are protected by international copyright, trademark, patent, trade secret, and other intellectual property laws.</p>
        `)}

        ${createLegalSection('9. Limitation of Liability', `
            <p>In no event shall VAPR, its directors, employees, partners, agents, suppliers, or affiliates be liable for any indirect, incidental, special, consequential, or punitive damages, including without limitation, loss of profits, data, use, goodwill, or other intangible losses.</p>
        `)}

        ${createLegalSection('10. Termination', `
            <p>We may terminate or suspend your account and bar access to the Service immediately, without prior notice or liability, under our sole discretion, for any reason whatsoever, including without limitation if you breach the Terms.</p>
        `)}

        ${createLegalSection('11. Changes to Terms', `
            <p>We reserve the right to modify or replace these Terms at any time. If a revision is material, we will provide at least 30 days notice prior to any new terms taking effect.</p>
        `)}
    `;
}

if (typeof window !== 'undefined') {
    window.openTermsPage = openTermsPage;
    window.closeTermsPage = closeTermsPage;
}
document.addEventListener('DOMContentLoaded', (event) => {
    const post = document.getElementsByClassName("post")[0];
    let startX = 0;
    let startY = 0;
    let currentX = 0;
    let currentY = 0;
    let startTime = 0;

    post.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        currentX = startX;
        currentY = startY;
        startTime = new Date().getTime();
        post.style.transition = 'none';
        post.style.animation = 'none';
    }, { passive: true });

    post.addEventListener('touchmove', (e) => {
        currentX = e.touches[0].clientX;
        currentY = e.touches[0].clientY;
        let changeX = currentX - startX;
        let changeY = currentY - startY;
        post.style.transform = `translate(${changeX}px, ${changeY}px) rotate(${changeX * 0.1}deg)`;
    }, { passive: true });

    post.addEventListener('touchend', (e) => {
        let changeX = currentX - startX;
        let changeY = currentY - startY;
        let elapsedTime = new Date().getTime() - startTime;
        let velocity = Math.abs(changeX) / elapsedTime;
        let velocityy = Math.abs(changeY) / elapsedTime;

        if (velocity > 0.3 || Math.abs(changeX) > 100) {
            if (changeX < -100) {
                dislikePost();
            } else if (changeX > 100) {
                likePost();
            }
        }else if (velocityy > 0.3 || Math.abs(changeY) > 100) {
            if (changeY < -100) {
                skipPost();
            }
        } else {
            resetPostPosition();
        }
    });

    function resetPostPosition() {
        post.style.transition = 'transform 0.3s ease';
        post.style.transform = 'translate(0px, 0px) rotate(0deg)';
    }
});

function setInitialTransform(post) {
    const transform = post.style.transform || '';

    let translateX = 0;
    let translateY = 0;
    let rotate = 0;

    if (transform) {
        const translateMatch = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
        if (translateMatch) {
            translateX = parseInt(translateMatch[1]) || 0;
            translateY = parseInt(translateMatch[2]) || 0;
        }

        const rotateMatch = transform.match(/rotate\(([^)]+)\)/);
        if (rotateMatch) {
            rotate = parseInt(rotateMatch[1]) || 0;
        }
    }

    console.log({
        translateX: translateX,
        translateY: translateY,
        rotate: rotate
    });

    post.style.setProperty('--start-translate-x', `${translateX}px`);
    post.style.setProperty('--start-translate-y', `${translateY}px`);
    post.style.setProperty('--start-rotate', `${rotate}deg`);

    post.style.transform = "translateY(100vh)";
    post.style.transition = 'all 1s ease-in-out';
}

function displayLikeAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'swipeRight 0.6s';
    post.style.transform = "translateY(100vh)";

    notify.showActionFeedback('liked');

    confetti({
        particleCount: 100,
        spread: 70,
        origin: { y: 0.6 },
        colors: ['#22c55e', '#10b981', '#059669']
    });
}

function displayDislikeAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'swipeLeft 0.6s';
    post.style.transform = "translateY(100vh)";

    notify.showActionFeedback('passed');
}

function displaySkipAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'skip 0.6s';
    post.style.transform = "translateY(100vh)";

    notify.showActionFeedback('skipped');
}

function likePost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displayLikeAnimation();
        APIHandler.handle(
            () => api.likePost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displayLikeAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}

function skipPost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displaySkipAnimation();
        APIHandler.handle(
            () => api.skipPost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displaySkipAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}

function dislikePost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displayDislikeAnimation();
        APIHandler.handle(
            () => api.dislikePost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displayDislikeAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}
const uploadArea = DOM.query('.upload-area');
const fileInput = DOM.get('file');

if (uploadArea) {
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        uploadArea.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
        uploadArea.addEventListener(eventName, () => {
            uploadArea.classList.add('dragging');
        }, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
        uploadArea.addEventListener(eventName, () => {
            uploadArea.classList.remove('dragging');
        }, false);
    });

    uploadArea.addEventListener('drop', handleDrop, false);

    function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;

        if (files.length > 0) {
            fileInput.files = files;
            handleFileSelect(files[0]);
        }
    }
}

if (fileInput) {
    fileInput.addEventListener('change', function() {
        if (this.files && this.files[0]) {
            handleFileSelect(this.files[0]);
        }
    });
}

function handleFileSelect(file) {
    const fileType = file.type;
    const placeholder = DOM.get('upload-placeholder');
    const preview = DOM.get('upload-preview');
    const previewImage = DOM.get('preview_img');
    const previewVideo = DOM.get('preview_video');

    if (file.size > 50 * 1024 * 1024) {
        notify.error('File too large', 'Please select a file under 50MB');
        return;
    }

    const reader = new FileReader();
    reader.onload = function(e) {
        DOM.hide(placeholder);
        DOM.show(preview);

        if (fileType.startsWith('video/')) {
            previewVideo.src = e.target.result;
            DOM.show(previewVideo);
            DOM.hide(previewImage);
        } else if (fileType.startsWith('image/')) {
            previewImage.src = e.target.result;
            DOM.show(previewImage);
            DOM.hide(previewVideo);
        } else {
            notify.error('Invalid file type', 'Please upload an image or video file');
            DOM.show(placeholder, 'flex');
            DOM.hide(preview);
            return;
        }
    };
    reader.readAsDataURL(file);
}

const titleInput = DOM.get('title');
const titleCount = DOM.get('title-count');

if (titleInput && titleCount) {
    titleInput.addEventListener('input', function() {
        titleCount.textContent = this.value.length;
    });
}

let selectedGameForTag = null;

window.openGameTagModal = async function() {
    DOM.show('game-tag-modal', 'flex');
    await loadGamesForTagging();
}

window.closeGameTagModal = function() {
    DOM.hide('game-tag-modal');
}

window.selectGameForTag = function(gameId, gameTitle, gameCover) {
    selectedGameForTag = {
        id: gameId,
        title: gameTitle,
        coverImage: gameCover
    };

    DOM.hide('game-tag-button');
    DOM.show('selected-game', 'flex');
    DOM.get('selected-game-title').textContent = gameTitle;
    DOM.get('selected-game-cover').src = gameCover;

    closeGameTagModal();
}

window.removeGameTag = function() {
    selectedGameForTag = null;
    DOM.show('game-tag-button', 'inline-flex');
    DOM.hide('selected-game');
}

async function loadGamesForTagging() {
    try {
        const response = await api.request('/api/games');
        if (response.success) {
            displayGamesForTagging(response.games);
        }
    } catch (error) {
        console.error('Error loading games:', error);
    }
}

function displayGamesForTagging(games) {
    const container = DOM.get('game-tag-list');
    container.innerHTML = '';

    games.forEach(game => {
        const gameItem = DOM.create('div', {
            class: 'game-tag-item',
            onclick: () => selectGameForTag(game.id, game.title, game.coverImage)
        });

        gameItem.innerHTML = `
            <img src="${game.coverImage}" alt="${game.title}" class="game-tag-item-cover">
            <span class="game-tag-item-title">${game.title}</span>
        `;

        container.appendChild(gameItem);
    });
}

window.searchGamesForTag = function() {
    const searchTerm = DOM.get('game-tag-search').value.toLowerCase();
    const items = DOM.queryAll('.game-tag-item');

    items.forEach(item => {
        const title = item.querySelector('.game-tag-item-title').textContent.toLowerCase();
        if (title.includes(searchTerm)) {
            DOM.show(item, 'flex');
        } else {
            DOM.hide(item);
        }
    });
}

window.submitPost = async function(event) {
    event.preventDefault();

    const submitBtn = DOM.get('submit-post-btn');
    const uploadProgress = DOM.get('upload-progress');
    const progressFill = DOM.get('progress-fill');

    const title = DOM.get('title').value;
    const file = DOM.get('file').files[0];

    if (!file) {
        notify.warning('No media selected', 'Please select an image or video to upload');
        return;
    }

    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> <span>Publishing...</span>';

    const formData = new FormData();
    formData.append('title', title);

    if (selectedGameForTag) {
        formData.append('taggedGameId', selectedGameForTag.id);
    }

    if (file) {
        const fileExtension = file.name.split('.').pop();
        const fileName = `${new Date().getTime()}.${fileExtension}`;
        const fileContentType = file.type || 'application/octet-stream';
        const blob = new Blob([file], { type: fileContentType });
        formData.append("file", blob, fileName);
    }

    try {
        DOM.show(uploadProgress);

        let progress = 0;
        const progressInterval = setInterval(() => {
            progress += Math.random() * 15;
            if (progress > 90) progress = 90;
            progressFill.style.width = progress + '%';
        }, 200);

        const result = await api.createPost(formData);

        clearInterval(progressInterval);
        progressFill.style.width = '100%';

        if (result.success || result.id) { 
            confetti({
                particleCount: 100,
                spread: 70,
                origin: { y: 0.6 }
            });

           
            DOM.get('title').value = '';
            DOM.get('file').value = '';
            DOM.show('upload-placeholder', 'flex');
            DOM.hide('upload-preview');
            const titleCount = DOM.get('title-count');
            if (titleCount) {
                titleCount.textContent = '0';
            }

            removeGameTag();

            notify.success("Post published successfully!");

           
            if (window.user && result.user) {
                const oldUser = {
                    xp: window.user.xp,
                    level: window.user.level,
                    xp_required: window.user.xp_required
                };

                window.user = result.user;
                setXPProgress(oldUser);
            }

           
            closeAddPostCard();

           
            setTimeout(() => {
                router.navigate(`/post/${result.id}`, true);
            }, 300);

        } else {
            throw new Error(result.error || 'Failed to create post');
        }

    } catch (error) {
        console.error('Failed to submit post:', error);
        notify.error('Upload failed', error.message || 'Failed to create post. Please try again.');

    } finally {
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="fa-solid fa-paper-plane"></i> <span>Publish Post</span>';
        DOM.hide(uploadProgress);
        progressFill.style.width = '0%';
    }
}
const AnimationUtils = {
    animateCounter(element, start, end, duration = 1000, formatter = null) {
        if (!element) return;

        const startTime = performance.now();
        const defaultFormatter = (val) => this.formatNumber(val);
        const format = formatter || defaultFormatter;

        const updateCounter = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            const easeOutQuart = 1 - Math.pow(1 - progress, 4);
            const currentValue = Math.floor(start + (end - start) * easeOutQuart);

            element.textContent = format(currentValue);

            if (progress < 1) {
                requestAnimationFrame(updateCounter);
            }
        };

        requestAnimationFrame(updateCounter);
    },

    formatNumber(num) {
        if (num < 1000) return num.toString();
        if (num < 1000000) return (num / 1000).toFixed(1) + 'K';
        if (num < 1000000000) return (num / 1000000).toFixed(1) + 'M';
        return (num / 1000000000).toFixed(1) + 'B';
    },

    timeAgo(dateParam) {
        if (!dateParam) return null;

        const date = typeof dateParam === 'object' ? dateParam : new Date(dateParam);
        const today = new Date();
        const seconds = Math.round((today - date) / 1000);
        const minutes = Math.round(seconds / 60);
        const hours = Math.round(minutes / 60);
        const days = Math.round(hours / 24);
        const months = Math.round(days / 30.4);
        const years = Math.round(days / 365);

        if (seconds < 60) {
            return `${seconds}s ago`;
        } else if (minutes < 60) {
            return `${minutes}m ago`;
        } else if (hours < 24) {
            return `${hours}h ago`;
        } else if (days < 30) {
            return `${days}d ago`;
        } else if (months < 12) {
            return `${months}mo ago`;
        } else {
            return `${years}y ago`;
        }
    },

    formatViews(viewCount) {
        return this.formatNumber(viewCount);
    },

    escapeHtml(text) {
        const div = DOM.create('div');
        div.textContent = text;
        return div.innerHTML;
    }
};

window.animateCounter = AnimationUtils.animateCounter.bind(AnimationUtils);
window.formatNumber = AnimationUtils.formatNumber;
window.timeAgo = AnimationUtils.timeAgo;
window.formatViews = AnimationUtils.formatViews;
window.escapeHtml = AnimationUtils.escapeHtml;
const LoadingUtils = {
    loadingElement: null,
    loadingCount: 0,

    init() {
        if (!this.loadingElement) {
            const loading = document.createElement('div');
            loading.id = 'global-loading';
            loading.className = 'global-loading';
            loading.innerHTML = `
                <div class="loading-spinner">
                    <i class="fa-solid fa-spinner fa-spin"></i>
                </div>
            `;
            document.body.appendChild(loading);
            this.loadingElement = loading;
        }
    },

    show() {
        this.init();
        this.loadingElement.style.display = 'flex';
        document.body.style.overflow = 'hidden';
    },

    hide() {
        if (this.loadingElement) {
            this.loadingElement.style.display = 'none';
            document.body.style.overflow = '';
        }
    }
};

window.loading = LoadingUtils;
const NotificationUtils = {
    getToast() {
        if (typeof Swal === 'undefined') return null;

        return Swal.mixin({
            toast: true,
            position: "top-end",
            showConfirmButton: false,
            timer: 3000,
            timerProgressBar: true,
            didOpen: (toast) => {
                toast.onmouseenter = Swal.stopTimer;
                toast.onmouseleave = Swal.resumeTimer;
            }
        });
    },

    success(title, options = {}) {
        const Toast = this.getToast();
        if (!Toast) return;

        Toast.fire({
            icon: "success",
            title,
            ...options
        });
    },

    error(title, text = null, options = {}) {
        if (typeof Swal === 'undefined') return;

        if (text) {
            Swal.fire({
                icon: 'error',
                title,
                text,
                ...options
            });
        } else {
            const Toast = this.getToast();
            Toast?.fire({
                icon: "error",
                title,
                ...options
            });
        }
    },

    info(title, text = null, options = {}) {
        if (typeof Swal === 'undefined') {
            console.error('SweetAlert2 not loaded');
            return Promise.resolve({ isConfirmed: false });
        }

        if (text) {
            return Swal.fire({
                icon: 'info',
                title,
                text,
                ...options
            });
        } else {
            const Toast = this.getToast();
            if (Toast) {
                Toast.fire({
                    icon: "info",
                    title,
                    ...options
                });
            }
            return Promise.resolve({ isConfirmed: false });
        }
    },

    warning(title, text, options = {}) {
        if (typeof Swal === 'undefined') return;

        Swal.fire({
            icon: 'warning',
            title,
            text,
            ...options
        });
    },

    async confirm(title, text, options = {}) {
        if (typeof Swal === 'undefined') return false;

        const result = await Swal.fire({
            title,
            text,
            icon: 'question',
            showCancelButton: true,
            confirmButtonText: 'Yes',
            cancelButtonText: 'Cancel',
            confirmButtonColor: '#4ecdc4',
            ...options
        });

        return result.isConfirmed;
    },

    async confirmDanger(title, text, confirmText = 'Yes, delete it', options = {}) {
        if (typeof Swal === 'undefined') return false;

        const result = await Swal.fire({
            title,
            text,
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: confirmText,
            cancelButtonText: 'Cancel',
            confirmButtonColor: '#e74c3c',
            ...options
        });

        return result.isConfirmed;
    },

    levelUp(level) {
        if (typeof confetti !== 'undefined') {
            confetti({
                particleCount: 50,
                spread: 50,
                origin: { y: 0.3 },
                colors: ['#ffffff', '#4ecdc4', '#667eea']
            });
        }

        this.success(`Level ${level} reached! ðŸŽ‰`);
    },

    showXP(amount) {
        const notification = DOM.get('xp-notification');
        if (!notification) return;

        notification.style.animation = 'xpNotificationAnimation 1.5s';
        notification.textContent = `+${amount} XP`;

        setTimeout(() => {
            notification.style.animation = 'none';
        }, 1500);
    },

    showActionFeedback(action) {
        const feedback = DOM.create('div', {
            class: 'action-feedback ' + action
        });
        feedback.innerHTML = `<i class="fa-solid fa-${action === 'liked' ? 'heart' : action === 'passed' ? 'heart-crack' : 'forward'}"></i> ${action.charAt(0).toUpperCase() + action.slice(1)}!`;

        document.body.appendChild(feedback);

        setTimeout(() => {
            feedback.remove();
        }, 1000);
    },

    desktopAppPrompt(onConfirm) {
        if (typeof Swal === 'undefined') return;

        Swal.fire({
            title: 'Desktop App Required',
            html: `
                <p>To download and play games, you need the VAPR desktop app.</p>
                <p style="margin-top: 20px; font-size: 14px; color: rgba(255, 255, 255, 0.7);">
                    The desktop app allows you to:
                </p>
                <ul style="text-align: left; margin: 10px 0; font-size: 14px; color: rgba(255, 255, 255, 0.7);">
                    <li>Download and install games directly</li>
                    <li>Launch games with one click</li>
                    <li>Track your playtime</li>
                    <li>Get automatic updates</li>
                </ul>
            `,
            icon: 'info',
            showCancelButton: true,
            confirmButtonText: '<i class="fa-solid fa-download"></i> Download Desktop App',
            cancelButtonText: 'Maybe Later',
            confirmButtonColor: '#4ecdc4',
            customClass: {
                container: 'download-prompt-container'
            }
        }).then((result) => {
            if (result.isConfirmed && onConfirm) {
                onConfirm();
            }
        });
    },

    copyToClipboard(text, successMessage = 'Copied to clipboard!') {
        navigator.clipboard.writeText(text).then(() => {
            this.success(successMessage);
        }).catch(() => {
            const textArea = DOM.create('textarea', {
                value: text,
                style: {
                    position: 'absolute',
                    left: '-9999px'
                }
            });
            document.body.appendChild(textArea);
            textArea.select();
            textArea.setSelectionRange(0, 99999);

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    this.success(successMessage);
                } else {
                    this.error('Failed to copy to clipboard');
                }
            } catch (err) {
                this.error('Failed to copy to clipboard');
            }

            document.body.removeChild(textArea);
        });
    }
};

window.notify = NotificationUtils;
window.showToast = (type, title, options) => NotificationUtils[type](title, options);
let versionCheckInterval = null;
let isVersionCheckModalOpen = false;

function getWebVersion() {
    const versionElement = DOM.query('.menu-version span');
    if (versionElement) {
        const versionText = versionElement.textContent;
        const versionMatch = versionText.match(/v(\d+\.\d+\.\d+)/);
        if (versionMatch) {
            return versionMatch[1];
        }
    }
    return null;
}

function getDesktopVersion() {
    if (window.__TAURI__ && window.__TAURI__.app) {
        return window.__TAURI__.app.getVersion();
    }
    return null;
}

async function checkDesktopVersion() {
    if (!isRunningInTauri() || isVersionCheckModalOpen) {
        return;
    }

    try {
        const webVersion = getWebVersion();
        const desktopVersion = await getDesktopVersion();

        if (!webVersion || !desktopVersion) {
            console.error('Could not retrieve version information');
            return;
        }

        if (webVersion !== desktopVersion) {
            showVersionUpdateModal({
                current_version: desktopVersion,
                required_version: webVersion
            });
        }
    } catch (error) {
        console.error('Version check failed:', error);
    }
}

function showVersionUpdateModal(versionInfo) {
    if (isVersionCheckModalOpen) return;

    isVersionCheckModalOpen = true;

    if (versionCheckInterval) {
        clearInterval(versionCheckInterval);
        versionCheckInterval = null;
    }

    const downloadUrl = `https://github.com/Vic92548/VAPR/releases/download/v${versionInfo.required_version}/VAPR_${versionInfo.required_version}_x64_en-US.msi`;

    const modal = DOM.create('div', {
        id: 'version-update-modal',
        class: 'version-modal-overlay'
    });

    modal.innerHTML = `
        <div class="version-modal-content">
            <div class="version-modal-header">
                <i class="fa-solid fa-exclamation-triangle"></i>
                <h2>Update Available</h2>
            </div>
            <div class="version-modal-body">
                <p>A new version of VAPR desktop app is available. Update now for the latest features and improvements.</p>
                <div class="version-info">
                    <div class="version-item">
                        <span class="version-label">Your version:</span>
                        <span class="version-value outdated">v${versionInfo.current_version}</span>
                    </div>
                    <div class="version-item">
                        <span class="version-label">Latest version:</span>
                        <span class="version-value required">v${versionInfo.required_version}</span>
                    </div>
                </div>
                <p class="version-note">We recommend updating to ensure the best experience and compatibility.</p>
            </div>
            <div class="version-modal-actions">
                <button class="version-download-btn" onclick="downloadLatestDesktopVersion('${downloadUrl}')">
                    <i class="fa-solid fa-download"></i>
                    Download Latest Version
                </button>
                <button class="version-skip-btn" onclick="skipVersionUpdate('${versionInfo.required_version}')">
                    <i class="fa-solid fa-clock"></i>
                    Skip for now <span class="skip-warning">(not recommended, may cause bugs)</span>
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';
}

function skipVersionUpdate(skippedVersion) {
    const modal = DOM.get('version-update-modal');
    if (modal) {
        modal.remove();
        document.body.style.overflow = '';
    }

    isVersionCheckModalOpen = false;
}

function downloadLatestDesktopVersion(downloadUrl) {
    window.open(downloadUrl, '_blank');

    setTimeout(() => {
        notify.info(
            'Download Started',
            `<p>The download should begin shortly.</p>
            <p style="margin-top: 15px; font-size: 14px; color: rgba(255, 255, 255, 0.7);">
                After installing the new version, please restart VAPR to continue.
            </p>`,
            {
                confirmButtonText: 'OK',
                confirmButtonColor: '#4ecdc4'
            }
        );
    }, 500);
}

function initVersionCheck() {
    if (!isRunningInTauri()) return;

    setTimeout(() => {
        checkDesktopVersion();
    }, 3000);
}

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        initVersionCheck();
    });

    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'childList' && DOM.query('.menu-version span')) {
                observer.disconnect();
                checkDesktopVersion();
            }
        });
    });

    observer.observe(document.body, { childList: true, subtree: true });
}
