const cardManager = {
    currentCard: null,
    cards: new Map(),

    register(cardId, options = {}) {
        this.cards.set(cardId, {
            onShow: options.onShow || (() => {}),
            onHide: options.onHide || (() => {}),
            onLoad: options.onLoad || null,
            ...options
        });
    },

    async show(cardId) {
        const card = document.getElementById(cardId);
        if (!card) {
            console.error(`Card ${cardId} not found`);
            return;
        }

        if (window.hideMenu) hideMenu();

        if (this.currentCard && this.currentCard !== cardId) {
            await this.hideCard(this.currentCard, true);
        }

        const post = document.querySelector('.post');
        if (post) {
            post.style.display = 'none';
        }

        card.style.display = 'block';

        setTimeout(() => {
            card.classList.add('show');
        }, 10);

        this.currentCard = cardId;

        const config = this.cards.get(cardId) || {};
        if (config.onLoad) {
            this.showLoading(cardId);
            try {
                await config.onLoad();
            } catch (error) {
                console.error(`Error loading card ${cardId}:`, error);
            } finally {
                this.hideLoading(cardId);
            }
        }

        config.onShow();
    },

    hide(cardId) {
        return this.hideCard(cardId, false);
    },

    hideCard(cardId, skipPostRestore = false) {
        return new Promise((resolve) => {
            const card = document.getElementById(cardId);
            if (!card) {
                resolve();
                return;
            }

            const config = this.cards.get(cardId) || {};

            card.classList.remove('show');

            setTimeout(() => {
                card.style.display = 'none';

                if (!skipPostRestore) {
                    const post = document.querySelector('.post');
                    if (post) {
                        post.style.display = 'block';
                    }
                }

                config.onHide();

                if (this.currentCard === cardId) {
                    this.currentCard = null;
                }

                resolve();
            }, 800);
        });
    },

    showLoading(cardId) {
        const card = document.getElementById(cardId);

        if (cardId === 'analytics-card') {
            const loading = document.getElementById('analytics-loading');
            const content = document.querySelector('.analytics-body');
            if (loading) loading.style.display = 'block';
            if (content) content.style.opacity = '0.3';
        }
        else if (cardId === 'backgrounds-card') {
            const loading = document.getElementById('backgrounds-loading');
            const content = document.getElementById('backgroundsContent');
            if (loading) loading.style.display = 'block';
            if (content) content.style.opacity = '0.3';
        }
    },

    hideLoading(cardId) {
        const card = document.getElementById(cardId);

        if (cardId === 'analytics-card') {
            const loading = document.getElementById('analytics-loading');
            const content = document.querySelector('.analytics-body');
            if (loading) loading.style.display = 'none';
            if (content) content.style.opacity = '1';
        }
        else if (cardId === 'backgrounds-card') {
            const loading = document.getElementById('backgrounds-loading');
            const content = document.getElementById('backgroundsContent');
            if (loading) loading.style.display = 'none';
            if (content) content.style.opacity = '1';
        }
    },

    isShown(cardId) {
        return this.currentCard === cardId;
    },

    getCurrentCard() {
        return this.currentCard;
    }
};

window.cardManager = cardManager;
window.analytics = {};

function isOnMainePage(){
    if(document.getElementById("sign_in")){
        return true;
    }

    return false;
}

window.MainPage = isOnMainePage();
let analyticsData = {
    posts: [],
    fullData: null
};

cardManager.register('analytics-card', {
    onLoad: async () => {
        resetAnalyticsUI();
        await loadAnalyticsData();
    }
});

async function openAnalytics() {
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }

    await cardManager.show('analytics-card');
}

function closeAnalyticsCard() {
    cardManager.hide('analytics-card');
}

function resetAnalyticsUI() {
    const analyticsCard = document.getElementById('analytics-card');
    if (analyticsCard) {
        analyticsCard.querySelector('#total_views').textContent = "0";
        analyticsCard.querySelector('#total_likes').textContent = "0";
        analyticsCard.querySelector('#total_followers').textContent = "0";
        analyticsCard.querySelector('#total_clicks').textContent = "0";
    }
    document.getElementById("engagement_rate").textContent = "0%";
    document.getElementById("ctr_rate").textContent = "0%";
    document.getElementById("posts_list").innerHTML = '<div style="text-align: center; padding: 20px;">Loading posts...</div>';
}

async function loadAnalyticsData() {
    try {
        const fallbackData = await api.getMyPosts();
        console.log('Loaded posts data:', fallbackData);

        if (!fallbackData || fallbackData.length === 0) {
            document.getElementById("posts_list").innerHTML = '<div style="text-align: center; padding: 20px;">No posts found</div>';
            return;
        }

        analyticsData.posts = fallbackData;

       
        setTimeout(() => {
            calculateOverviewMetrics();
            populatePostsList();
            setupEventListeners();
        }, 100);
    } catch (error) {
        console.error("Error loading analytics data:", error);
        document.getElementById("posts_list").innerHTML = '<div style="text-align: center; padding: 20px; color: #e74c3c;">Failed to load analytics data</div>';
    }
}

function calculateOverviewMetrics() {
    const posts = analyticsData.posts;

    let totalViews = 0;
    let totalLikes = 0;
    let totalDislikes = 0;
    let totalFollows = 0;
    let totalClicks = 0;

    posts.forEach(post => {
        totalViews += post.viewsCount || 0;
        totalLikes += post.likesCount || 0;
        totalDislikes += post.dislikesCount || 0;
        totalFollows += post.followersCount || 0;
        totalClicks += post.linkClicksCount || 0;
    });

    console.log('Total views calculated:', totalViews);

   
    const analyticsCard = document.getElementById('analytics-card');
    if (!analyticsCard) {
        console.error('Analytics card not found!');
        return;
    }

    const elements = {
        views: analyticsCard.querySelector('#total_views'),
        likes: analyticsCard.querySelector('#total_likes'),
        followers: analyticsCard.querySelector('#total_followers'),
        clicks: analyticsCard.querySelector('#total_clicks')
    };

   
    if (elements.views) animateCounter(elements.views, 0, totalViews, 1000);
    if (elements.likes) animateCounter(elements.likes, 0, totalLikes, 1000);
    if (elements.followers) animateCounter(elements.followers, 0, totalFollows, 1000);
    if (elements.clicks) animateCounter(elements.clicks, 0, totalClicks, 1000);

    const totalEngagements = totalLikes + totalDislikes + totalFollows;
    const engagementRate = totalViews > 0 ? ((totalEngagements / totalViews) * 100).toFixed(2) : 0;

    setTimeout(() => {
        document.getElementById("engagement_rate").textContent = engagementRate + "%";
        document.getElementById("engagement_bar").style.width = Math.min(engagementRate, 100) + "%";
    }, 500);

    const ctr = totalViews > 0 ? ((totalClicks / totalViews) * 100).toFixed(2) : 0;

    setTimeout(() => {
        document.getElementById("ctr_rate").textContent = ctr + "%";
    }, 700);

    document.getElementById("reaction_pills").innerHTML = '<span style="font-size: 12px; color: rgba(255, 255, 255, 0.5);">No reactions data available</span>';
}

function animateCounter(element, start, end, duration) {
    if (!element) {
        console.error('Element not found for counter animation');
        return;
    }

    const startTime = performance.now();

    function updateCounter(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        const easeOutQuart = 1 - Math.pow(1 - progress, 4);

        const currentValue = Math.floor(start + (end - start) * easeOutQuart);

        element.textContent = formatNumber(currentValue);

        if (progress < 1) {
            requestAnimationFrame(updateCounter);
        }
    }

    requestAnimationFrame(updateCounter);
}

function populatePostsList(sortBy = 'views') {
    const container = document.getElementById("posts_list");
    container.innerHTML = '';

    const posts = analyticsData.posts;
    if (!posts || posts.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 20px;">No posts found</div>';
        return;
    }

    let sortedPosts = [...posts];
    switch(sortBy) {
        case 'views':
            sortedPosts.sort((a, b) => (b.viewsCount || 0) - (a.viewsCount || 0));
            break;
        case 'likes':
            sortedPosts.sort((a, b) => (b.likesCount || 0) - (a.likesCount || 0));
            break;
        case 'engagement':
            sortedPosts.sort((a, b) => {
                const engA = calculatePostEngagement(a);
                const engB = calculatePostEngagement(b);
                return parseFloat(engB) - parseFloat(engA);
            });
            break;
        case 'recent':
            sortedPosts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            break;
    }

    sortedPosts.forEach((post, index) => {
        const postItem = document.createElement('div');
        postItem.className = 'post-item';
        postItem.style.opacity = '0';
        postItem.style.transform = 'translateY(10px)';

        const engagement = calculatePostEngagement(post);

        postItem.innerHTML = `
            <div class="post-item-header">
                <h4 class="post-title">${escapeHtml(post.title)}</h4>
                <span class="post-engagement-badge">${engagement}%</span>
            </div>
            <div class="post-metrics">
                <div class="post-metric">
                    <span class="post-metric-value">${formatNumber(post.viewsCount || 0)}</span>
                    <span class="post-metric-label"><i class="fa-solid fa-eye"></i> Views</span>
                </div>
                <div class="post-metric">
                    <span class="post-metric-value">${formatNumber(post.likesCount || 0)}</span>
                    <span class="post-metric-label"><i class="fa-solid fa-heart"></i> Likes</span>
                </div>
                <div class="post-metric">
                    <span class="post-metric-value">${formatNumber(post.followersCount || 0)}</span>
                    <span class="post-metric-label"><i class="fa-solid fa-user-plus"></i> Follows</span>
                </div>
                <div class="post-metric">
                    <span class="post-metric-value">${formatNumber(post.linkClicksCount || 0)}</span>
                    <span class="post-metric-label"><i class="fa-solid fa-link"></i> Clicks</span>
                </div>
            </div>
            <div class="post-item-footer">
                <span class="post-date">${timeAgo(post.timestamp)}</span>
                <a href="/post/${post.id}" class="view-post-link" target="_blank">
                    View Post <i class="fa-solid fa-external-link-alt"></i>
                </a>
            </div>
        `;

        postItem.onclick = (e) => {
            if (!e.target.classList.contains('view-post-link') && !e.target.parentElement.classList.contains('view-post-link')) {
                window.open(`/post/${post.id}`, '_blank');
            }
        };

        container.appendChild(postItem);

        setTimeout(() => {
            postItem.style.transition = 'all 0.3s ease';
            postItem.style.opacity = '1';
            postItem.style.transform = 'translateY(0)';
        }, index * 50);
    });
}

function calculatePostEngagement(post) {
    const views = post.viewsCount || 0;
    if (views === 0) return 0;

    const likes = post.likesCount || 0;
    const dislikes = post.dislikesCount || 0;
    const follows = post.followersCount || 0;

    const engagements = likes + dislikes + follows;
    return ((engagements / views) * 100).toFixed(1);
}

function setupEventListeners() {
    const sortDropdown = document.getElementById('sort_posts');

    if (sortDropdown) {
        const newDropdown = sortDropdown.cloneNode(true);
        sortDropdown.parentNode.replaceChild(newDropdown, sortDropdown);

        newDropdown.addEventListener('change', (e) => {
            populatePostsList(e.target.value);
        });
    }
}

function formatNumber(num) {
    if (num < 1000) return num.toString();
    if (num < 1000000) return (num / 1000).toFixed(1) + 'K';
    if (num < 1000000000) return (num / 1000000).toFixed(1) + 'M';
    return (num / 1000000000).toFixed(1) + 'B';
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function timeAgo(dateParam) {
    if (!dateParam) return null;

    const date = typeof dateParam === 'object' ? dateParam : new Date(dateParam);
    const today = new Date();
    const seconds = Math.round((today - date) / 1000);
    const minutes = Math.round(seconds / 60);
    const hours = Math.round(minutes / 60);
    const days = Math.round(hours / 24);
    const months = Math.round(days / 30.4);
    const years = Math.round(days / 365);

    if (seconds < 60) {
        return `${seconds}s ago`;
    } else if (minutes < 60) {
        return `${minutes}m ago`;
    } else if (hours < 24) {
        return `${hours}h ago`;
    } else if (days < 30) {
        return `${days}d ago`;
    } else if (months < 12) {
        return `${months}mo ago`;
    } else {
        return `${years}y ago`;
    }
}

window.closeAnalytics = closeAnalyticsCard;
class API {
    constructor() {
        this.baseURL = '';
        this.defaultHeaders = {
            'Content-Type': 'application/json'
        };
    }

    clearAuth() {
        localStorage.removeItem('userData');
        window.user = null;
    }

    async request(path, options = {}) {
        const {
            method = 'GET',
            body = null,
            requireAuth = true,
            headers = {},
            isFormData = false
        } = options;

        const requestHeaders = {
            ...(!isFormData ? this.defaultHeaders : {}),
            ...headers
        };

        try {
            const response = await fetch(path, {
                method,
                headers: requestHeaders,
                body: isFormData ? body : (body ? JSON.stringify(body) : null),
                credentials: 'include'
            });

            if (!response.ok) {
                if (response.status === 401 && requireAuth) {
                    this.clearAuth();
                    window.location.href = '/login';
                    throw new Error('Unauthorized');
                }
                throw new Error(`Network response was not ok: ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            throw error;
        }
    }

    get(path, requireAuth = true) {
        return this.request(path, { requireAuth });
    }

    post(path, body, options = {}) {
        return this.request(path, {
            method: 'POST',
            body,
            ...options
        });
    }

    async getMe() {
        return this.get('/me');
    }

    async getFeed() {
        return this.get('/feed', false);
    }

    async getPost(id) {
        if (!/^[a-f0-9-]{36}$/.test(id)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/posts/${id}`, false);
    }

    async createPost(formData) {
        return this.request('/posts', {
            method: 'POST',
            body: formData,
            isFormData: true,
            requireAuth: true
        });
    }

    async likePost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/like/${postId}`);
    }

    async dislikePost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/dislike/${postId}`);
    }

    async skipPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/skip/${postId}`);
    }

    async followPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/manage-follow?action=follow&postId=${postId}`);
    }

    async unfollowPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/manage-follow?action=unfollow&postId=${postId}`);
    }

    async checkFollowStatus(creatorId) {
        const data = await this.get(`/check-follow/${creatorId}`);
        return data.isFollowing || false;
    }

    async addReaction(postId, emoji) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        const allowedEmojis = ['ðŸ’©', 'ðŸ‘€', 'ðŸ˜‚', 'â¤ï¸', 'ðŸ’¯', 'null'];
        if (!allowedEmojis.includes(emoji)) {
            throw new Error('Invalid emoji');
        }
        return this.get(`/add-reaction?postId=${postId}&emoji=${encodeURIComponent(emoji)}`);
    }

    async getReactions(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/get-reactions?postId=${postId}`, false);
    }

    async registerView(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/register-view?postId=${postId}`, false);
    }

    async clickLink(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/click-link?postId=${postId}`, false);
    }

    async getMyPosts() {
        return this.get('/me/posts');
    }

    async updateBackground(backgroundId) {
        if (!/^[a-zA-Z0-9_-]+$/.test(backgroundId)) {
            throw new Error('Invalid background ID format');
        }
        return this.get(`/me/update-background?backgroundId=${encodeURIComponent(backgroundId)}`);
    }

    async acceptInvitation(ambassadorUserId) {
        return this.get(`/accept-invitation?ambassadorUserId=${ambassadorUserId}`);
    }

    async getAnalytics(range = 7) {
        if (!['7', '30', 'all'].includes(String(range))) {
            range = 7;
        }
        return this.get(`/api/analytics?range=${range}`);
    }

    async getDailyXP() {
        return this.get('/api/xp-today');
    }

    async getUserCount() {
        const response = await fetch('/api/user-count', {
            credentials: 'include'
        });
        return response.json();
    }

    async getUser(userId) {
        return this.get(`/api/user/${userId}`, false);
    }
}

class APIHandler {
    static async handle(apiCall, options = {}) {
        const {
            onSuccess = () => {},
            onError = null,
            showLoading = false,
            successMessage = null,
            errorMessage = 'An error occurred',
            updateXP = false
        } = options;

        if (showLoading) showLoading();

        try {
            const data = await apiCall();

            if (updateXP && window.user && data.user) {
                const oldUser = {
                    xp: window.user.xp,
                    level: window.user.level,
                    xp_required: window.user.xp_required
                };
                window.user = data.user;
                setXPProgress(oldUser);
            }

            if (successMessage && typeof Swal !== 'undefined') {
                const Toast = Swal.mixin({
                    toast: true,
                    position: "top-end",
                    showConfirmButton: false,
                    timer: 3000,
                    timerProgressBar: true
                });
                Toast.fire({ icon: "success", title: successMessage });
            }

            await onSuccess(data);
            return data;

        } catch (error) {
            console.error(error);

            if (onError) {
                await onError(error);
            } else if (typeof Swal !== 'undefined') {
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: errorMessage
                });
            }

            throw error;
        } finally {
            if (showLoading) hideLoading();
        }
    }
}

const api = new API();
window.api = api;
window.APIHandler = APIHandler;

window.makeApiRequest = function(path, requireAuth = true) {
    return api.get(path, requireAuth);
};
function loadUserData(){
    if(MainPage){
        document.getElementById("sign_in").style.display = "none";
        document.getElementById("add_post").style.display = "none";
    }

    fetch('/me', {
        credentials: 'include'
    })
        .then(response => {
            if (!response.ok) {
                throw new Error('Not authenticated');
            }
            return response.json();
        })
        .then(data => {
            window.user = data;

            if(!MainPage){
                return;
            }

            updateUsername();
            updateLevel();

            const oldUser = {
                xp: 0,
                level: window.user.level,
                xp_required: window.user.xp_required
            };

            setXPProgress(oldUser, true);

            syncBackgroundFromBackend();

            document.getElementById("sign_in").style.display = "none";
            if(window.innerWidth <= 768){
                document.getElementById("add_post").style.display = "block";
            }

            document.getElementById("xp_bar").style.display = "block";

            loading_steps--;
            hideLoading();

            handleReferral();

            setTimeout(() => {
                migrateLocalBackgroundToBackend();
            }, 1000);

        }).catch( error => {
        document.getElementById("sign_in").style.display = "block";
        if(window.innerWidth <= 768){
            document.getElementById("add_post").style.display = "block";
        }
        document.getElementById("add_post").onclick = openRegisterModal;
        loading_steps--;
        hideLoading();
    });
}

function syncBackgroundFromBackend() {
    if (window.user && window.user.backgroundId) {
        const userBackground = background_images.find(bg => bg.id === window.user.backgroundId);

        if (userBackground) {
            equipBackground(userBackground.image_url, true);
            localStorage.setItem('background_url', userBackground.image_url);
            localStorage.setItem('background_id', userBackground.id);
            console.log('Background synchronized from backend:', userBackground.title);
        } else {
            console.log('User background ID not found in available backgrounds:', window.user.backgroundId);
            setDefaultBackground();
        }
    } else {
        const savedBackgroundUrl = localStorage.getItem('background_url');
        if (savedBackgroundUrl) {
            equipBackground(savedBackgroundUrl, false);
        } else {
            setDefaultBackground();
        }
    }
}

function setDefaultBackground() {
    if (background_images.length > 0) {
        const defaultBg = background_images[0];
        equipBackground(defaultBg.image_url, true);
        localStorage.setItem('background_url', defaultBg.image_url);
        localStorage.setItem('background_id', defaultBg.id);
    }
}
background_images = [
    {
        "id": "sunset_crush",
        "title": "Sunset Crush",
        "description": "Illustration from the music album Sunset Crush by Bip Bop Music",
        "image_url": "https://vapr-club.b-cdn.net/backgrounds/sunset_crush.png",
        "link": "https://www.youtube.com/watch?v=OU55Q9k7538&list=OLAK5uy_lSbP59KQr3hAI9h3DDdFI32BXO8AnpAJA",
        "link_text": "Listen on YouTube",
        "unlock": 0,
        "rarity": "common",
        "new": false
    },
    {
        "id": "pixel_mirage",
        "title": "Pixel Mirage",
        "description": "Illustration from the music album Pixel Mirage by Bip Bop Music",
        "image_url": "https://vapr-club.b-cdn.net/backgrounds/pixel_mirage.png",
        "link": "https://music.youtube.com/playlist?list=OLAK5uy_lD663FKcik2jpJwnZzkPLeQbaOgPqN75Y",
        "link_text": "Listen on YouTube Music",
        "unlock": 0,
        "rarity": "common",
        "new": false
    },
    {
        "id": "bip_bop_music",
        "title": "Bip Bop Music",
        "description": "Illustration from Bip Bop Music",
        "image_url": "https://vapr-club.b-cdn.net/backgrounds/bip_bop_music.png",
        "link": "https://www.youtube.com/@BipBopMusic",
        "link_text": "Subscribe on YouTube",
        "unlock": 2,
        "rarity": "rare",
        "new": false
    },
    {
        "id": "redline_bg",
        "title": "Redline Background",
        "description": "Illustration from The fortnite Game called Redline",
        "image_url": "https://vapr-club.b-cdn.net/backgrounds/redline_bg.webp",
        "link": "https://www.youtube.com/@StarkiteGames",
        "link_text": "Subscribe on YouTube",
        "unlock": 5,
        "rarity": "common",
        "new": true
    },
]
cardManager.register('backgrounds-card', {
    onShow: () => {
        displayBackgroundImages();
    }
});

function openCustomizationMenu() {
    if (!isUserLoggedIn() && MainPage) {
        openRegisterModal();
        return;
    }

    cardManager.show('backgrounds-card');
}

function closeBackgroundsCard() {
    cardManager.hide('backgrounds-card');
}

function closeCustomizationMenu() {
    closeBackgroundsCard();
}

function displayBackgroundImages() {
    if (!isUserLoggedIn() && MainPage) {
        openRegisterModal();
        return;
    }

    const container = document.getElementById("backgrounds-grid");
    container.innerHTML = '';

    const currentBackground = localStorage.getItem('background_url');

    background_images.forEach((bg, index) => {
        const isUnlocked = user.level >= bg.unlock;
        const isEquipped = currentBackground === bg.image_url;
        const progress = Math.min((user.level / bg.unlock) * 100, 100);

        const card = document.createElement('div');
        card.className = `background-item ${!isUnlocked ? 'locked' : ''} ${isEquipped ? 'equipped' : ''}`;

        let rarityClass = `rarity-${bg.rarity}`;
        let rarityText = bg.rarity.charAt(0).toUpperCase() + bg.rarity.slice(1);

        card.innerHTML = `
            <div class="rarity-badge ${rarityClass}">${rarityText}</div>
            ${bg.new && isUnlocked ? '<div class="new-badge">NEW</div>' : ''}
            
            <img src="${bg.image_url}" class="background-preview" alt="${bg.title}" loading="lazy">
            
            <div class="background-info">
                <h4 class="background-title">${bg.title}</h4>
                <p class="background-description">${bg.description}</p>
                ${bg.link ? `
                    <a href="${bg.link}" target="_blank" class="background-link" onclick="event.stopPropagation()">
                        <i class="fa-solid fa-external-link-alt"></i>
                        ${bg.link_text || 'View Source'}
                    </a>
                ` : ''}
            </div>
            
            ${!isUnlocked ? `
                <div class="lock-overlay">
                    <i class="fa-solid fa-lock lock-icon"></i>
                    <div class="unlock-text">Unlock at Level ${bg.unlock}</div>
                    <div class="unlock-progress">
                        <div class="unlock-progress-fill" style="width: ${progress}%"></div>
                    </div>
                </div>
            ` : ''}
        `;

        if (isUnlocked && !isEquipped) {
            card.onclick = () => {
                card.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    card.style.transform = '';
                }, 100);

                updateBackgroundId(bg.id);
                equipBackground(bg.image_url);

                if (typeof confetti !== 'undefined') {
                    confetti({
                        particleCount: 50,
                        spread: 50,
                        origin: { y: 0.6 },
                        colors: ['#4ecdc4', '#44a3aa', '#3d9a92']
                    });
                }

                displayBackgroundImages();
            };
        }

        container.appendChild(card);
    });
}

function equipBackground(url, save = true) {
    if(!MainPage){
        return;
    }

    document.body.style.backgroundImage = 'url(' + url + ')';

    if (save) {
        localStorage.setItem('background_url', url);

        const bgData = background_images.find(bg => bg.image_url === url);
        if (bgData) {
            localStorage.setItem('background_id', bgData.id);
        }
    }
}

function updateBackgroundId(newBackgroundId) {
    if (!isUserLoggedIn()) {
        alert('You must be logged in to update your background.');
        return;
    }

    if (!navigator.onLine) {
        localStorage.setItem('pending_background_id', newBackgroundId);

        const bg = background_images.find(b => b.id === newBackgroundId);
        if (bg) {
            equipBackground(bg.image_url, true);
        }

        if (typeof Swal !== 'undefined') {
            Swal.fire({
                icon: 'info',
                title: 'Offline Mode',
                text: 'Background will be synced when you\'re back online'
            });
        }
        return;
    }

    api.updateBackground(newBackgroundId)
        .then(response => {
            console.log('Background updated successfully:', response);

            if (window.user) {
                window.user.backgroundId = newBackgroundId;
            }

            if (typeof Swal !== 'undefined') {
                const Toast = Swal.mixin({
                    toast: true,
                    position: "top-end",
                    showConfirmButton: false,
                    timer: 3000,
                    timerProgressBar: true
                });

                Toast.fire({
                    icon: "success",
                    title: "Background equipped!"
                });
            }
        })
        .catch(error => {
            console.error('Failed to update background:', error);
            alert('Failed to update background. Please try again.');
        });
}

async function migrateLocalBackgroundToBackend() {
    if (!isUserLoggedIn()) return;

    if (!window.user.backgroundId) {
        const localBackgroundId = localStorage.getItem('background_id');
        const localBackgroundUrl = localStorage.getItem('background_url');

        if (localBackgroundId) {
            try {
                await api.updateBackground(localBackgroundId);
                console.log('Migrated local background to backend');
            } catch (error) {
                console.error('Failed to migrate background:', error);
            }
        } else if (localBackgroundUrl) {
            const bgData = background_images.find(bg => bg.image_url === localBackgroundUrl);
            if (bgData) {
                try {
                    await api.updateBackground(bgData.id);
                    localStorage.setItem('background_id', bgData.id);
                    console.log('Migrated local background URL to backend');
                } catch (error) {
                    console.error('Failed to migrate background:', error);
                }
            }
        }
    }
}

window.addEventListener('online', async () => {
    if (isUserLoggedIn()) {
        const pendingBackgroundId = localStorage.getItem('pending_background_id');
        if (pendingBackgroundId) {
            try {
                await api.updateBackground(pendingBackgroundId);
                localStorage.removeItem('pending_background_id');
                console.log('Synced pending background change');
            } catch (error) {
                console.error('Failed to sync pending background:', error);
            }
        }
    }
});
let gamesData = {
    allGames: [],
    userGames: [],
    currentManagingGame: null,
    installedGames: [],
    downloadingGames: new Map()
};

cardManager.register('games-card', {
    onLoad: async () => {
        await loadGamesData();
    }
});

cardManager.register('library-card', {
    onLoad: async () => {
        await loadLibraryData();
    }
});

cardManager.register('game-management-card', {
    onLoad: async () => {
        if (gamesData.currentManagingGame) {
            await loadGameKeys(gamesData.currentManagingGame.id);
        }
    }
});

async function openGamesShowcase() {
    await cardManager.show('games-card');
}

async function openMyLibrary() {
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }
    await cardManager.show('library-card');
}

function closeGamesCard() {
    cardManager.hide('games-card');
}

function closeLibraryCard() {
    cardManager.hide('library-card');
}

function closeGameManagementCard() {
    cardManager.hide('game-management-card');
}

async function loadGamesData() {
    try {
        document.getElementById('games-loading').style.display = 'block';

        const [gamesResponse, userGamesResponse] = await Promise.all([
            api.request('/api/games'),
            isUserLoggedIn() ? api.request('/api/my-games') : Promise.resolve({ games: [] })
        ]);

        gamesData.allGames = gamesResponse.games || [];
        gamesData.userGames = userGamesResponse.games || [];

        if (isRunningInTauri()) {
            try {
                const installedGames = await window.__TAURI__.core.invoke('get_installed_games');
                gamesData.installedGames = installedGames || [];
            } catch (error) {
                console.error('Error loading installed games:', error);
                gamesData.installedGames = [];
            }
        }

        displayGames();
    } catch (error) {
        console.error('Error loading games:', error);
    } finally {
        document.getElementById('games-loading').style.display = 'none';
    }
}

async function loadLibraryData() {
    try {
        document.getElementById('library-loading').style.display = 'block';

        const response = await api.request('/api/my-games');
        gamesData.userGames = response.games || [];

        if (isRunningInTauri()) {
            try {
                const installedGames = await window.__TAURI__.core.invoke('get_installed_games');
                gamesData.installedGames = installedGames || [];
            } catch (error) {
                console.error('Error loading installed games:', error);
                gamesData.installedGames = [];
            }
        }

        displayLibrary();
    } catch (error) {
        console.error('Error loading library:', error);
    } finally {
        document.getElementById('library-loading').style.display = 'none';
    }
}

function displayGames() {
    const container = document.getElementById('games-grid');
    container.innerHTML = '';

    const userGameIds = gamesData.userGames.map(g => g.id);

    gamesData.allGames.forEach(game => {
        const isOwned = userGameIds.includes(game.id);
        const isOwner = isUserLoggedIn() && game.ownerId === window.user.id;

        const gameEl = document.createElement('div');
        gameEl.className = 'game-item';

        const manageButton = isOwner ? `<button class="manage-button" onclick="window.openGameManagement(event, '${game.id}')"><i class="fa-solid fa-key"></i> Manage</button>` : '';

        gameEl.innerHTML = `
            ${isOwned ? '<div class="owned-badge">OWNED</div>' : ''}
            ${manageButton}
            <div class="game-cover-wrapper">
                <img src="${game.coverImage}" class="game-cover" alt="${game.title}">
            </div>
            <div class="game-info">
                <h4 class="game-title">${game.title}</h4>
                <p class="game-description">${game.description}</p>
                ${game.externalLink ? `<a href="${game.externalLink}" target="_blank" class="game-link" onclick="event.stopPropagation()"><i class="fa-solid fa-external-link"></i> Learn More</a>` : ''}
            </div>
        `;

        if (!isOwner) {
            gameEl.onclick = () => {
                if (game.externalLink) {
                    window.open(game.externalLink, '_blank');
                }
            };
        }

        container.appendChild(gameEl);
    });
}

function displayLibrary() {
    const container = document.getElementById('library-grid');
    container.innerHTML = '';

    if (gamesData.userGames.length === 0) {
        container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: rgba(255, 255, 255, 0.6);">No games in your library yet. Redeem a key to get started!</div>';
        return;
    }

    gamesData.userGames.forEach(game => {
        const gameEl = document.createElement('div');
        gameEl.className = 'game-item';
        gameEl.id = `game-item-${game.id}`;

        const isTauri = isRunningInTauri();
        const isInstalled = gamesData.installedGames.some(g => g.id === game.id);
        const isDownloading = gamesData.downloadingGames.has(game.id);

        let actionContent = '';
        if (game.downloadUrl) {
            if (isTauri) {
                if (isDownloading) {
                    const progress = gamesData.downloadingGames.get(game.id) || 0;
                    actionContent = `
                        <div class="download-progress-overlay">
                            <div class="download-progress-info">
                                <span class="download-status">Downloading...</span>
                                <span class="download-percentage">${Math.round(progress)}%</span>
                            </div>
                            <div class="download-progress-bar">
                                <div class="download-progress-fill" style="width: ${progress}%"></div>
                            </div>
                            <button class="cancel-download-btn" onclick="window.cancelDownload('${game.id}')">
                                <i class="fa-solid fa-xmark"></i>
                            </button>
                        </div>
                    `;
                } else if (isInstalled) {
                    const installedGame = gamesData.installedGames.find(g => g.id === game.id);
                    if (installedGame && installedGame.executable) {
                        actionContent = `
                            <div class="game-actions">
                                <button class="download-button play-button" onclick="window.launchGame(event, '${installedGame.executable.replace(/\\/g, '\\\\')}')">
                                    <i class="fa-solid fa-play"></i> Play
                                </button>
                                <button class="uninstall-button" onclick="window.uninstallGame(event, '${game.id}', '${game.title.replace(/'/g, "\\'")}')">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                            </div>
                        `;
                    }
                } else {
                    actionContent = `<button class="download-button" onclick="window.downloadGame(event, '${game.id}', '${game.title.replace(/'/g, "\\'")}', '${game.downloadUrl}')"><i class="fa-solid fa-download"></i> Install</button>`;
                }
            } else {
                actionContent = `<button class="download-button" onclick="window.downloadGame(event, '${game.id}', '${game.title.replace(/'/g, "\\'")}', '${game.downloadUrl}')"><i class="fa-solid fa-download"></i> Download</button>`;
            }
        }

        gameEl.innerHTML = `
            ${actionContent}
            <div class="game-cover-wrapper">
                <img src="${game.coverImage}" class="game-cover" alt="${game.title}">
            </div>
            <div class="game-info">
                <h4 class="game-title">${game.title}</h4>
                <p class="game-description">${game.description}</p>
                <div style="font-size: 11px; color: rgba(255, 255, 255, 0.5); margin-top: 5px;">
                    Owned since ${new Date(game.ownedAt).toLocaleDateString()}
                    ${isInstalled ? ' â€¢ <i class="fa-solid fa-check-circle"></i> Installed' : ''}
                </div>
            </div>
        `;

        container.appendChild(gameEl);
    });
}

function openRedeemModal() {
    document.getElementById('redeem-modal').style.display = 'flex';
    document.getElementById('game-key-input').value = '';
    document.getElementById('game-key-input').focus();
}

function closeRedeemModal() {
    document.getElementById('redeem-modal').style.display = 'none';
}

async function redeemKey(event) {
    event.preventDefault();

    const keyInput = document.getElementById('game-key-input');
    const key = keyInput.value.trim();

    try {
        const response = await api.request('/api/games/redeem-key', {
            method: 'POST',
            body: { key }
        });

        if (response.success) {
            closeRedeemModal();

            if (typeof Swal !== 'undefined') {
                Swal.fire({
                    icon: 'success',
                    title: 'Success!',
                    text: `You now own ${response.game.title}!`,
                    confirmButtonText: 'View Library'
                }).then((result) => {
                    if (result.isConfirmed) {
                        closeGamesCard();
                        openMyLibrary();
                    }
                });
            }

            await loadLibraryData();
        }
    } catch (error) {
        if (typeof Swal !== 'undefined') {
            Swal.fire({
                icon: 'error',
                title: 'Invalid Key',
                text: error.message || 'The key you entered is invalid or has already been used.'
            });
        }
    }
}

window.openGameManagement = async function(event, gameId) {
    event.stopPropagation();

    const game = gamesData.allGames.find(g => g.id === gameId);
    if (!game) return;

    gamesData.currentManagingGame = game;
    document.getElementById('management-game-name').textContent = game.title;

    await cardManager.show('game-management-card');
}

async function loadGameKeys(gameId) {
    try {
        const response = await api.request(`/api/games/${gameId}/keys`);

        if (response.success) {
            displayKeys(response.keys);
        }
    } catch (error) {
        console.error('Error loading keys:', error);
    }
}

function displayKeys(keys) {
    const container = document.getElementById('keys-list');
    container.innerHTML = '';

    if (keys.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 20px; color: rgba(255, 255, 255, 0.6);">No keys generated yet</div>';
        return;
    }

    keys.forEach(key => {
        const keyEl = document.createElement('div');
        keyEl.className = 'key-item';
        keyEl.innerHTML = `
            <span class="key-code">${key.key}</span>
            <span class="key-status ${key.usedBy ? 'used' : 'available'}">${key.usedBy ? 'Used' : 'Available'}</span>
            ${!key.usedBy ? `<button class="copy-key-btn" onclick="copyKey('${key.key}')"><i class="fa-solid fa-copy"></i> Copy</button>` : ''}
        `;
        container.appendChild(keyEl);
    });
}

async function generateKeys() {
    if (!gamesData.currentManagingGame) return;

    try {
        const response = await api.request(`/api/games/${gamesData.currentManagingGame.id}/generate-keys`, {
            method: 'POST',
            body: { count: 5 }
        });

        if (response.success) {
            if (typeof Swal !== 'undefined') {
                const Toast = Swal.mixin({
                    toast: true,
                    position: "top-end",
                    showConfirmButton: false,
                    timer: 3000,
                    timerProgressBar: true
                });
                Toast.fire({
                    icon: "success",
                    title: "5 keys generated successfully!"
                });
            }

            await loadGameKeys(gamesData.currentManagingGame.id);
        }
    } catch (error) {
        console.error('Error generating keys:', error);
    }
}

function copyKey(key) {
    navigator.clipboard.writeText(key).then(() => {
        if (typeof Swal !== 'undefined') {
            const Toast = Swal.mixin({
                toast: true,
                position: "top-end",
                showConfirmButton: false,
                timer: 2000,
                timerProgressBar: true
            });
            Toast.fire({
                icon: "success",
                title: "Key copied to clipboard!"
            });
        }
    });
}

window.downloadGame = async function(event, gameId, gameTitle, downloadUrl) {
    event.stopPropagation();

    if (!isRunningInTauri()) {
        Swal.fire({
            title: 'Desktop App Required',
            html: `
                <p>To download and play games, you need the VAPR desktop app.</p>
                <p style="margin-top: 20px; font-size: 14px; color: rgba(255, 255, 255, 0.7);">
                    The desktop app allows you to:
                </p>
                <ul style="text-align: left; margin: 10px 0; font-size: 14px; color: rgba(255, 255, 255, 0.7);">
                    <li>Download and install games directly</li>
                    <li>Launch games with one click</li>
                    <li>Track your playtime</li>
                    <li>Get automatic updates</li>
                </ul>
            `,
            icon: 'info',
            showCancelButton: true,
            confirmButtonText: '<i class="fa-solid fa-download"></i> Download Desktop App',
            cancelButtonText: 'Maybe Later',
            confirmButtonColor: '#4ecdc4',
            customClass: {
                container: 'download-prompt-container'
            }
        }).then((result) => {
            if (result.isConfirmed) {
                downloadDesktopApp();
            }
        });
        return;
    }

    gamesData.downloadingGames.set(gameId, 0);
    displayLibrary();

    try {
        const unlisten = await window.__TAURI__.event.listen('download-progress', (event) => {
            const progress = event.payload;
            if (progress.game_id === gameId) {
                gamesData.downloadingGames.set(gameId, progress.percentage);
                updateGameDownloadProgress(gameId, progress);
            }
        });

        const statusUnlisten = await window.__TAURI__.event.listen('download-status', (event) => {
            const data = event.payload;
            if (data.game_id === gameId) {
                updateGameDownloadStatus(gameId, data.status);
            }
        });

        const result = await window.__TAURI__.core.invoke('download_and_install_game', {
            gameId: gameId,
            gameName: gameTitle,
            downloadUrl: downloadUrl
        });

        unlisten();
        statusUnlisten();

        if (result.success) {
            gamesData.downloadingGames.delete(gameId);

            const Toast = Swal.mixin({
                toast: true,
                position: "top-end",
                showConfirmButton: false,
                timer: 3000,
                timerProgressBar: true
            });
            Toast.fire({
                icon: "success",
                title: `${gameTitle} installed successfully!`
            });

            await loadLibraryData();
        } else {
            throw new Error(result.error || 'Installation failed');
        }
    } catch (error) {
        console.error('Error downloading game:', error);
        gamesData.downloadingGames.delete(gameId);
        displayLibrary();

        Swal.fire({
            icon: 'error',
            title: 'Download Failed',
            text: error.message || 'Failed to download the game. Please try again.'
        });
    }
}

function updateGameDownloadProgress(gameId, progress) {
    const gameEl = document.getElementById(`game-item-${gameId}`);
    if (!gameEl) return;

    const progressFill = gameEl.querySelector('.download-progress-fill');
    const percentage = gameEl.querySelector('.download-percentage');
    const status = gameEl.querySelector('.download-status');

    if (progressFill) progressFill.style.width = `${progress.percentage}%`;
    if (percentage) percentage.textContent = `${Math.round(progress.percentage)}%`;
    if (status) status.textContent = `Downloading... ${progress.speed.toFixed(2)} MB/s`;
}

function updateGameDownloadStatus(gameId, statusText) {
    const gameEl = document.getElementById(`game-item-${gameId}`);
    if (!gameEl) return;

    const status = gameEl.querySelector('.download-status');
    if (status) status.textContent = statusText;
}

window.cancelDownload = function(gameId) {
    gamesData.downloadingGames.delete(gameId);
    displayLibrary();
}

window.uninstallGame = async function(event, gameId, gameTitle) {
    event.stopPropagation();

    const result = await Swal.fire({
        title: 'Uninstall Game?',
        html: `<p>Are you sure you want to uninstall <strong>${gameTitle}</strong>?</p>
               <p style="font-size: 14px; color: rgba(255, 255, 255, 0.7); margin-top: 10px;">This will remove all game files from your computer.</p>`,
        icon: 'warning',
        showCancelButton: true,
        confirmButtonText: 'Yes, uninstall',
        cancelButtonText: 'Cancel',
        confirmButtonColor: '#e74c3c'
    });

    if (result.isConfirmed) {
        try {
            await window.__TAURI__.core.invoke('uninstall_game', { gameId });

            const Toast = Swal.mixin({
                toast: true,
                position: "top-end",
                showConfirmButton: false,
                timer: 3000,
                timerProgressBar: true
            });
            Toast.fire({
                icon: "success",
                title: `${gameTitle} uninstalled successfully`
            });

            await loadLibraryData();
        } catch (error) {
            console.error('Error uninstalling game:', error);
            Swal.fire({
                icon: 'error',
                title: 'Uninstall Failed',
                text: error.message || 'Failed to uninstall the game. Please try again.'
            });
        }
    }
}

window.launchGame = async function(event, executablePath) {
    event.stopPropagation();

    if (!isRunningInTauri()) return;

    const button = event.target.closest('button');
    const originalContent = button.innerHTML;
    button.disabled = true;
    button.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Launching...';

    try {
        await window.__TAURI__.core.invoke('launch_game', {
            executablePath: executablePath
        });

        const Toast = Swal.mixin({
            toast: true,
            position: "top-end",
            showConfirmButton: false,
            timer: 3000,
            timerProgressBar: true
        });
        Toast.fire({
            icon: "success",
            title: "Game launched!"
        });
    } catch (error) {
        console.error('Error launching game:', error);
        Swal.fire({
            icon: 'error',
            title: 'Launch Failed',
            text: error.message || 'Failed to launch the game. Please try again.'
        });
    } finally {
        button.disabled = false;
        button.innerHTML = originalContent;
    }
}

function formatTime(seconds) {
    if (seconds === 0) return 'Calculating...';

    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
        return `${hours}h ${minutes}m remaining`;
    } else if (minutes > 0) {
        return `${minutes}m ${secs}s remaining`;
    } else {
        return `${secs}s remaining`;
    }
}

function isRunningInTauri() {
    return typeof window.__TAURI__ !== 'undefined';
}

window.openGamesShowcase = openGamesShowcase;
window.openMyLibrary = openMyLibrary;
window.closeGamesCard = closeGamesCard;
window.closeLibraryCard = closeLibraryCard;
window.closeGameManagementCard = closeGameManagementCard;
window.openRedeemModal = openRedeemModal;
window.closeRedeemModal = closeRedeemModal;
window.redeemKey = redeemKey;
window.generateKeys = generateKeys;
window.copyKey = copyKey;
async function updateGithubStars(element) {
    try {
        const response = await fetch('https://api.github.com/repos/Vic92548/VAPR');
        if (!response.ok) throw new Error('GitHub API error');

        const data = await response.json();
        const stars = data.stargazers_count;

        element.textContent = `${stars} â­`;
    } catch (error) {
        console.error('Failed to fetch GitHub stars:', error);
        element.textContent = 'â­ï¸ N/A';
    }
}

if(MainPage){
    updateGithubStars(document.getElementById('github_stars'));
}
function makeImageBig(img) {
    img.classList.remove("normal_image");
    img.classList.add("big_image");
    window.analytics.track('image_zoom_out', { post: current_post });
}

function makeImageNormal(img) {
    img.classList.remove("big_image");
    img.classList.add("normal_image");
    window.analytics.track('image_zoom_in', { post: current_post });
}

function switchImage(img) {
    if(img.classList.contains("big_image")){
        makeImageNormal(img);
    }else{
        makeImageBig(img);
    }
}
function initPlayerPreferences() {
    if (!window.user) {
        const backgroundUrl = localStorage.getItem('background_url');

        if(backgroundUrl){
            equipBackground(backgroundUrl, false);
        }
    }
}

initPlayerPreferences();
let feed_posts = [];
let loading_steps = 2;
let post_seen = 0;
let creators = {};

function showInitialPost() {
    const path = window.location.pathname.split('/');

    if(path.length < 3){
        displayPost();
    }else if(path[1] === "post"){
        displayPost(path[2]);
    }
}

function isUserLoggedIn(){
    if(window.user){
        return true;
    }else{
        return false;
    }
}

function updateUsername() {
    const level_elements = document.getElementsByClassName("username");
    for (let i = 0; i < level_elements.length; i++) {
        level_elements[i].textContent = user.username;
        console.log("updated username : " + user.username);
    }
}

loadUserData();

function hideLoading(){
    console.log("steps:"+loading_steps);
}

function showLoading(){
}

function timeAgo(dateParam) {
    if (!dateParam) {
        return null;
    }

    const date = typeof dateParam === 'object' ? dateParam : new Date(dateParam);
    const today = new Date();
    const seconds = Math.round((today - date) / 1000);
    const minutes = Math.round(seconds / 60);
    const hours = Math.round(minutes / 60);
    const days = Math.round(hours / 24);
    const months = Math.round(days / 30.4);
    const years = Math.round(days / 365);

    if (seconds < 60) {
        return `${seconds} seconds ago`;
    } else if (minutes < 60) {
        return `${minutes} minutes ago`;
    } else if (hours < 24) {
        return `${hours} hours ago`;
    } else if (days < 30) {
        return `${days} days ago`;
    } else if (months < 12) {
        return `${months} months ago`;
    } else {
        return `${years} years ago`;
    }
}

function setupSocialLink(id, link){
    const link_bt = document.getElementById(id);
    link_bt.style.display = "inline-block";
    link_bt.href = link;
}

let current_post_id = undefined;
let current_post = undefined;

function hidePost() {
    showLoading();
    document.getElementById("post_video").children[0].src = "";
    document.getElementsByClassName("post")[0].style.transform = "translateY(100vh)";
}

cardManager.register('add-post-card', {
    onShow: () => {
        setTimeout(() => {
            const titleInput = document.getElementById('title');
            if (titleInput) titleInput.focus();
        }, 500);
    }
});

function opeNewPostModel() {
    if (isUserLoggedIn()) {
        cardManager.show('add-post-card');
    } else {
        openRegisterModal();
    }
}

function closeAddPostCard() {
    cardManager.hide('add-post-card');
}

function closeNewPostModel() {
    closeAddPostCard();
}

function openRegisterModal() {
    document.getElementById("register").style.display = "flex";
}

function openUserAccountModel() {
    document.getElementById("account").style.display = "flex";

    APIHandler.handle(
        () => api.getMyPosts(),
        {
            onSuccess: (data) => {
                console.log("Coucou");
                console.log(data);

                const old_posts = document.getElementById("old-posts");
                old_posts.innerHTML = "";

                for (let i = 0; i < data.length; i++) {
                    old_posts.innerHTML += '<div class="post-card">\n' +
                        '                    <h4>' + data[i].title + '</h4>\n' +
                        '                    <div style="display: flex; justify-content: space-between">\n' +
                        '                        <span><i class="fa-solid fa-eye"></i> <span>loading...</span></span>\n' +
                        '                        <span><i class="fa-solid fa-heart"></i> <span>loading...</span></span>\n' +
                        '                        <span><i class="fa-solid fa-heart-crack"></i> <span>loading...</span></span>\n' +
                        '                        <span><i class="fa-solid fa-forward"></i> <span>loading...</span></span>\n' +
                        '                    </div>\n' +
                        '                </div>'
                }
            },
            onError: () => {
                const old_posts = document.getElementById("old-posts");
                old_posts.innerHTML = "<p>You don't have created any posts yet, what are you waiting for? :)</p>";
            }
        }
    );
}

async function updateFollowButton() {
    const follow_bt = document.getElementById("follow");

    if(isUserLoggedIn()){
        let following;

        console.log("CURRENT POST");
        console.log(current_post);

        if(creators[current_post.userId]){
            following = creators[current_post.userId].following;
        }else{
            creators[current_post.userId] = {
                following: false
            }
        }

        if(following === undefined){
            following = await checkUserFollowsCreator(current_post.userId);
            creators[current_post.userId].following = following;
        }

        follow_bt.style.opacity = "0";
        follow_bt.style.display = "inline-block";

        if(following){
            follow_bt.innerHTML = '<i class="fa-solid fa-user-minus"></i>';
            follow_bt.onclick = unfollowPost;
            follow_bt.style.border = "1px solid rgb(206 220 247 / 42%)";
            follow_bt.style.backgroundColor = "rgb(190 213 255 / 40%)";
        }else{
            follow_bt.innerHTML = '<i class="fa-solid fa-user-plus"></i>';
            follow_bt.onclick = followPost;
            follow_bt.style.border = "1px solid rgb(77 137 245)";
            follow_bt.style.backgroundColor = "rgb(95 148 243)";
        }

        follow_bt.style.opacity = "1";

        if(current_post.userId === user.id){
            follow_bt.style.opacity = "0";
            follow_bt.style.display = "none";
        }
    }else{
        follow_bt.onclick = openRegisterModal;
    }
}

function followPost() {
    creators[current_post.userId].following = true;
    updateFollowButton();
    if(isUserLoggedIn()){
        APIHandler.handle(
            () => api.followPost(current_post.id),
            {
                errorMessage: 'Error when trying to follow. Please try again.'
            }
        );
    }else{
        openRegisterModal();
    }
}

function unfollowPost() {
    creators[current_post.userId].following = false;
    updateFollowButton();
    if(isUserLoggedIn()){
        APIHandler.handle(
            () => api.unfollowPost(current_post.id)
        );
    }else{
        openRegisterModal();
    }
}

async function checkUserFollowsCreator(creatorId) {
    try {
        const isFollowing = await api.checkFollowStatus(creatorId);
        console.log('Check follow status:', isFollowing);
        return isFollowing;
    } catch (error) {
        console.error('Error checking follow status:', error);
        return false;
    }
}

function formatViews(viewCount) {
    if (viewCount < 1000) {
        return viewCount;
    } else if (viewCount < 1000000) {
        return (viewCount / 1000).toFixed(2) + 'K';
    } else if (viewCount < 1000000000) {
        return (viewCount / 1000000).toFixed(2) + 'M';
    } else {
        return (viewCount / 1000000000).toFixed(2) + 'B';
    }
}

function openMenu() {
    document.getElementById("menu").style.display = 'flex';
}

function hideMenu() {
    if(window.innerWidth <= 768){
        document.getElementById("menu").style.display = 'none';
    }
}

if(MainPage){
    if(window.innerWidth >= 768){
        document.getElementById("menu").style.display = 'flex';
    }
}

function processJoinQueryParam() {
    const url = new URL(window.location.href);
    const params = url.searchParams;

    if (params.has('join')) {
        const joinValue = params.get('join');
        console.log("Join param found with value = " + joinValue);
        localStorage.setItem('referrerId', joinValue);
        params.delete('join');
        window.history.replaceState({}, '', url.toString());
    }
}

function handleReferral() {
    const referrerId = localStorage.getItem('referrerId');

    if (referrerId) {
        APIHandler.handle(
            () => api.acceptInvitation(referrerId),
            {
                onSuccess: (data) => {
                    console.log('Invitation processed:', data);
                    if(creators[referrerId]){
                        creators[referrerId].following = true;
                        updateFollowButton();
                    }
                    localStorage.removeItem('referrerId');
                },
                onError: (error) => {
                    localStorage.removeItem('referrerId');
                }
            }
        );
    }
}

function openTextModal(text) {
    document.getElementById("text_modal_text").textContent = text;
    document.getElementById("text_modal").style.display = 'block';
}

function closeTextModal() {
    document.getElementById("text_modal").style.display = 'none';
}

function copyReferrerId() {
    if(isUserLoggedIn()){
        const referralUrl = `https://vapr.club?join=${user.id}`;
        const textArea = document.createElement('textarea');
        textArea.value = referralUrl;
        textArea.style.position = 'absolute';
        textArea.style.left = '-9999px';
        document.body.appendChild(textArea);
        textArea.select();
        textArea.setSelectionRange(0, 99999);

        try {
            const successful = document.execCommand('copy');
            console.log(successful ? 'Referral URL copied to clipboard!' : 'Failed to copy the URL');
            Swal.fire({
                title: "Invitation copied to clipboard!",
                text: "Your invitation link (" + referralUrl + "), has been copied to clipboard!",
                icon: "success"
            });
        } catch (err) {
            console.error('Error copying to clipboard: ', err);
            Swal.fire({
                title: "Failed to copy to clipboard!",
                text: "Your invitation link (" + referralUrl + "), has failed to copy to clipboard!",
                icon: "error"
            });
        }

        document.body.removeChild(textArea);
    }else{
        openRegisterModal();
    }
}

processJoinQueryParam();

if(MainPage){
    showInitialPost();
}
function initMenu() {
    if (!MainPage) return;

    if (isUserLoggedIn()) {
        updateMenuUserInfo();
        showMenuUserElements();
        updateQuickStats();
    }

    updateOnlineUsers();

    addMenuAnimations();

    if (document.getElementById('github_stars')) {
        updateGithubStars(document.getElementById('github_stars'));
    }

    if (window.innerWidth >= 769) {
        initMenuCollapseState();
        addCollapsedMenuInteractions();
    }

    initDesktopDownloadButton();
}

function toggleMenuCollapse() {
    const menuContainer = document.querySelector('.menu-container');
    const mainElement = document.querySelector('main');
    const toggleButton = document.querySelector('.menu-toggle i');

    if (!menuContainer) return;

    menuContainer.classList.toggle('collapsed');

    if (mainElement) {
        mainElement.classList.toggle('menu-collapsed');
    }

    const isCollapsed = menuContainer.classList.contains('collapsed');
    localStorage.setItem('menuCollapsed', isCollapsed);

    updateMenuTooltips(isCollapsed);

    if (toggleButton) {
        toggleButton.style.transform = isCollapsed ? 'rotate(180deg)' : 'rotate(0deg)';
    }
}

function updateMenuTooltips(isCollapsed) {
    const menuItems = document.querySelectorAll('.menu-item');

    menuItems.forEach(item => {
        if (isCollapsed) {
            const title = item.querySelector('.menu-item-title');
            if (title) {
                item.setAttribute('data-tooltip', title.textContent);
            }
        } else {
            item.removeAttribute('data-tooltip');
        }
    });
}

function initMenuCollapseState() {
    const savedState = localStorage.getItem('menuCollapsed');
    const menuContainer = document.querySelector('.menu-container');
    const mainElement = document.querySelector('main');

    if (savedState === 'true' && menuContainer) {
        menuContainer.classList.add('collapsed');
        if (mainElement) {
            mainElement.classList.add('menu-collapsed');
        }
        updateMenuTooltips(true);

        const toggleButton = document.querySelector('.menu-toggle i');
        if (toggleButton) {
            toggleButton.style.transform = 'rotate(180deg)';
        }
    }
}

function addCollapsedMenuInteractions() {
    const menuContainer = document.querySelector('.menu-container');
    if (!menuContainer) return;

}

function updateMenuUserInfo() {
    if (!window.user) return;

    const menuAvatar = document.getElementById('menu_user_avatar');
    if (menuAvatar && window.user.avatar) {
        menuAvatar.src = `https://cdn.discordapp.com/avatars/${window.user.id}/${window.user.avatar}.png?size=128`;
    } else if (menuAvatar) {
        menuAvatar.src = 'https://vapr-club.b-cdn.net/default_vapr_avatar.png';
    }

    const menuUsername = document.getElementById('menu_username');
    if (menuUsername) {
        menuUsername.textContent = '@' + window.user.username;
    }

    const menuLevel = document.getElementById('menu_user_level');
    if (menuLevel) {
        menuLevel.textContent = window.user.level || 0;
    }

    updateMenuXPBar();
}

function updateMenuXPBar() {
    if (!window.user) return;

    const xp = window.user.xp || 0;
    const xpRequired = window.user.xp_required || 700;
    const xpPercentage = (xp / xpRequired) * 100;

    const xpBar = document.getElementById('menu_xp_bar');
    const xpText = document.getElementById('menu_xp_text');

    if (xpBar) {
        xpBar.style.width = xpPercentage + '%';
    }

    if (xpText) {
        xpText.textContent = `${xp} / ${xpRequired} XP`;
    }
}

function showMenuUserElements() {
    const userCard = document.getElementById('menu_user_info');
    const quickStats = document.getElementById('quick_stats');
    const logoutBtn = document.getElementById('logout_btn');

    if (userCard) userCard.style.display = 'flex';
    if (quickStats) quickStats.style.display = 'grid';
    if (logoutBtn) logoutBtn.style.display = 'flex';
}

async function updateQuickStats() {
    try {
        const xpResponse = await api.getDailyXP();
        if (xpResponse && xpResponse.xp !== undefined) {
            const dailyXPEl = document.getElementById('daily_xp');
            if (dailyXPEl) {
                animateCounter(dailyXPEl, 0, xpResponse.xp, 1000);
            }
        }

        const postsResponse = await api.getMyPosts();
        if (postsResponse && Array.isArray(postsResponse)) {
            let totalFollowers = 0;
            let totalViews = 0;

            postsResponse.forEach(post => {
                totalFollowers += post.followersCount || 0;
                totalViews += post.viewsCount || 0;
            });

            const followerEl = document.getElementById('follower_count');
            const viewsEl = document.getElementById('total_views');

            if (followerEl) {
                animateCounter(followerEl, 0, totalFollowers, 1000);
            }
            if (viewsEl) {
                animateCounter(viewsEl, 0, totalViews, 1000);
            }
        }
    } catch (error) {
        console.error('Error updating quick stats:', error);
    }
}

function animateCounter(element, start, end, duration) {
    const startTime = performance.now();

    function updateCounter(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        const easeOutQuart = 1 - Math.pow(1 - progress, 4);

        const currentValue = Math.floor(start + (end - start) * easeOutQuart);
        element.textContent = formatNumber(currentValue);

        if (progress < 1) {
            requestAnimationFrame(updateCounter);
        }
    }

    requestAnimationFrame(updateCounter);
}

function formatNumber(num) {
    if (num < 1000) return num.toString();
    if (num < 1000000) return (num / 1000).toFixed(1) + 'K';
    return (num / 1000000).toFixed(1) + 'M';
}

async function updateOnlineUsers() {
    try {
        const data = await api.getUserCount();

        const onlineEl = document.getElementById('online_users');
        if (onlineEl && data.count) {
            onlineEl.textContent = data.count.toLocaleString() + ' users';
        }
    } catch (error) {
        console.error('Error fetching online users:', error);
    }
}

function addMenuAnimations() {
    const menuItems = document.querySelectorAll('.menu-item');

    menuItems.forEach((item, index) => {
        item.style.opacity = '0';
        item.style.transform = 'translateX(-20px)';

        setTimeout(() => {
            item.style.transition = 'all 0.3s ease';
            item.style.opacity = '1';
            item.style.transform = 'translateX(0)';
        }, index * 50);

        item.addEventListener('mouseenter', () => {
        });
    });
}

function isRunningInTauri() {
    return typeof window.__TAURI__ !== 'undefined';
}

function initDesktopDownloadButton() {
    const downloadItem = document.getElementById('desktop-download-item');

    if (downloadItem && !isRunningInTauri()) {
        downloadItem.style.display = 'flex';

        setTimeout(() => {
            downloadItem.style.opacity = '0';
            downloadItem.style.transform = 'translateX(-20px)';

            setTimeout(() => {
                downloadItem.style.transition = 'all 0.3s ease';
                downloadItem.style.opacity = '1';
                downloadItem.style.transform = 'translateX(0)';
            }, 100);
        }, 300);
    }
}

function getLatestVersion() {
    const versionElement = document.querySelector('.menu-version span');
    if (versionElement) {
        const versionText = versionElement.textContent;
        const versionMatch = versionText.match(/v(\d+\.\d+\.\d+)/);
        if (versionMatch) {
            return versionMatch[1];
        }
    }
    return '1.1.19';
}

function downloadDesktopApp() {
    const version = getLatestVersion();
    const downloadUrl = `https://github.com/Vic92548/VAPR/releases/download/v${version}/VAPR_${version}_x64_en-US.msi`;

    if (window.analytics && window.analytics.track) {
        window.analytics.track('desktop_app_download_clicked', {
            version: version,
            platform: 'windows'
        });
    }

    window.open(downloadUrl, '_blank');

    if (typeof Swal !== 'undefined') {
        const Toast = Swal.mixin({
            toast: true,
            position: "top-end",
            showConfirmButton: false,
            timer: 5000,
            timerProgressBar: true
        });

        Toast.fire({
            icon: "info",
            title: "Download started!",
            html: `The VAPR desktop app download should begin shortly.<br><small>Windows 64-bit â€¢ v${version}</small>`
        });
    }
}

function openMenu() {
    const menu = document.getElementById('menu');
    if (!menu) return;

    menu.style.display = 'flex';

    if (isUserLoggedIn()) {
        updateMenuUserInfo();
        updateQuickStats();
    }

    const menuContainer = menu.querySelector('.menu-container');
    if (menuContainer) {
        menuContainer.style.transform = 'translateX(-100%)';
        menuContainer.style.opacity = '0';

        setTimeout(() => {
            menuContainer.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
            menuContainer.style.transform = 'translateX(0)';
            menuContainer.style.opacity = '1';
        }, 10);
    }

    addMenuAnimations();

    initDesktopDownloadButton();
}

function hideMenu() {
    const menu = document.getElementById('menu');
    if (!menu) return;

    const menuContainer = menu.querySelector('.menu-container');
    if (menuContainer) {
        menuContainer.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        menuContainer.style.transform = 'translateX(-100%)';
        menuContainer.style.opacity = '0';

        setTimeout(() => {
            menu.style.display = 'none';
        }, 300);
    } else {
        menu.style.display = 'none';
    }
}

async function logout() {
    if (confirm('Are you sure you want to logout?')) {
        try {
            await fetch('/logout', {
                method: 'POST',
                credentials: 'include'
            });

            localStorage.removeItem('userData');
            window.user = null;
            window.location.href = '/';
        } catch (error) {
            console.error('Logout error:', error);
            window.location.href = '/';
        }
    }
}

let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        if (window.innerWidth < 769) {
            const menuContainer = document.querySelector('.menu-container');
            const mainElement = document.querySelector('main');

            if (menuContainer) {
                menuContainer.classList.remove('collapsed');
            }
            if (mainElement) {
                mainElement.classList.remove('menu-collapsed');
            }
        } else {
            initMenuCollapseState();
        }
    }, 250);
});

const originalOpenNewPostModel = window.opeNewPostModel;
window.opeNewPostModel = function() {
    hideMenu();
    originalOpenNewPostModel();
};

const originalOpenAnalytics = window.openAnalytics;
window.openAnalytics = function() {
    hideMenu();
    originalOpenAnalytics();
};

const originalOpenCustomizationMenu = window.openCustomizationMenu;
window.openCustomizationMenu = function() {
    hideMenu();
    originalOpenCustomizationMenu();
};

const originalOpenLeaderboardModal = window.openLeaderboardModal;
window.openLeaderboardModal = function() {
    hideMenu();
    originalOpenLeaderboardModal();
};

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        initMenu();

        if (window.innerWidth >= 769) {
            initMenuCollapseState();
        }
    });

    const originalLoadUserData = window.loadUserData;
    window.loadUserData = function() {
        originalLoadUserData();
        setTimeout(initMenu, 500);
    };
}

window.toggleMenuCollapse = toggleMenuCollapse;
window.openMenu = openMenu;
window.hideMenu = hideMenu;
window.logout = logout;
window.downloadDesktopApp = downloadDesktopApp;
function displayPage(type) {
    const post = document.getElementsByClassName("post")[0];
    const game = document.getElementsByClassName("game")[0];

    if(type === "post"){
        game.style.display = "none";
        post.style.display = "block";

        showPost();
    }else if(type === "game"){
        game.style.display = "block";
        post.style.display = "none";


    }
}
function drawPost(data){
    displayReactions();

    APIHandler.handle(
        () => api.registerView(data.id),
        {
            onSuccess: (data) => {
                console.log(data);
                console.log("Views updated");
            }
        }
    );

    post_seen++;
    showPost();
    console.log("Post DATA:");
    console.log(data);

    updateFollowButton();

    const titleEl = document.getElementById("post_title");
    const showMoreButtonEl = document.getElementById("post_title_show_more");
    titleEl.textContent = data.title;

    requestAnimationFrame(() => {
        const isClamped = titleEl.scrollHeight > titleEl.clientHeight;

        if (isClamped) {
            showMoreButtonEl.style.display = "inline-block";
            showMoreButtonEl.onclick = () => {
                titleEl.classList.toggle("expanded");
                const isExpanded = titleEl.classList.contains("expanded");
                showMoreButtonEl.innerHTML = isExpanded
                    ? `<i class="fa-solid fa-chevron-up"></i> Show less`
                    : `<i class="fa-solid fa-chevron-down"></i> Show more`;

                if (isExpanded) {
                    titleEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            };
        } else {
            showMoreButtonEl.style.display = "none";
        }
    });

    const username = data.username;
    document.getElementById("post_username").textContent = "@" + username;

    const avatarImg = document.getElementById("user_avatar_img");
    const avatarLetter = document.getElementById("avatar_letter");
    const avatarEl = document.getElementById("user_avatar");

    function showLetterAvatar() {
        avatarImg.style.display = "none";
        avatarLetter.style.display = "flex";
        avatarLetter.textContent = username.charAt(0).toUpperCase();

        const hue = username.charCodeAt(0) * 3 % 360;
        avatarEl.style.background = `linear-gradient(135deg, hsl(${hue}, 70%, 50%), hsl(${hue + 30}, 70%, 60%))`;
    }

    function showDiscordAvatar(avatarHash) {
        if (avatarHash) {
            avatarImg.src = `https://cdn.discordapp.com/avatars/${data.userId}/${avatarHash}.png?size=128`;
            avatarImg.style.display = "block";
            avatarLetter.style.display = "none";
            avatarEl.style.background = "none";

            avatarImg.onerror = () => {
                console.log("Failed to load Discord avatar, showing fallback");
                showLetterAvatar();
            };
        } else {
            showLetterAvatar();
        }
    }

    if (data.userAvatar !== undefined) {
        showDiscordAvatar(data.userAvatar);

        if (!window.creators) {
            window.creators = {};
        }
        if (!window.creators[data.userId]) {
            window.creators[data.userId] = {};
        }
        window.creators[data.userId].avatar = data.userAvatar;
        window.creators[data.userId].username = data.username;
        window.creators[data.userId].level = data.userLevel || 0;
    }
    else if (window.creators && window.creators[data.userId] && window.creators[data.userId].avatar !== undefined) {
        showDiscordAvatar(window.creators[data.userId].avatar);
    }
    else {
        APIHandler.handle(
            () => api.getUser(data.userId),
            {
                onSuccess: (userInfo) => {
                    if (!window.creators) {
                        window.creators = {};
                    }
                    if (!window.creators[data.userId]) {
                        window.creators[data.userId] = {};
                    }

                    window.creators[data.userId].avatar = userInfo.avatar || null;
                    window.creators[data.userId].username = userInfo.username;
                    window.creators[data.userId].level = userInfo.level || 0;

                    showDiscordAvatar(userInfo.avatar);
                },
                onError: (error) => {
                    console.error("Failed to fetch user info:", error);
                    showLetterAvatar();

                    if (!window.creators) {
                        window.creators = {};
                    }
                    if (!window.creators[data.userId]) {
                        window.creators[data.userId] = {};
                    }
                    window.creators[data.userId].avatar = null;
                }
            }
        );
    }

    document.getElementById("post_time").textContent = timeAgo(data.timestamp);

    animateViewCount(data.views);

    if(!data.content){
        data.content = "https://vapr.b-cdn.net/posts/200w.gif";
    }

    if(data.content.split("/posts/")[0] === "https://vapr-club.b-cdn.net"){
        document.getElementById("post_image").src = data.content;
        document.getElementById("post_image").style.display = "block";
        document.getElementById("post_content").style.display = "none";
        document.getElementById("post_video").style.display = "none";

        const imageEl = document.getElementById("post_image");
        imageEl.style.filter = "blur(10px)";
        imageEl.onload = () => {
            imageEl.style.filter = "none";
            imageEl.style.transition = "filter 0.3s ease";
        };
    }else if(data.content.includes("iframe.mediadelivery.net")){
        document.getElementById("post_video").style.display = "block";
        setTimeout(() => {
            document.getElementById("post_video").children[0].src = data.content;
        }, 100);
        document.getElementById("post_content").style.display = "none";
        document.getElementById("post_image").style.display = "none";
    }

    document.getElementById("post_image").onclick = function () {
        toggleImageZoom(document.getElementById("post_image"));
    }

    const headerLinkButton = document.getElementById("header_link_button");
    const links = document.getElementById("post_link").children;

    for(let i = 0; i < links.length; i++){
        links[i].style.display = "none";
    }

    headerLinkButton.style.display = "none";

    if(data.link){
        handlePostLinks(data.link);
    }
}

function navigateToProfile() {
    if (current_post && current_post.username) {
        window.location.href = `/@${current_post.username}`;
    }
}

function animateViewCount(targetViews) {
    const viewsEl = document.getElementById("post_views");
    const startViews = parseInt(viewsEl.textContent) || 0;
    const duration = 1000;
    const startTime = performance.now();

    function updateViews(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        const easeOutQuart = 1 - Math.pow(1 - progress, 4);

        const currentViews = Math.floor(startViews + (targetViews - startViews) * easeOutQuart);
        viewsEl.textContent = formatViews(currentViews);

        if (progress < 1) {
            requestAnimationFrame(updateViews);
        }
    }

    requestAnimationFrame(updateViews);
}

function toggleImageZoom(img) {
    if (img.classList.contains('zoomed')) {
        img.classList.remove('zoomed');
        document.querySelector('.image-overlay')?.remove();
    } else {
        const overlay = document.createElement('div');
        overlay.className = 'image-overlay';
        overlay.onclick = () => toggleImageZoom(img);

        const zoomedImg = img.cloneNode();
        zoomedImg.className = 'zoomed-image';

        overlay.appendChild(zoomedImg);
        document.body.appendChild(overlay);

        img.classList.add('zoomed');

        requestAnimationFrame(() => {
            overlay.classList.add('active');
        });
    }
}

function handlePostLinks(link) {
    try {
        const url = new URL(link);
        const hostname = url.hostname.toLowerCase();

        const linkMappings = {
            'discord.gg': { id: 'post_discord', icon: 'fa-brands fa-discord', label: 'Discord' },
            'reddit.com': { id: 'post_reddit', icon: 'fa-brands fa-reddit', label: 'Reddit' },
            'store.steampowered.com': { id: 'post_steam', icon: 'fa-brands fa-steam', label: 'Steam' },
            'x.com': { id: 'post_x', icon: 'fa-brands fa-x-twitter', label: 'X' },
            'twitter.com': { id: 'post_x', icon: 'fa-brands fa-x-twitter', label: 'X' },
            'threads.net': { id: 'post_threads', icon: 'fa-brands fa-threads', label: 'Threads' },
            'pinterest': { id: 'post_pinterest', icon: 'fa-brands fa-pinterest', label: 'Pinterest' },
            'twitch.tv': { id: 'post_twitch', icon: 'fa-brands fa-twitch', label: 'Twitch' },
            'youtube.com': { id: 'post_youtube', icon: 'fa-brands fa-youtube', label: 'YouTube' },
            'instagram.com': { id: 'post_instagram', icon: 'fa-brands fa-instagram', label: 'Instagram' },
            'store.epicgames.com': { id: 'post_epic', icon: 'fa-solid fa-gamepad', label: 'Epic Games' },
            'kickstarter.com': { id: 'post_kickstarter', icon: 'fa-brands fa-kickstarter', label: 'Kickstarter' },
            'kick.com': { id: 'post_kick', icon: 'fa-brands fa-kickstarter-k', label: 'Kick' },
            'patreon.com': { id: 'post_patreon', icon: 'fa-brands fa-patreon', label: 'Patreon' },
            'fortnite.com': { id: 'post_fortnite', icon: 'fa-solid fa-gamepad', label: 'Fortnite' },
            'nintendo.com': { id: 'post_nintendo', icon: 'fa-solid fa-gamepad', label: 'Nintendo' },
            'ubisoft.com': { id: 'post_ubisoft', icon: 'fa-solid fa-gamepad', label: 'Ubisoft' },
            'gumroad.com': { id: 'post_gumroad', icon: 'fa-solid fa-shopping-cart', label: 'Gumroad' },
            'garryhost.com': { id: 'post_garryhost', icon: 'fa-solid fa-server', label: "Garry's Host" },
            'itch.io': { id: 'post_itch', icon: 'fa-brands fa-itch-io', label: 'itch.io' }
        };

        let matchedLink = null;
        for (const [domain, linkInfo] of Object.entries(linkMappings)) {
            if (hostname.includes(domain)) {
                matchedLink = linkInfo;
                setupSocialLink(linkInfo.id, link);
                break;
            }
        }

        if (hostname === 'hayarobi-portfolio.carrd.co') {
            matchedLink = { id: 'post_hayarobi', icon: 'fa-solid fa-palette', label: 'Hayarobi' };
            setupSocialLink('post_hayarobi', link);
        }

        if (matchedLink) {
            const headerLinkButton = document.getElementById("header_link_button");
            headerLinkButton.style.display = "inline-flex";
            headerLinkButton.href = link;
            headerLinkButton.innerHTML = `<i class="${matchedLink.icon}"></i><span>${matchedLink.label}</span>`;

            headerLinkButton.style.opacity = '0';
            headerLinkButton.style.transform = 'translateY(10px)';

            setTimeout(() => {
                headerLinkButton.style.transition = 'all 0.3s ease';
                headerLinkButton.style.opacity = '1';
                headerLinkButton.style.transform = 'translateY(0)';
            }, 100);
        }

    } catch (error) {
        console.error('Invalid URL:', link);
    }
}
function showPost() {
    const post = document.getElementsByClassName("post")[0];
    post.style.transform = "translate(0px, 0px) rotate(0deg)";
    post.style.backgroundColor = "";
    post.style.boxShadow = "";
    post.style.animation = 'none';
}

function displayPost(postId = undefined){
    hidePost();
    if(!postId){
        if(feed_posts.length > 0){
            const data = feed_posts.shift();
            loading_steps--;
            hideLoading();
            current_post_id = data.id;
            current_post = data;
            drawPost(data);
            history.pushState(null, null, "/post/" + data.id);
        }else{
            APIHandler.handle(
                () => api.getFeed(),
                {
                    onSuccess: (data) => {
                        console.log(data);
                        feed_posts = data.sort((a, b) => 0.5 - Math.random());
                        console.log(data);
                        displayPost();
                    }
                }
            );
        }
    }else{
        APIHandler.handle(
            () => api.getPost(postId),
            {
                onSuccess: (data) => {
                    loading_steps--;
                    hideLoading();
                    current_post_id = data.id;
                    current_post = data;
                    drawPost(data);
                    history.pushState(null, null, "/post/" + data.id);
                }
            }
        );
    }
}
let user_previous_reaction = null;
let isProcessingReaction = false;

function initEnhancedReactions() {
    const reactionButtons = document.querySelectorAll('.reactions button');

    reactionButtons.forEach(btn => {
        btn.addEventListener('click', function(e) {
            createRipple(e, this);
        });
    });
}

function createRipple(event, button) {
    const ripple = document.createElement('span');
    const rect = button.getBoundingClientRect();
    const size = Math.max(rect.width, rect.height);
    const x = event.clientX - rect.left - size / 2;
    const y = event.clientY - rect.top - size / 2;

    ripple.style.cssText = `
        position: absolute;
        width: ${size}px;
        height: ${size}px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.5);
        pointer-events: none;
        transform: translate(${x}px, ${y}px) scale(0);
        animation: rippleEffect 0.6s ease-out;
    `;

    button.appendChild(ripple);
    setTimeout(() => ripple.remove(), 600);
}

function incrementEmoji(emoji) {
    const emoji_count = document.getElementById(emoji);
    const currentCount = parseInt(emoji_count.textContent);
    const newCount = currentCount + 1;

    emoji_count.style.transform = 'scale(1.5)';
    emoji_count.style.color = '#4ecdc4';

    setTimeout(() => {
        emoji_count.textContent = newCount;
        emoji_count.style.transform = 'scale(1)';
        emoji_count.style.color = '';
    }, 200);
}

function decrementEmoji(emoji) {
    const emoji_count = document.getElementById(emoji);
    const currentCount = parseInt(emoji_count.textContent);
    const newCount = Math.max(0, currentCount - 1);

    emoji_count.style.transform = 'scale(0.8)';
    emoji_count.style.color = '#e74c3c';

    setTimeout(() => {
        emoji_count.textContent = newCount;
        emoji_count.style.transform = 'scale(1)';
        emoji_count.style.color = '';
    }, 200);
}

function resetEmoji(emoji) {
    const emoji_count = document.getElementById(emoji);
    emoji_count.textContent = "0";
}

function addReaction(emoji) {
    if (!isUserLoggedIn()) {
        const reactionsContainer = document.querySelector('.reactions');
        reactionsContainer.style.animation = 'shake 0.5s ease';
        setTimeout(() => {
            reactionsContainer.style.animation = '';
            openRegisterModal();
        }, 500);
        return;
    }

    if (isProcessingReaction) return;

    isProcessingReaction = true;

    const currentBtn = document.querySelector(`[data-reaction="${emoji}"]`);
    const wasActive = currentBtn.classList.contains('active');

    if (user_previous_reaction && user_previous_reaction !== emoji) {
        const prevBtn = document.querySelector(`[data-reaction="${user_previous_reaction}"]`);
        prevBtn.classList.remove('active');
        decrementEmoji(user_previous_reaction);
    }

    if (!wasActive) {
        currentBtn.classList.add('active');
        incrementEmoji(emoji);
        animateReactionIcon(currentBtn.querySelector('.reaction_icon'));
        createFloatingReaction(emoji, currentBtn);
    } else {
        currentBtn.classList.remove('active');
        decrementEmoji(emoji);
        emoji = null;
    }

    APIHandler.handle(
        () => api.addReaction(current_post_id, emoji),
        {
            onSuccess: (data) => {
                console.log('Reaction added:', data);
                user_previous_reaction = emoji;
                isProcessingReaction = false;
            },
            onError: (error) => {
                console.error('Error adding reaction:', error);
                if (user_previous_reaction) {
                    incrementEmoji(user_previous_reaction);
                    decrementEmoji(emoji);
                }
                currentBtn.classList.toggle('active');
                isProcessingReaction = false;
            }
        }
    );
}

function animateReactionIcon(icon) {
    icon.style.animation = 'none';
    setTimeout(() => {
        icon.style.animation = 'bounce 0.5s ease';
    }, 10);
}

function createFloatingReaction(emoji, button) {
    const floater = document.createElement('div');
    floater.className = 'floating-reaction';
    floater.textContent = emoji;

    const rect = button.getBoundingClientRect();
    floater.style.cssText = `
        position: fixed;
        left: ${rect.left + rect.width / 2}px;
        top: ${rect.top}px;
        font-size: 30px;
        pointer-events: none;
        z-index: 1000;
        animation: floatUp 1s ease-out forwards;
    `;

    document.body.appendChild(floater);
    setTimeout(() => floater.remove(), 1000);
}

function displayReactions() {
    document.querySelectorAll('.reactions button').forEach(btn => {
        btn.classList.remove('active');
    });

    resetEmoji('ðŸ’©');
    resetEmoji('ðŸ‘€');
    resetEmoji('ðŸ˜‚');
    resetEmoji('ðŸ’¯');

    console.log("Post id : " + current_post_id);

    APIHandler.handle(
        () => api.getReactions(current_post_id),
        {
            onSuccess: (data) => {
                console.log('Reactions received:', data);
                user_previous_reaction = null;

                data.reactions.forEach((reaction, index) => {
                    setTimeout(() => {
                        incrementEmoji(reaction.emoji);

                        if (reaction.userId === window.user?.id) {
                            user_previous_reaction = reaction.emoji;
                            const btn = document.querySelector(`[data-reaction="${reaction.emoji}"]`);
                            btn.classList.add('active');
                        }
                    }, index * 50);
                });
            }
        }
    );
}

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', initEnhancedReactions);
}
function closeRegisterModal() {
    document.getElementById("register").style.display = "none";
}

document.addEventListener('DOMContentLoaded', function() {
    const userCountEl = document.getElementById('user_count');
    const userCountCtaEl = document.getElementById('user_count_cta');

    if (userCountEl && userCountCtaEl) {
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'childList' || mutation.type === 'characterData') {
                    userCountCtaEl.textContent = userCountEl.textContent;
                }
            });
        });

        observer.observe(userCountEl, { childList: true, characterData: true, subtree: true });
    }
});
function setXPProgress(old_user, disable_xp_notif = false, force_update = false) {
    if (!user.xp) user.xp = 0;
    if (!user.level) user.level = 0;

    const total_xp = user.xp;
    const xp = Math.min(total_xp - old_user.xp, old_user.xp_required);

    updateLevel();
    updateXPDisplay();

    if (xp > 0 || force_update) {
        const diff = (xp / old_user.xp_required) * 100;
        const new_value = (total_xp / old_user.xp_required) * 100;

        const xp_bar_progress_visual = document.getElementById("xp_bar_progress_visual");
        const xp_bar_progress = document.getElementById("xp_bar_progress");
        const notification = document.getElementById('xp-notification');

        xp_bar_progress_visual.style.width = diff + "%";
        xp_bar_progress_visual.style.left = (new_value - diff) + "%";

        if (!disable_xp_notif) {
            notification.style.animation = 'xpNotificationAnimation 1.5s';
            notification.textContent = "+" + xp + " XP";

            setTimeout(() => {
                notification.style.animation = 'none';

                if (old_user.level < user.level) {
                    showLevelUpNotification(user.level);
                    setXPProgress(window.user, true, true);
                }
            }, 1500);
        }

        setTimeout(() => {
            xp_bar_progress.style.width = new_value + "%";
            xp_bar_progress_visual.style.width = "0%";
            xp_bar_progress_visual.style.left = new_value + "%";
        }, 300);
    }
}

function updateLevel() {
    const level_elements = document.getElementsByClassName("xp_level");
    for (let i = 0; i < level_elements.length; i++) {
        level_elements[i].textContent = user.level;
    }

    const xp_level_elements = document.getElementsByClassName("xp-level");
    for (let i = 0; i < xp_level_elements.length; i++) {
        xp_level_elements[i].textContent = user.level;
    }
}

function updateXPDisplay() {
    const username = document.querySelector('.xp-username');

    if (username) username.textContent = user.username || 'username';

    const oldUsername = document.querySelector('.username');
    if (oldUsername) oldUsername.textContent = user.username || 'username';
}

function showLevelUpNotification(newLevel) {
    if (typeof confetti !== 'undefined') {
        confetti({
            particleCount: 50,
            spread: 50,
            origin: { y: 0.3 },
            colors: ['#ffffff', '#4ecdc4', '#667eea']
        });
    }

    if (typeof Swal !== 'undefined') {
        const Toast = Swal.mixin({
            toast: true,
            position: "top-end",
            showConfirmButton: false,
            timer: 3000,
            timerProgressBar: true,
            didOpen: (toast) => {
                toast.onmouseenter = Swal.stopTimer;
                toast.onmouseleave = Swal.resumeTimer;
            }
        });
        Toast.fire({
            icon: "success",
            title: `Level ${newLevel} reached! ðŸŽ‰`
        });
    }
}
document.addEventListener('DOMContentLoaded', (event) => {
    if(!MainPage){
        return;
    }

    const post = document.getElementsByClassName("post")[0];
    let startX = 0;
    let startY = 0;
    let currentX = 0;
    let currentY = 0;
    let startTime = 0;

    post.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        currentX = startX;
        currentY = startY;
        startTime = new Date().getTime();
        post.style.transition = 'none';
        post.style.animation = 'none';
    });

    post.addEventListener('touchmove', (e) => {
        currentX = e.touches[0].clientX;
        currentY = e.touches[0].clientY;
        let changeX = currentX - startX;
        let changeY = currentY - startY;
        post.style.transform = `translate(${changeX}px, ${changeY}px) rotate(${changeX * 0.1}deg)`;
    });

    post.addEventListener('touchend', (e) => {
        let changeX = currentX - startX;
        let changeY = currentY - startY;
        let elapsedTime = new Date().getTime() - startTime;
        let velocity = Math.abs(changeX) / elapsedTime;
        let velocityy = Math.abs(changeY) / elapsedTime;

        if (velocity > 0.3 || Math.abs(changeX) > 100) {
            if (changeX < -100) {
                dislikePost();
            } else if (changeX > 100) {
                likePost();
            }
        }else if (velocityy > 0.3 || Math.abs(changeY) > 100) {
            if (changeY < -100) {
                skipPost();
            }
        } else {
            resetPostPosition();
        }
    });

    function resetPostPosition() {
        post.style.transition = 'transform 0.3s ease';
        post.style.transform = 'translate(0px, 0px) rotate(0deg)';
    }
});

function setInitialTransform(post) {
    const transform = post.style.transform;

    console.log(transform);
    let translateX = transform.split("translate(")[1].split("px,");
    let translateY = translateX[1].split('px)')
    const rotate = parseInt(translateY[1].split("rotate(")[1].split("deg)")[0]);
    translateY = parseInt(translateY[0]);
    translateX = parseInt(translateX[0]);

    console.log({
        translateX: translateX,
        translateY: translateY,
        rotate
    })

    post.style.setProperty('--start-translate-x', `${translateX}px`);
    post.style.setProperty('--start-translate-y', `${translateY}px`);
    post.style.setProperty('--start-rotate', `${rotate}deg`);

    post.style.transform = "translateY(100vh)";
    post.style.transition = 'all 1s ease-in-out';
}

function showActionFeedback(action) {
    const feedback = document.createElement('div');
    feedback.className = 'action-feedback ' + action;
    feedback.innerHTML = `<i class="fa-solid fa-${action === 'liked' ? 'heart' : action === 'passed' ? 'heart-crack' : 'forward'}"></i> ${action.charAt(0).toUpperCase() + action.slice(1)}!`;

    document.body.appendChild(feedback);

    setTimeout(() => {
        feedback.remove();
    }, 1000);
}

function displayLikeAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'swipeRight 0.6s';
    post.style.transform = "translateY(100vh)";

    showActionFeedback('liked');

    confetti({
        particleCount: 100,
        spread: 70,
        origin: { y: 0.6 },
        colors: ['#22c55e', '#10b981', '#059669']
    });
}

function displayDislikeAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'swipeLeft 0.6s';
    post.style.transform = "translateY(100vh)";

    showActionFeedback('passed');
}

function displaySkipAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'skip 0.6s';
    post.style.transform = "translateY(100vh)";

    showActionFeedback('skipped');
}

function likePost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displayLikeAnimation();
        APIHandler.handle(
            () => api.likePost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displayLikeAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}

function skipPost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displaySkipAnimation();
        APIHandler.handle(
            () => api.skipPost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displaySkipAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}

function dislikePost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displayDislikeAnimation();
        APIHandler.handle(
            () => api.dislikePost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displayDislikeAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}

if (!document.getElementById('action-feedback-styles')) {
    const style = document.createElement('style');
    style.id = 'action-feedback-styles';
    style.textContent = `
        .action-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 50px;
            font-size: 24px;
            font-weight: 700;
            z-index: 10000;
            animation: feedbackPulse 0.5s ease-out;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .action-feedback.liked {
            background: rgba(34, 197, 94, 0.9);
        }

        .action-feedback.passed {
            background: rgba(239, 68, 68, 0.9);
        }

        .action-feedback.skipped {
            background: rgba(59, 130, 246, 0.9);
        }

        @keyframes feedbackPulse {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.9;
            }
        }
    `;
    document.head.appendChild(style);
}
if(MainPage){
    const uploadArea = document.querySelector('.upload-area');
    const fileInput = document.getElementById('file');

    if (uploadArea) {
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.add('dragging');
            }, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.remove('dragging');
            }, false);
        });

        uploadArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                fileInput.files = files;
                handleFileSelect(files[0]);
            }
        }
    }

    if (fileInput) {
        fileInput.addEventListener('change', function() {
            if (this.files && this.files[0]) {
                handleFileSelect(this.files[0]);
            }
        });
    }

    function handleFileSelect(file) {
        const fileType = file.type;
        const placeholder = document.getElementById('upload-placeholder');
        const preview = document.getElementById('upload-preview');
        const previewImage = document.getElementById('preview_img');
        const previewVideo = document.getElementById('preview_video');

        if (file.size > 50 * 1024 * 1024) {
            Swal.fire({
                icon: 'error',
                title: 'File too large',
                text: 'Please select a file under 50MB'
            });
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            placeholder.style.display = 'none';
            preview.style.display = 'block';

            if (fileType.startsWith('video/')) {
                previewVideo.src = e.target.result;
                previewVideo.style.display = 'block';
                previewImage.style.display = 'none';
            } else if (fileType.startsWith('image/')) {
                previewImage.src = e.target.result;
                previewImage.style.display = 'block';
                previewVideo.style.display = 'none';
            } else {
                Swal.fire({
                    icon: 'error',
                    title: 'Invalid file type',
                    text: 'Please upload an image or video file'
                });
                placeholder.style.display = 'flex';
                preview.style.display = 'none';
                return;
            }
        };
        reader.readAsDataURL(file);
    }

    const titleInput = document.getElementById('title');
    const titleCount = document.getElementById('title-count');

    if (titleInput && titleCount) {
        titleInput.addEventListener('input', function() {
            titleCount.textContent = this.value.length;
        });
    }
}

window.submitPost = async function(event) {
    event.preventDefault();

    const submitBtn = document.getElementById('submit-post-btn');
    const uploadProgress = document.getElementById('upload-progress');
    const progressFill = document.getElementById('progress-fill');

    const title = document.getElementById('title').value;
    const link = document.getElementById('link').value;
    const file = document.getElementById('file').files[0];

    if (!file) {
        Swal.fire({
            icon: 'warning',
            title: 'No media selected',
            text: 'Please select an image or video to upload'
        });
        return;
    }

    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> <span>Publishing...</span>';

    const formData = new FormData();
    formData.append('title', title);
    formData.append('link', link);

    if (file) {
        const fileExtension = file.name.split('.').pop();
        const fileName = `${new Date().getTime()}.${fileExtension}`;
        const fileContentType = file.type || 'application/octet-stream';
        const blob = new Blob([file], { type: fileContentType });
        formData.append("file", blob, fileName);
    }

    try {
        uploadProgress.style.display = 'block';

        let progress = 0;
        const progressInterval = setInterval(() => {
            progress += Math.random() * 15;
            if (progress > 90) progress = 90;
            progressFill.style.width = progress + '%';
        }, 200);

        const result = await api.createPost(formData);

        clearInterval(progressInterval);
        progressFill.style.width = '100%';

        if (result.success) {
            confetti({
                particleCount: 100,
                spread: 70,
                origin: { y: 0.6 }
            });

            closeAddPostCard();

            document.getElementById('title').value = '';
            document.getElementById('link').value = '';
            document.getElementById('file').value = '';
            document.getElementById('upload-placeholder').style.display = 'flex';
            document.getElementById('upload-preview').style.display = 'none';
            const titleCount = document.getElementById('title-count');
            if (titleCount) {
                titleCount.textContent = '0';
            }

            const Toast = Swal.mixin({
                toast: true,
                position: "top-end",
                showConfirmButton: false,
                timer: 3000,
                timerProgressBar: true
            });

            Toast.fire({
                icon: "success",
                title: "Post published successfully!"
            });

            if (window.user && result.user) {
                const oldUser = {
                    xp: window.user.xp,
                    level: window.user.level,
                    xp_required: window.user.xp_required
                };

                window.user = result.user;
                setXPProgress(oldUser);
            }

            setTimeout(() => {
                displayPost(result.id);
            }, 500);

        } else {
            throw new Error(result.error || 'Failed to create post');
        }

    } catch (error) {
        console.error('Failed to submit post:', error);

        Swal.fire({
            icon: 'error',
            title: 'Upload failed',
            text: error.message || 'Failed to create post. Please try again.'
        });

    } finally {
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="fa-solid fa-paper-plane"></i> <span>Publish Post</span>';
        uploadProgress.style.display = 'none';
        progressFill.style.width = '0%';
    }
}
function initProfilePage() {
    if (!window.profileData) return;

    if (isUserLoggedIn()) {
        addFollowButton();
    }

    makeProfilePostsInteractive();

    addProfileInteractions();

    console.log(profileData);
    if (window.profileData && window.profileData.backgroundId) {
        const background = background_images.find(bg => bg.id === window.profileData.backgroundId);
        if (background) {
            document.getElementById('profile-body').style.backgroundImage = 'url(' + background.image_url + ')';
        }
    }
}

function addFollowButton() {
    const profileHeader = document.querySelector('.profile-info');
    if (!profileHeader || !window.user || window.user.id === window.profileData.id) {
        return;
    }

    const followBtn = document.createElement('button');
    followBtn.className = 'glass_bt follow-profile-btn';
    followBtn.id = 'profile_follow_btn';

    checkProfileFollowStatus(window.profileData.id).then(isFollowing => {
        if (isFollowing) {
            followBtn.innerHTML = '<i class="fa-solid fa-user-minus"></i> Following';
            followBtn.classList.add('following');
        } else {
            followBtn.innerHTML = '<i class="fa-solid fa-user-plus"></i> Follow';
        }
    });

    followBtn.onclick = () => toggleProfileFollow();

    profileHeader.appendChild(followBtn);
}

async function checkProfileFollowStatus(profileUserId) {
    try {
        const isFollowing = await api.checkFollowStatus(profileUserId);
        return isFollowing;
    } catch (error) {
        console.error("Error checking follow status:", error);
        return false;
    }
}

async function toggleProfileFollow() {
    if (!isUserLoggedIn()) {
        window.location.href = '/login';
        return;
    }

    const followBtn = document.getElementById('profile_follow_btn');
    if (!followBtn) return;

    const isFollowing = followBtn.classList.contains('following');
    const action = isFollowing ? "unfollow" : "follow";

    try {
        const tempPost = { id: "profile_follow", userId: window.profileData.id };

        const response = action === 'follow'
            ? await api.followPost(tempPost.id)
            : await api.unfollowPost(tempPost.id);

        if (response) {
            const followerCountEl = document.querySelector('.stat-value[data-stat="followers"]');

            if (isFollowing) {
                followBtn.innerHTML = '<i class="fa-solid fa-user-plus"></i> Follow';
                followBtn.classList.remove('following');
                if (followerCountEl) {
                    const currentCount = parseInt(followerCountEl.textContent.replace(/[^0-9]/g, ''));
                    followerCountEl.textContent = formatNumber(Math.max(0, currentCount - 1));
                }
            } else {
                followBtn.innerHTML = '<i class="fa-solid fa-user-minus"></i> Following';
                followBtn.classList.add('following');
                if (followerCountEl) {
                    const currentCount = parseInt(followerCountEl.textContent.replace(/[^0-9]/g, ''));
                    followerCountEl.textContent = formatNumber(currentCount + 1);
                }
            }
        }
    } catch (error) {
        console.error("Error toggling follow:", error);
    }
}

function makeProfilePostsInteractive() {
    const postCards = document.querySelectorAll('.profile-post-card');

    postCards.forEach(card => {
        card.addEventListener('click', (e) => {
            e.preventDefault();
            const postId = card.href.split('/post/')[1];

            sessionStorage.setItem('previousPage', window.location.pathname);

            window.location.href = card.href;
        });
    });
}

function addProfileInteractions() {
    const style = document.createElement('style');
    style.textContent = `
        .follow-profile-btn {
            background-color: rgb(95, 148, 243);
            color: white;
            padding: 10px 20px;
            font-weight: 700;
            margin-top: 10px;
            border: none;
            cursor: pointer;
        }
        
        .follow-profile-btn.following {
            background-color: rgba(190, 213, 255, 0.4);
            border: 1px solid rgb(206, 220, 247, 0.42);
        }
        
        .follow-profile-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(95, 148, 243, 0.4);
        }
        
        .stat-value[data-stat="followers"] {
            transition: all 0.3s ease;
        }
    `;
    document.head.appendChild(style);
}

function formatNumber(num) {
    if (num < 1000) return num.toString();
    if (num < 1000000) return (num / 1000).toFixed(1) + 'K';
    if (num < 1000000000) return (num / 1000000).toFixed(1) + 'M';
    return (num / 1000000000).toFixed(1) + 'B';
}

document.addEventListener('DOMContentLoaded', () => {
    initProfilePage();
});

if (typeof drawPost !== 'undefined') {
    const originalDrawPost = drawPost;
    drawPost = function(data) {
        originalDrawPost(data);

        const usernameElement = document.getElementById("post_username");
        if (usernameElement && data.username) {
            usernameElement.style.cursor = "pointer";
            usernameElement.onclick = (e) => {
                e.preventDefault();
                window.location.href = `/@${data.username}`;
            };
        }
    };
}
