const cardManager = {
    currentCard: null,
    cards: new Map(),
    isNavigating: false,
    previousPath: null,

    register(cardId, options = {}) {
        this.cards.set(cardId, {
            onShow: options.onShow || (() => {}),
            onHide: options.onHide || (() => {}),
            onLoad: options.onLoad || null,
            route: options.route || null,
            ...options
        });
    },

    async show(cardId) {
        const card = document.getElementById(cardId);
        if (!card) {
            console.error(`Card ${cardId} not found`);
            return;
        }

        if (window.hideMenu) hideMenu();

        this.previousPath = window.location.pathname;

        if (this.currentCard && this.currentCard !== cardId) {
            await this.hideCard(this.currentCard, true);
            await new Promise(resolve => setTimeout(resolve, 50));
        }

        const post = document.querySelector('.post');
        if (post) {
            post.style.display = 'none';
        }

        card.style.display = 'block';

        setTimeout(() => {
            card.classList.add('show');
        }, 10);

        this.currentCard = cardId;

        const config = this.cards.get(cardId) || {};

        if (config.route && window.router && !this.isNavigating) {
            const currentPath = window.location.pathname;
            if (currentPath !== config.route) {
                this.isNavigating = true;
                window.history.pushState(null, null, config.route);
                this.isNavigating = false;
            }
        }

        if (config.onLoad) {
            this.showLoading(cardId);
            try {
                await config.onLoad();
            } catch (error) {
                console.error(`Error loading card ${cardId}:`, error);
            } finally {
                this.hideLoading(cardId);
            }
        }

        if(config.onShow) config.onShow();
    },

    hide(cardId) {
        return this.hideCard(cardId, false);
    },

    hideCard(cardId, skipPostRestore = false) {
        return new Promise((resolve) => {
            const card = document.getElementById(cardId);
            if (!card) {
                resolve();
                return;
            }

            const config = this.cards.get(cardId) || {};

            if (cardId === 'downloads-card' && window.downloadManager) {
                window.downloadManager.pauseEventProcessing();
            }

            card.classList.remove('show');

            setTimeout(() => {
                card.style.display = 'none';

                if(config.onHide) {
                    try {
                        config.onHide();
                    } catch (error) {
                        console.error('Error in onHide:', error);
                    }
                }

                if (this.currentCard === cardId) {
                    this.currentCard = null;
                }

                if (cardId === 'downloads-card' && window.downloadManager) {
                    setTimeout(() => {
                        window.downloadManager.resumeEventProcessing();
                    }, 100);
                }

                if (!skipPostRestore) {
                    const post = document.querySelector('.post');
                    if (post) {
                        post.style.display = 'block';
                        post.style.transform = 'translate(0px, 0px) rotate(0deg)';
                    }

                    if (window.router && !this.isNavigating) {
                        let targetPath = '/';

                        if (window.current_post_id) {
                            targetPath = `/post/${window.current_post_id}`;
                        } else if (this.previousPath && this.previousPath !== window.location.pathname) {
                            targetPath = this.previousPath;
                        }

                        this.isNavigating = true;
                        window.history.pushState(null, null, targetPath);

                        if (targetPath === '/' || targetPath.startsWith('/post/')) {
                            if (window.showPost) window.showPost();
                            if (window.displayPost) {
                                if (targetPath.startsWith('/post/')) {
                                    const postId = targetPath.split('/')[2];
                                    window.displayPost(postId);
                                } else {
                                    window.displayPost();
                                }
                            }
                        }

                        this.isNavigating = false;
                    }
                }

                resolve();
            }, 300);
        });
    },

    showLoading(cardId) {
        const card = document.getElementById(cardId);

        if (cardId === 'analytics-card') {
            const loading = document.getElementById('analytics-loading');
            const content = document.querySelector('.analytics-body');
            if (loading) loading.style.display = 'block';
            if (content) content.style.opacity = '0.3';
        }
        else if (cardId === 'backgrounds-card') {
            const loading = document.getElementById('backgrounds-loading');
            const content = document.getElementById('backgroundsContent');
            if (loading) loading.style.display = 'block';
            if (content) content.style.opacity = '0.3';
        }
        else if (cardId === 'games-card') {
            const loading = document.getElementById('games-loading');
            const content = document.getElementById('gamesContent');
            if (loading) loading.style.display = 'block';
            if (content) content.style.opacity = '0.3';
        }
    },

    hideLoading(cardId) {
        const card = document.getElementById(cardId);

        if (cardId === 'analytics-card') {
            const loading = document.getElementById('analytics-loading');
            const content = document.querySelector('.analytics-body');
            if (loading) loading.style.display = 'none';
            if (content) content.style.opacity = '1';
        }
        else if (cardId === 'backgrounds-card') {
            const loading = document.getElementById('backgrounds-loading');
            const content = document.getElementById('backgroundsContent');
            if (loading) loading.style.display = 'none';
            if (content) content.style.opacity = '1';
        }
        else if (cardId === 'games-card') {
            const loading = document.getElementById('games-loading');
            const content = document.getElementById('gamesContent');
            if (loading) loading.style.display = 'none';
            if (content) content.style.opacity = '1';
        }
    }
};

window.cardManager = cardManager;
const DOM = {
    get: (id) => document.getElementById(id),
    query: (sel) => document.querySelector(sel),
    queryAll: (sel) => document.querySelectorAll(sel),
    create: (tag, attrs = {}, content = '') => {
        const el = document.createElement(tag);
        Object.entries(attrs).forEach(([k, v]) => {
            if (k === 'style' && typeof v === 'object') {
                Object.assign(el.style, v);
            } else if (k === 'class') {
                el.className = v;
            } else if (k.startsWith('on')) {
                el[k] = v;
            } else {
                el.setAttribute(k, v);
            }
        });
        if (content) el.innerHTML = content;
        return el;
    },
    show: (el, display = 'block') => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.style.display = display;
    },
    hide: (el) => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.style.display = 'none';
    },
    toggle: (el, display = 'block') => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.style.display = el.style.display === 'none' ? display : 'none';
    },
    setText: (el, text) => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.textContent = text;
    },
    setHTML: (el, html) => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.innerHTML = html;
    }
};

window.DOM = DOM;
window.analytics = {};
class VAPRRouter {
    constructor() {
        this.routes = new Map();
        this.currentRoute = null;
        this.params = {};
        this.previousRoute = null;
    }

    register(pattern, handler) {
        this.routes.set(pattern, handler);
        console.log('ROUTE REGISTERED', {pattern, handler});
    }

    navigate(path, bIsFrontEndOnly = false) {
        if(bIsFrontEndOnly){
            history.pushState(null, null, path);
            this.handleRoute();
        }
        else{
            loading.show();
            window.location.href = path;
        }
    }

    handleRoute() {
        console.log('ROUTE');
        const path = window.location.pathname;
        this.previousRoute = this.currentRoute;

        if (cardManager.currentCard && !cardManager.isNavigating) {
            cardManager.hide(cardManager.currentCard);
        }

        if (path.startsWith('/@')) {
            this.currentRoute = '/@:username';
            const handler = this.routes.get('/@:username');
            if (handler) {
                handler(this.params);
                return;
            }
        }

        for (const [pattern, handler] of this.routes) {
            const match = this.matchRoute(pattern, path);
            if (match) {
                this.currentRoute = pattern;
                this.params = match.params;
                handler(match.params);
                return;
            }
        }

        this.handle404();
    }

    matchRoute(pattern, path) {
        const patternParts = pattern.split('/').filter(Boolean);
        const pathParts = path.split('/').filter(Boolean);

        if (patternParts.length !== pathParts.length) return null;

        const params = {};

        for (let i = 0; i < patternParts.length; i++) {
            if (patternParts[i].startsWith(':')) {
                const paramName = patternParts[i].slice(1);
                params[paramName] = decodeURIComponent(pathParts[i]);
            } else if (patternParts[i] !== pathParts[i]) {
                return null;
            }
        }

        return { params };
    }

    handle404() {
        this.currentRoute = '404';
        console.log('No route found for:', window.location.pathname);
       
        showPost();
        displayPost();
    }
}

window.router = new VAPRRouter();

window.addEventListener('popstate', () => {
    router.handleRoute();
});
router.register('/', () => {
    showInitialPost();
});

router.register('/post/:id', (params) => {
    showPost();
    displayPost(params.id);
});

router.register('/@:username', async (params) => {
    hidePost();
    cardManager.show('profile-card');
});

router.register('/library', async () => {
    hidePost();
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }
    await cardManager.show('library-card');
});

router.register('/new-post', async () => {
    hidePost();

   
    if (!window.user && loading_steps > 0) {
       
        await new Promise(resolve => {
            const checkAuth = () => {
                if (window.user || loading_steps === 0) {
                    resolve();
                } else {
                    setTimeout(checkAuth, 100);
                }
            };
            checkAuth();
        });
    }

    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }
    openAddPostPage();
});

router.register('/create', async () => {
    hidePost();

   
    if (!window.user && loading_steps > 0) {
       
        await new Promise(resolve => {
            const checkAuth = () => {
                if (window.user || loading_steps === 0) {
                    resolve();
                } else {
                    setTimeout(checkAuth, 100);
                }
            };
            checkAuth();
        });
    }

    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }
    openAddPostPage();
});

router.register('/downloads', async () => {

    if (!isRunningInTauri()) {
        notify.warning('Desktop App Required', 'The downloads manager requires the VAPR desktop app.');
        return;
    }
    hidePost();
    await cardManager.show('downloads-card');
});

router.register('/terms', () => {
    hidePost();
    openTermsPage();
});

router.register('/join', () => {
    hidePost();
    openAuthPage();
});

router.register('/auth', () => {
    hidePost();
    openAuthPage();
});

router.register('/register', () => {
    hidePost();
    openAuthPage();
});

router.register('/login', () => {
    hidePost();
    openAuthPage();
});
class VAPRTemplateEngine {
    constructor() {
        this.templates = new Map();
        this.rendered = new WeakSet();
        this.hooks = new Map();
    }

    init() {
        this.loadTemplates();
        this.processDocument();
        this.observeDOM();
    }

    on(selector, event, callback) {
        const key = `${selector}:${event}`;
        if (!this.hooks.has(key)) {
            this.hooks.set(key, []);
        }
        this.hooks.get(key).push(callback);
    }

    emit(element, event) {
        const tagName = element.tagName.toLowerCase();
        const id = element.id;
        const classes = Array.from(element.classList);

        const selectors = [
            tagName,
            ...classes.map(c => `.${c}`),
            id ? `#${id}` : null
        ].filter(Boolean);

        selectors.forEach(selector => {
            const key = `${selector}:${event}`;
            if (this.hooks.has(key)) {
                this.hooks.get(key).forEach(callback => {
                    callback(element);
                });
            }
        });

        const customSelectors = element.getAttribute('data-hook');
        if (customSelectors) {
            customSelectors.split(' ').forEach(selector => {
                const key = `${selector}:${event}`;
                if (this.hooks.has(key)) {
                    this.hooks.get(key).forEach(callback => {
                        callback(element);
                    });
                }
            });
        }
    }

    loadTemplates() {
        const templates = document.querySelectorAll('template[data-vapr]');
        templates.forEach(template => {
            const name = template.dataset.vapr;
            this.templates.set(name.toLowerCase(), template.innerHTML.trim());
        });
        console.log(`VAPR: Loaded ${this.templates.size} templates`);
    }

    processDocument() {
        this.templates.forEach((template, name) => {
            this.processElements(name);
        });
    }

    processElements(tagName) {
        const elements = document.querySelectorAll(tagName);
        elements.forEach(element => {
            if (!this.rendered.has(element)) {
                this.renderElement(element, tagName);
            }
        });
    }

    processConditionals(html, attributes) {
        const processBlock = (text, isNegative) => {
            const regex = isNegative
                ? /\{\{\^([\w-]+)\}\}/g
                : /\{\{#([\w-]+)\}\}/g;

            let result = text;
            let match;

            const openings = [];
            while ((match = regex.exec(text)) !== null) {
                openings.push({
                    attr: match[1],
                    start: match.index,
                    end: match.index + match[0].length,
                    tag: match[0]
                });
            }

            for (let i = openings.length - 1; i >= 0; i--) {
                const opening = openings[i];
                const closingTag = `{{/${opening.attr}}}`;
                const closingIndex = result.indexOf(closingTag, opening.end);

                if (closingIndex !== -1) {
                    const content = result.substring(opening.end, closingIndex);
                    const value = attributes[opening.attr];

                    let shouldShow;
                    if (isNegative) {
                        shouldShow = !value || value === 'false' || value === '';
                    } else {
                        shouldShow = value && value !== 'false' && value !== '';
                    }

                    const replacement = shouldShow ? this.processConditionals(content, attributes) : '';

                    result = result.substring(0, opening.start) +
                        replacement +
                        result.substring(closingIndex + closingTag.length);
                }
            }

            return result;
        };

        html = processBlock(html, true);
        html = processBlock(html, false);

        return html;
    }

    renderElement(element, tagName) {
        const template = this.templates.get(tagName.toLowerCase());
        if (!template) return;

        const content = element.innerHTML;
        const attributes = {};

        for (let attr of element.attributes) {
            attributes[attr.name] = attr.value;
        }

        let html = template;

        html = html.replace(/<slot\s*\/?>/gi, content);

        html = this.processConditionals(html, attributes);

        html = html.replace(/\{\{([\w-]+)\}\}/g, (match, attrName) => {
            const value = attributes[attrName];
            return value !== undefined && value !== null ? value : '';
        });

        const wrapper = document.createElement('div');
        wrapper.innerHTML = html;

        let rootElement;
        let elementsToEmit = [];

        if (wrapper.children.length === 1) {
            const newElement = wrapper.firstElementChild;

            for (let attr of element.attributes) {
                if (!newElement.hasAttribute(attr.name)) {
                    newElement.setAttribute(attr.name, attr.value);
                }
            }

            element.replaceWith(newElement);
            rootElement = newElement;

            elementsToEmit = [newElement, ...newElement.querySelectorAll('*')];
        } else {
            element.innerHTML = wrapper.innerHTML;
            rootElement = element;

            elementsToEmit = [element, ...element.querySelectorAll('*')];
        }

        this.rendered.add(rootElement);

        elementsToEmit.forEach(el => {
            this.emit(el, 'created');
        });

        requestAnimationFrame(() => {
            if (rootElement.isConnected) {
                const connectedElements = wrapper.children.length === 1
                    ? [rootElement, ...rootElement.querySelectorAll('*')]
                    : [rootElement, ...rootElement.querySelectorAll('*')];

                connectedElements.forEach(el => {
                    if (el.isConnected) {
                        this.emit(el, 'mounted');
                    }
                });
            }
        });
    }

    observeDOM() {
        const observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === 1) {
                        const tagName = node.tagName?.toLowerCase();

                        if (tagName && this.templates.has(tagName)) {
                            if (!this.rendered.has(node)) {
                                this.renderElement(node, tagName);
                            }
                        }

                        this.templates.forEach((template, name) => {
                            const children = node.querySelectorAll(name);
                            children.forEach(child => {
                                if (!this.rendered.has(child)) {
                                    this.renderElement(child, name);
                                }
                            });
                        });
                    }
                });
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    }

    refresh() {
        this.rendered = new WeakSet();
        this.processDocument();
    }

    render(element) {
        const tagName = element.tagName.toLowerCase();
        if (this.templates.has(tagName)) {
            this.renderElement(element, tagName);
        }
    }

    querySelector(selector) {
        return document.querySelector(selector);
    }

    querySelectorAll(selector) {
        return document.querySelectorAll(selector);
    }

    createElement(tagName, attributes = {}) {
        const element = document.createElement(tagName);

        Object.entries(attributes).forEach(([key, value]) => {
            const attrName = key.replace(/([A-Z])/g, '-$1').toLowerCase();

            if (value === null || value === undefined) {
                return;
            } else if (typeof value === 'boolean') {
                element.setAttribute(attrName, value.toString());
            } else if (typeof value === 'object') {
                element.setAttribute(attrName, JSON.stringify(value));
            } else {
                element.setAttribute(attrName, value.toString());
            }
        });

        return element;
    }

    createElements(tagName, dataArray) {
        return dataArray.map(data => this.createElement(tagName, data));
    }

    appendElements(container, tagName, dataArray) {
        const elements = this.createElements(tagName, dataArray);
        elements.forEach(el => container.appendChild(el));
        return elements;
    }
}

window.VAPR = new VAPRTemplateEngine();
window.VAPR.init();

VAPR.on('.menu-section', 'mounted', (element) => {
    const title = element.querySelector('.menu-section-title');
    if (title && title.textContent === 'Desktop App' && typeof window.__TAURI__ !== 'undefined') {
        element.style.display = 'none';
    }
});
function createAddPostPage(content) {
    return `
    <section id="add-post-page" class="add-post-page-container" style="display:none;">
        <button id="add_post_menu_btn" class="create-post-btn glass_bt" onclick="openMenu()"><i class="fa-solid fa-bars"></i></button>

        <div class="add-post-page-header">
            <div class="add-post-page-header-content">
                <button class="add-post-back-btn" onclick="closeAddPostPage()">
                    <i class="fa-solid fa-arrow-left"></i>
                </button>
                <div class="add-post-title-section">
                    <h1 class="add-post-title">Create New Post</h1>
                    <p class="add-post-subtitle">Share your content with the RSPWN community</p>
                </div>
            </div>
        </div>

        <div class="add-post-page-body">
            <div class="add-post-page-content">
                ${content}
            </div>
        </div>
    </section>`;
}

function openAddPostPage() {
    let addPostPage = DOM.get('add-post-page');
    const feed = DOM.get('feed');

   
    if (!addPostPage) {
        const addPostContent = createAddPostContent();
        const addPostPageHTML = createAddPostPage(addPostContent);

       
        const main = document.querySelector('main');
        if (main) {
            main.insertAdjacentHTML('beforeend', addPostPageHTML);
            addPostPage = DOM.get('add-post-page');
        }
    }

    if (addPostPage && feed) {
       
        feed.style.display = 'none';
        addPostPage.style.display = 'flex';

       
        const addPostBody = addPostPage.querySelector('.add-post-page-body');
        if (addPostBody) {
            addPostBody.scrollTop = 0;
        }

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'add-post'}, 'Create New Post - RSPWN', '/create');
        }

       
        document.title = 'Create New Post - RSPWN';

       
        setupCharacterCounter();
    }
}

function closeAddPostPage() {
    const addPostPage = DOM.get('add-post-page');
    const feed = DOM.get('feed');

    if (addPostPage && feed) {
       
        addPostPage.style.display = 'none';
        feed.style.display = 'block';

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'home'}, 'RSPWN', '/');
        }

       
        document.title = 'RSPWN';

       
        clearAddPostForm();
    }
}

function createAddPostContent() {
    return `
        <div class="add-post-form-container">
            <form id="postForm" class="add-post-form">
                <div class="post-section">
                    <div class="section-header">
                        <i class="fa-solid fa-heading"></i>
                        <span>Post Details</span>
                    </div>

                    <div class="input-group">
                        <label for="title">
                            Title <span class="required">*</span>
                        </label>
                        <input type="text" id="title" name="title" placeholder="Give your post an eye-catching title..." required maxlength="100" class="glass-input">
                        <div class="character-count">
                            <span id="title-count">0</span>/100
                        </div>
                    </div>
                </div>

                <div class="post-section">
                    <div class="section-header">
                        <i class="fa-solid fa-photo-film"></i>
                        <span>Media Content</span>
                    </div>

                    <div class="upload-area" onclick="document.getElementById('file').click()">
                        <div class="upload-placeholder" id="upload-placeholder">
                            <div class="upload-icon">
                                <i class="fa-solid fa-cloud-arrow-up"></i>
                            </div>
                            <h3>Drop your media here or click to browse</h3>
                            <p>Supports: JPG, PNG, GIF, MP4, WEBM • Max 50MB</p>
                        </div>
                        <div class="upload-preview" id="upload-preview" style="display:none;">
                            <img id="preview_img" src="" alt="Preview">
                            <video id="preview_video" src="" controls></video>
                            <div class="preview-overlay">
                                <button type="button" class="change-media-btn glass-button" onclick="document.getElementById('file').click()">
                                    <i class="fa-solid fa-camera"></i> Change Media
                                </button>
                            </div>
                        </div>
                        <input type="file" id="file" name="file" hidden accept="image/*,video/*">
                    </div>
                </div>

                <div class="post-section">
                    <div class="section-header">
                        <i class="fa-solid fa-gamepad"></i>
                        <span>Game Tag</span>
                        <span class="optional">(Optional)</span>
                    </div>

                    <div class="game-tag-selector">
                        <button type="button" class="game-tag-button glass-button" id="game-tag-button" onclick="openGameTagModal()">
                            <i class="fa-solid fa-plus"></i> Select a game
                        </button>
                        <div class="selected-game" id="selected-game" style="display:none;">
                            <img class="selected-game-cover" id="selected-game-cover" src="" alt="">
                            <span class="selected-game-title" id="selected-game-title"></span>
                            <button type="button" class="remove-game-tag glass-close-btn" onclick="removeGameTag()">
                                <i class="fa-solid fa-xmark"></i>
                            </button>
                        </div>
                    </div>
                    <p class="input-hint">Tag a game from RSPWN to let users discover it</p>
                </div>

                <div class="post-section submit-section">
                    <div class="submit-actions">
                        <button type="button" class="cancel-btn glass-button" onclick="closeAddPostPage()">
                            <i class="fa-solid fa-xmark"></i> Cancel
                        </button>
                        <button type="submit" class="submit-btn glass-button primary" id="submit-post-btn" onclick="submitPost(event)">
                            <i class="fa-solid fa-paper-plane"></i>
                            <span>Publish Post</span>
                        </button>
                    </div>
                </div>

                <div class="upload-progress" id="upload-progress" style="display:none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <p class="progress-text">Uploading your content...</p>
                </div>
            </form>
        </div>

        <div id="game-tag-modal" class="glass_modal" style="display:none;">
            <div class="game-tag-modal-container">
                <div class="game-tag-modal-header">
                    <div class="header-content">
                        <div class="header-brand">
                            <div class="header-icon">
                                <i class="fa-solid fa-gamepad"></i>
                            </div>
                            <div class="header-text">
                                <h3>Select a Game</h3>
                                <p>Choose a game to tag with your post</p>
                            </div>
                        </div>
                    </div>
                    <button type="button" class="glass-close-btn" onclick="closeGameTagModal()">
                        <i class="fa-solid fa-xmark"></i>
                    </button>
                </div>
                <div class="game-tag-content">
                    <div class="game-tag-search">
                        <input type="text" id="game-tag-search" placeholder="Search games..." class="glass-input" oninput="searchGamesForTag()">
                    </div>
                    <div class="game-tag-list" id="game-tag-list"></div>
                </div>
            </div>
        </div>
    `;
}

function setupCharacterCounter() {
    const titleInput = DOM.get('title');
    const titleCount = DOM.get('title-count');

    if (titleInput && titleCount) {
        titleInput.addEventListener('input', function() {
            titleCount.textContent = this.value.length;
        });
    }
}

function clearAddPostForm() {
    const form = DOM.get('postForm');
    if (form) {
        form.reset();

       
        const titleCount = DOM.get('title-count');
        if (titleCount) {
            titleCount.textContent = '0';
        }

       
        const uploadPreview = DOM.get('upload-preview');
        const uploadPlaceholder = DOM.get('upload-placeholder');
        if (uploadPreview && uploadPlaceholder) {
            uploadPreview.style.display = 'none';
            uploadPlaceholder.style.display = 'flex';
        }

       
        const selectedGame = DOM.get('selected-game');
        const gameTagButton = DOM.get('game-tag-button');
        if (selectedGame && gameTagButton) {
            selectedGame.style.display = 'none';
            gameTagButton.style.display = 'inline-flex';
        }
    }
}

window.addEventListener('popstate', function(event) {
    const path = window.location.pathname;

    if (path === '/create' || path === '/new-post') {
        openAddPostPage();
    } else {
        const addPostPage = DOM.get('add-post-page');
        if (addPostPage && addPostPage.style.display !== 'none') {
            closeAddPostPage();
        }
    }
});

document.addEventListener('DOMContentLoaded', function() {
    const path = window.location.pathname;
    if (path === '/create' || path === '/new-post') {
       
        setTimeout(() => {
            openAddPostPage();
        }, 100);
    }
});

if (typeof window !== 'undefined') {
    window.openAddPostPage = openAddPostPage;
    window.closeAddPostPage = closeAddPostPage;
    window.clearAddPostForm = clearAddPostForm;
}
class API {
    constructor() {
        this.baseURL = '';
        this.defaultHeaders = {
            'Content-Type': 'application/json'
        };
    }

    clearAuth() {
        localStorage.removeItem('userData');
        window.user = null;
    }

    async request(path, options = {}) {
        const {
            method = 'GET',
            body = null,
            requireAuth = true,
            headers = {},
            isFormData = false
        } = options;

        const requestHeaders = {
            ...(!isFormData ? this.defaultHeaders : {}),
            ...headers
        };

        try {
            const response = await fetch(path, {
                method,
                headers: requestHeaders,
                body: isFormData ? body : (body ? JSON.stringify(body) : null),
                credentials: 'include'
            });

            if (!response.ok) {
                if (response.status === 401 && requireAuth) {
                    this.clearAuth();
                   
                    throw new Error('Unauthorized');
                }
                throw new Error(`Network response was not ok: ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            throw error;
        }
    }

    get(path, requireAuth = true) {
        return this.request(path, { requireAuth });
    }

    post(path, body, options = {}) {
        return this.request(path, {
            method: 'POST',
            body,
            ...options
        });
    }

    async getMe() {
        return this.get('/me');
    }

    async getFeed() {
        return this.get('/feed', false);
    }

    async getPost(id) {
        if (!/^[a-f0-9-]{36}$/.test(id)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/posts/${id}`, false);
    }

    async createPost(formData) {
        return this.request('/posts', {
            method: 'POST',
            body: formData,
            isFormData: true,
            requireAuth: true
        });
    }

    async likePost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/like/${postId}`);
    }

    async dislikePost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/dislike/${postId}`);
    }

    async skipPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/skip/${postId}`);
    }

    async followPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/manage-follow?action=follow&postId=${postId}`);
    }

    async unfollowPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/manage-follow?action=unfollow&postId=${postId}`);
    }

    async checkFollowStatus(creatorId) {
        const data = await this.get(`/check-follow/${creatorId}`);
        return data.isFollowing || false;
    }

    async addReaction(postId, emoji) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        const allowedEmojis = ['💩', '👀', '😂', '❤️', '💯', 'null'];
        if (!allowedEmojis.includes(emoji)) {
            throw new Error('Invalid emoji');
        }
        return this.get(`/add-reaction?postId=${postId}&emoji=${encodeURIComponent(emoji)}`);
    }

    async getReactions(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/get-reactions?postId=${postId}`, false);
    }

    async registerView(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/register-view?postId=${postId}`, false);
    }

    async getMyPosts() {
        return this.get('/me/posts');
    }

    async updateBackground(backgroundUrl) {
        return this.get(`/me/update-background?backgroundId=${encodeURIComponent(backgroundUrl)}`);
    }

    async acceptInvitation(ambassadorUserId) {
        return this.get(`/accept-invitation?ambassadorUserId=${ambassadorUserId}`);
    }

    async getUserCount() {
        const response = await fetch('/api/user-count', {
            credentials: 'include'
        });
        return response.json();
    }

    async getUser(userId) {
        return this.get(`/api/user/${userId}`, false);
    }

    async getUserPosts(userId) {
        if (!userId) {
            throw new Error('userId required');
        }
        return this.get(`/api/user/${userId}/posts`, false);
    }

    async resolvePost(input) {
        if (!input) {
            throw new Error('id or url required');
        }
        if (typeof input === 'object') {
            if (input.id) {
                return this.get(`/api/post/resolve?id=${encodeURIComponent(input.id)}`, false);
            }
            if (input.url) {
                return this.get(`/api/post/resolve?url=${encodeURIComponent(input.url)}`, false);
            }
        }
        const str = String(input);
        if (/^[a-f0-9-]{36}$/i.test(str)) {
            return this.get(`/api/post/resolve?id=${encodeURIComponent(str)}`, false);
        }
        return this.get(`/api/post/resolve?url=${encodeURIComponent(str)}`, false);
    }

    async recordPlaytimeSession({ gameId, startedAt, endedAt, durationSeconds, executablePath }) {
        return this.post('/api/playtime/session', { gameId, startedAt, endedAt, durationSeconds, executablePath });
    }

    async getPlaytimeTotals() {
        return this.get('/api/playtime/totals');
    }
}

class APIHandler {
    static async handle(apiCall, options = {}) {
        const {
            onSuccess = () => {},
            onError = null,
            showLoading = false,
            successMessage = null,
            errorMessage = 'An error occurred',
            updateXP = false
        } = options;

        if (showLoading) showLoading();

        try {
            const data = await apiCall();

            if (updateXP && window.user && data.user) {
                const oldUser = {
                    xp: window.user.xp,
                    level: window.user.level,
                    xp_required: window.user.xp_required
                };
                window.user = data.user;
                setXPProgress(oldUser);
            }

            if (successMessage && window.notify) {
                window.notify.success(successMessage);
            }

            await onSuccess(data);
            return data;

        } catch (error) {
            console.error(error);

            if (onError) {
                await onError(error);
            } else if (window.notify) {
                window.notify.error('Error', errorMessage);
            }

            throw error;
        } finally {
            if (showLoading) hideLoading();
        }
    }
}

const api = new API();
window.api = api;
window.APIHandler = APIHandler;

window.makeApiRequest = function(path, requireAuth = true) {
    return api.get(path, requireAuth);
};

if (typeof window !== 'undefined' && window.__TAURI__ && window.__TAURI__.event && window.__TAURI__.core) {
    try {
        window.__TAURI__.event.listen('sdk-request', async (event) => {
            const { id, name, payload } = event.payload || {};
            if (!id || !name) return;
            try {
                let data;
                switch (name) {
                    case 'getFeed':
                        data = await api.getFeed();
                        break;
                    case 'getUserPosts':
                        data = await api.getUserPosts(payload && payload.userId);
                        break;
                    case 'resolvePost':
                        data = await api.resolvePost(payload);
                        break;
                    default:
                        throw new Error('Unknown sdk-request: ' + name);
                }
                await window.__TAURI__.core.invoke('sdk_response', { id, ok: true, data });
            } catch (err) {
                await window.__TAURI__.core.invoke('sdk_response', { id, ok: false, error: String(err && err.message || err) });
            }
        });
    } catch (e) {
        console.error('Failed to setup Tauri sdk-request listener', e);
    }
}
function createAuthPageTemplate(content) {
    return `
    <section id="auth-page" class="auth-container" style="display:none;">
        <div class="auth-header">
            <div class="auth-header-content">
                <div class="auth-title-section">
                    <h1 class="auth-title">
                        <span class="letter-r">R</span>
                        <span class="letter-s">S</span>
                        <span class="letter-p">P</span>
                        <span class="letter-w">W</span>
                        <span class="letter-n">N</span>
                    </h1>
                    <p class="auth-subtitle">The Gamer's Social Network</p>
                </div>
            </div>
        </div>

        <div class="auth-body">
            <div class="auth-content">
                ${content}
            </div>
        </div>
    </section>`;
}

function createAuthContent() {
    return `
        <!-- Main Welcome Section -->
        <div class="auth-welcome-section">
            <div class="welcome-content">
                <h2>Join the Gaming Revolution</h2>
                <p class="welcome-description">Connect with thousands of gamers, share your content, and grow your audience on RSPWN - the platform built by gamers, for gamers.</p>

                <a href="/login" class="discord-login-btn">
                    <div class="btn-content">
                        <i class="fa-brands fa-discord"></i>
                        <span>Continue with Discord</span>
                    </div>
                    <div class="btn-glow"></div>
                </a>

                <div class="security-badges">
                    <div class="security-badge">
                        <i class="fa-solid fa-lock"></i>
                        <span>Secure OAuth</span>
                    </div>
                    <div class="security-badge">
                        <i class="fa-solid fa-server"></i>
                        <span>No passwords stored</span>
                    </div>
                    <div class="security-badge">
                        <i class="fa-solid fa-user-shield"></i>
                        <span>Privacy protected</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Features Section -->
        <div class="auth-features-section">
            <h3 class="section-title">Why Gamers Choose RSPWN</h3>
            <div class="features-grid">
                <div class="feature-card">
                    <div class="feature-icon-wrapper">
                        <i class="fa-solid fa-chart-line"></i>
                        <div class="feature-icon-bg"></div>
                    </div>
                    <h4>Advanced Analytics</h4>
                    <p>Track views, engagement, and growth with professional analytics dashboard</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon-wrapper">
                        <i class="fa-solid fa-trophy"></i>
                        <div class="feature-icon-bg"></div>
                    </div>
                    <h4>Gamified Experience</h4>
                    <p>Level up, earn XP, and unlock exclusive backgrounds as you grow</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon-wrapper">
                        <i class="fa-solid fa-users"></i>
                        <div class="feature-icon-bg"></div>
                    </div>
                    <h4>Growing Community</h4>
                    <p>Connect with gamers who share your passion and grow together</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon-wrapper">
                        <i class="fa-brands fa-github"></i>
                        <div class="feature-icon-bg"></div>
                    </div>
                    <h4>100% Open Source</h4>
                    <p>Built transparently by the community, for the community</p>
                </div>
            </div>
        </div>

        <!-- Community Stats -->
        <div class="auth-stats-section">
            <h3 class="section-title">Join Our Growing Community</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-icon">
                        <i class="fa-solid fa-users"></i>
                    </div>
                    <div class="stat-number" id="user_count_auth">1,000+</div>
                    <div class="stat-label">Active Creators</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon">
                        <i class="fa-solid fa-image"></i>
                    </div>
                    <div class="stat-number">50K+</div>
                    <div class="stat-label">Posts Shared</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon">
                        <i class="fa-solid fa-heart"></i>
                    </div>
                    <div class="stat-number">250K+</div>
                    <div class="stat-label">Reactions Given</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon">
                        <i class="fa-solid fa-gamepad"></i>
                    </div>
                    <div class="stat-number">500+</div>
                    <div class="stat-label">Games Discussed</div>
                </div>
            </div>
        </div>

        <!-- Final CTA -->
        <div class="auth-cta-section">
            <div class="cta-content">
                <h3>Ready to Start Your Journey?</h3>
                <p>Join <span id="user_count_cta_auth">thousands</span> of creators already growing on RSPWN</p>

                <a href="/login" class="discord-login-btn primary">
                    <div class="btn-content">
                        <i class="fa-brands fa-discord"></i>
                        <span>Get Started Now</span>
                    </div>
                    <div class="btn-glow"></div>
                </a>
            </div>
        </div>

        <!-- Footer Links -->
        <div class="auth-footer-links">
            <a href="https://github.com/Vic92548/RSPWN.APP" target="_blank" class="footer-link">
                <i class="fa-brands fa-github"></i>
                <span>View on GitHub</span>
            </a>
            <a href="https://discord.gg/vtsnj3zphd" target="_blank" class="footer-link">
                <i class="fa-brands fa-discord"></i>
                <span>Join Discord</span>
            </a>
        </div>
    `;
}

function openAuthPage() {
    let authPage = DOM.get('auth-page');
    const feed = DOM.get('feed');

   
    if (!authPage) {
        const authContent = createAuthContent();
        const authPageHTML = createAuthPageTemplate(authContent);

       
        const main = document.querySelector('main');
        if (main) {
            main.insertAdjacentHTML('beforeend', authPageHTML);
            authPage = DOM.get('auth-page');
        }
    }

    if (authPage && feed) {
       
        feed.style.display = 'none';
        authPage.style.display = 'flex';

       
        const authBody = authPage.querySelector('.auth-body');
        if (authBody) {
            authBody.scrollTop = 0;
        }

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'auth'}, 'Join RSPWN - The Gamer\'s Social Network', '/join');
        }

       
        document.title = 'Join RSPWN - The Gamer\'s Social Network';

       
        updateAuthUserCount();
    }
}

function closeAuthPage() {
    const authPage = DOM.get('auth-page');
    const feed = DOM.get('feed');

    if (authPage && feed) {
       
        authPage.style.display = 'none';
        feed.style.display = 'block';

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'home'}, 'RSPWN - The Gamer\'s Social Network', '/');
        }

       
        document.title = 'RSPWN';
    }
}

function updateAuthUserCount() {
   
    const mainUserCount = DOM.get('user_count');
    const authUserCount = DOM.get('user_count_auth');
    const authUserCountCta = DOM.get('user_count_cta_auth');

    if (mainUserCount && authUserCount) {
        authUserCount.textContent = mainUserCount.textContent;
    }

    if (mainUserCount && authUserCountCta) {
        authUserCountCta.textContent = mainUserCount.textContent;
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const path = window.location.pathname;
    if (path === '/join' || path === '/auth' || path === '/register' || path === '/login') {
       
        setTimeout(() => {
            openAuthPage();
        }, 100);
    }
});

if (typeof window !== 'undefined') {
    window.openAuthPage = openAuthPage;
    window.closeAuthPage = closeAuthPage;
    window.updateAuthUserCount = updateAuthUserCount;
}
function loadUserData(){
    DOM.hide("sign_in");
    DOM.hide("add_post");

    api.getMe().then(function(data){
        window.user = data;

        if (window.updateSDKUserInfo) {
            window.updateSDKUserInfo();
        }

        updateUsername();
        updateLevel();

        try {
            if (typeof updateApplyUIForAuth === 'function') updateApplyUIForAuth();
        } catch (e) { }

        const oldUser = {
            xp: 0,
            level: window.user.level,
            xp_required: window.user.xp_required
        };

        setXPProgress(oldUser, true);

        syncBackgroundFromBackend();

        DOM.hide("sign_in");
        DOM.show("add_post");

        DOM.show("xp_bar");

        loading_steps--;

        handleReferral();

        loadGamesData().then(() => {
            updateDeveloperSection();
            const accountSection = DOM.get('account_section');
            if (accountSection) DOM.show(accountSection);
            if (typeof showAuthRequiredElements === 'function') {
                showAuthRequiredElements();
            }
        });

        checkAndShowUpdates();
    }).catch(error => {

        DOM.show("sign_in");
        DOM.hide("add_post");
        DOM.get("add_post").onclick = openRegisterModal;
        loading_steps--;

        try {
            if (typeof updateApplyUIForAuth === 'function') updateApplyUIForAuth();
        } catch (e) { }

        const accountSection = DOM.get('account_section');
        if (accountSection) DOM.hide(accountSection);
        if (typeof hideAuthRequiredElements === 'function') {
            hideAuthRequiredElements();
        }
    })
}

function syncBackgroundFromBackend() {
    console.log(window.user);
    if (window.user && window.user.backgroundId) {
        equipBackground(window.user.backgroundId, false);
        console.log('Background synchronized from backend:', window.user.backgroundId);
    } else {
        const background_id = localStorage.getItem('background_id');
        if (background_id) {
            equipBackground(background_id, false);
        } else {
            setDefaultBackground();
        }
    }
}
async function equipBackground(postId, save = true) {
    let imageUrl = null;

    if (window.currentPostId === postId && window.currentPostImageUrl) {
        imageUrl = window.currentPostImageUrl;
    } else {
        imageUrl = await loadBackgroundFromPost(postId);
    }

    if (imageUrl) {
        document.body.style.backgroundImage = 'url(' + imageUrl + ')';

        localStorage.setItem('background_url', imageUrl);
        localStorage.setItem('background_id', postId);

        if (save && isUserLoggedIn() && navigator.onLine) {
            api.updateBackground(postId)
                .then(response => {
                    console.log('Background synced successfully:', response);
                    if (window.user) {
                        window.user.backgroundId = postId;
                    }
                })
                .catch(error => {
                    console.error('Failed to sync background:', error);
                });
        }
    }
}

async function loadBackgroundFromPost(postId) {
    try {
        const post = await api.resolvePost(postId);
        if (post && post.media) {
            document.body.style.backgroundImage = 'url(' + post.media + ')';
            return post.media;
        }
    } catch (error) {
        console.error('Failed to load background from post:', error);
    }
    return null;
}

function setDefaultBackground() {
    const defaultBgUrl = "2133e675-b741-4da0-9bd9-d519bfb72e1e";
    equipBackground(defaultBgUrl, true);
}
async function updateDiscordMembers(element) {
    try {
        const response = await fetch('https://discord.com/api/guilds/1226141081964515449/widget.json');
        if (!response.ok) throw new Error('Discord API error');

        const data = await response.json();
        const memberCount = data.presence_count || 0;

        element.innerHTML = `<i class="fa-solid fa-users"></i> ${memberCount.toLocaleString()}`;
    } catch (error) {
        console.error('Failed to fetch Discord member count:', error);
        element.innerHTML = '<i class="fa-solid fa-users"></i> N/A';
    }
}

if (window.VAPR) {
    VAPR.on('#discord_members', 'mounted', (element) => {
        updateDiscordMembers(element.querySelector('.menu-badge'));
    });
}
class DownloadManager {
    constructor() {
        this.downloads = new Map();
        this.queue = [];
        this.activeDownloads = new Set();
        this.maxConcurrentDownloads = 3;
        this.listeners = new Map();
        this.isActive = true;

        if (isRunningInTauri()) {
            this.initTauriListeners();
        }
    }

    pauseEventProcessing() {
        this.isActive = false;
    }

    resumeEventProcessing() {
        this.isActive = true;
    }

    async initTauriListeners() {
        await window.__TAURI__.event.listen('download-progress', (event) => {
            if (this.isActive) {
                this.handleProgress(event.payload);
            }
        });

        await window.__TAURI__.event.listen('download-status', (event) => {
            this.handleStatusChange(event.payload);
        });

        await window.__TAURI__.event.listen('download-complete', (event) => {
            this.handleCompletion(event.payload);
        });

        await window.__TAURI__.event.listen('download-error', (event) => {
            this.handleError(event.payload);
        });

        await window.__TAURI__.event.listen('update-complete', (event) => {
            this.handleUpdateComplete(event.payload);
        });
    }

    async processQueue() {
        while (this.activeDownloads.size < this.maxConcurrentDownloads && this.queue.length > 0) {
            const downloadId = this.queue.shift();
            const download = this.downloads.get(downloadId);

            if (download && download.status === 'queued') {
                await this.startDownload(downloadId);
            }
        }
    }

    async startDownload(downloadId) {
        const download = this.downloads.get(downloadId);
        if (!download) return;

        download.status = 'preparing';
        download.startTime = Date.now();
        this.activeDownloads.add(downloadId);

        this.emit('download-started', download);

        try {
            const result = await window.__TAURI__.core.invoke('start_download', {
                downloadId: downloadId,
                gameId: download.gameId,
                gameName: download.title,
                downloadUrl: download.downloadUrl,
                isUpdate: download.isUpdate,
                version: download.version
            });

            if (!result.success) {
                throw new Error(result.error || 'Download failed to start');
            }

            download.status = 'downloading';
            this.emit('download-status-changed', download);

        } catch (error) {
            download.status = 'error';
            download.error = error.message;
            this.activeDownloads.delete(downloadId);
            this.emit('download-error', download);
            this.processQueue();
        }
    }

    async pauseDownload(downloadId) {
        const download = this.downloads.get(downloadId);
        if (!download || download.status !== 'downloading') return;

        try {
            await window.__TAURI__.core.invoke('pause_download', { downloadId });
            download.status = 'paused';
            this.activeDownloads.delete(downloadId);
            this.emit('download-paused', download);
            this.processQueue();
        } catch (error) {
            console.error('Failed to pause download:', error);
        }
    }

    async resumeDownload(downloadId) {
        const download = this.downloads.get(downloadId);
        if (!download || download.status !== 'paused') return;

        if (this.activeDownloads.size >= this.maxConcurrentDownloads) {
            download.status = 'queued';
            this.queue.push(downloadId);
            this.emit('download-queued', download);
            return;
        }

        try {
            await window.__TAURI__.core.invoke('resume_download', { downloadId });
            download.status = 'downloading';
            this.activeDownloads.add(downloadId);
            this.emit('download-resumed', download);
        } catch (error) {
            console.error('Failed to resume download:', error);
        }
    }

    async cancelDownload(downloadId) {
        const download = this.downloads.get(downloadId);
        if (!download) return;

        try {
            await window.__TAURI__.core.invoke('cancel_download', { downloadId });

            this.activeDownloads.delete(downloadId);
            this.queue = this.queue.filter(id => id !== downloadId);

            if (download.status !== 'completed') {
                this.downloads.delete(downloadId);
                this.emit('download-cancelled', download);
            }

            this.processQueue();
        } catch (error) {
            console.error('Failed to cancel download:', error);
        }
    }

    handleProgress(payload) {
        const download = this.downloads.get(payload.download_id);
        if (!download) return;

        download.progress = payload.percentage;
        download.downloadedSize = payload.downloaded;
        download.totalSize = payload.total;
        download.speed = payload.speed;
        download.eta = payload.eta;
        download.status = 'downloading';

        this.emit('download-progress', download);
    }

    handleStatusChange(payload) {
        const download = this.downloads.get(payload.download_id);
        if (!download) return;

        download.status = payload.status;
        download.statusText = payload.message;

        this.emit('download-status-changed', download);
    }

    handleCompletion(payload) {
        const download = this.downloads.get(payload.download_id);
        if (!download) return;

        download.status = 'completed';
        download.progress = 100;
        download.endTime = Date.now();
        download.installPath = payload.install_path;
        download.executable = payload.executable;

        this.activeDownloads.delete(payload.download_id);
        this.emit('download-completed', download);
        this.processQueue();
    }

    handleError(payload) {
        const download = this.downloads.get(payload.download_id);
        if (!download) return;

        download.status = 'error';
        download.error = payload.error;

        this.activeDownloads.delete(payload.download_id);
        this.emit('download-error', download);

        this.processQueue();
    }

    async handleUpdateCompleted(payload) {
        if (window.gamesData) {
            window.gamesData.updatingGames.delete(payload.gameId);
            window.gamesData.updates = window.gamesData.updates.filter(u => u.gameId !== payload.gameId);

            const installedGame = window.gamesData.installedGames.find(g => g.id === payload.gameId);
            if (installedGame) {
                installedGame.version = payload.version;
            }
        }

        if (window.notify) {
            window.notify.success(`${payload.gameName} updated to v${payload.version}!`);
        }

        if (window.cardManager && window.cardManager.currentCard === 'library-card') {
            if (typeof window.loadLibraryData === 'function') {
                window.loadLibraryData();
            }
        }
    }

    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
    }

    off(event, callback) {
        if (!this.listeners.has(event)) return;

        const callbacks = this.listeners.get(event);
        const index = callbacks.indexOf(callback);
        if (index > -1) {
            callbacks.splice(index, 1);
        }
    }

    emit(event, data) {
        if (!this.listeners.has(event)) return;

        if (!this.isActive && !['download-completed', 'download-error'].includes(event)) {
            return;
        }

        this.listeners.get(event).forEach(callback => {
            try {
                callback(data);
            } catch (error) {
                console.error(`Error in download manager listener for ${event}:`, error);
            }
        });
    }

    getDownloads() {
        return Array.from(this.downloads.values());
    }

    getActiveDownloads() {
        return this.getDownloads().filter(d => d.status === 'downloading');
    }

    getQueuedDownloads() {
        return this.getDownloads().filter(d => d.status === 'queued');
    }

    getCompletedDownloads() {
        return this.getDownloads().filter(d => d.status === 'completed');
    }

    clearCompleted() {
        const completed = this.getCompletedDownloads();
        completed.forEach(download => {
            this.downloads.delete(download.id);
        });
        this.emit('downloads-cleared', completed);
    }

    addDownload(downloadInfo) {
        this.downloads.set(downloadInfo.id, downloadInfo);
        if (this.activeDownloads.size < this.maxConcurrentDownloads) {
            this.startDownload(downloadInfo.id);
        } else {
            downloadInfo.status = 'queued';
            this.queue.push(downloadInfo.id);
        }
    }
}

window.downloadManager = new DownloadManager();
async function openDownloadsPage() {
    if (!isRunningInTauri()) {
        notify.warning('Desktop App Required', 'The downloads manager requires the VAPR desktop app.');
        return;
    }

    hideMenu();

    try {
       
        await window.__TAURI__.core.invoke('open_downloads_window');
    } catch (error) {
        console.error('Failed to open downloads window:', error);
        notify.error('Failed to open downloads window');
    }
}
async function loadGamesData() {
    try {
        DOM.show('games-loading');

        const [gamesResponse, userGamesResponse, totalsResponse] = await Promise.all([
            api.request('/api/games'),
            isUserLoggedIn() ? api.request('/api/my-games') : Promise.resolve({ games: [] }),
            isUserLoggedIn() ? api.getPlaytimeTotals().catch(() => ({ success: false, totals: [] })) : Promise.resolve({ success: true, totals: [] })
        ]);

        gamesData.allGames = gamesResponse.games || [];
        gamesData.userGames = userGamesResponse.games || [];

        gamesData.playtimeTotals = {};
        if (totalsResponse && totalsResponse.totals) {
            for (const t of totalsResponse.totals) {
                gamesData.playtimeTotals[t.gameId] = t.totalSeconds || 0;
            }
        }

        if (isRunningInTauri()) {
            try {
                const installedGames = await window.__TAURI__.core.invoke('get_installed_games');
                gamesData.installedGames = installedGames || [];
            } catch (error) {
                console.error('Error loading installed games:', error);
                gamesData.installedGames = [];
            }
        }
    } catch (error) {
        console.error('Error loading games:', error);
    } finally {
        DOM.hide('games-loading');
    }
}

async function loadLibraryData() {
    try {
        DOM.show('library-loading');

       
        const response = await api.request('/api/my-games');
        gamesData.userGames = response.games || [];

       
        const totalsResponse = await api.getPlaytimeTotals().catch(() => ({ success: false, totals: [] }));
        gamesData.playtimeTotals = {};
        if (totalsResponse && totalsResponse.totals) {
            for (const t of totalsResponse.totals) {
                gamesData.playtimeTotals[t.gameId] = t.totalSeconds || 0;
            }
        }

       
        if (isRunningInTauri()) {
            try {
                const installedGames = await window.__TAURI__.core.invoke('get_installed_games');
                gamesData.installedGames = installedGames || [];

               
                gamesData.updatingGames.clear();
                gamesData.downloadingGames.clear();

               
                await checkAndShowUpdates();
            } catch (error) {
                console.error('Error loading installed games:', error);
                gamesData.installedGames = [];
            }
        }

        displayLibrary();
    } catch (error) {
        console.error('Error loading library:', error);
    } finally {
        DOM.hide('library-loading');
    }
}
function formatDurationShort(totalSeconds) {
    const seconds = Math.max(0, Math.floor(Number(totalSeconds || 0)));
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    if (hours > 0) return `${hours}h ${minutes}m`;
    if (minutes > 0) return `${minutes}m`;
    return `${secs}s`;
}

function displayLibrary() {
    const container = DOM.get('library-grid');
    container.innerHTML = '';

    if (gamesData.userGames.length === 0) {
        container.innerHTML += '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: rgba(255, 255, 255, 0.6);">No games in your library yet. Redeem a key to get started!</div>';
        return;
    }

    VAPR.appendElements(container, 'library-game-item',
        gamesData.userGames.map(game => {
            const installedGame = gamesData.installedGames.find(g => g.id === game.id);
            const isInstalled = !!installedGame;
            const isDownloading = gamesData.downloadingGames.has(game.id);
            const isUpdating = gamesData.updatingGames.has(game.id);

           
            let hasUpdate = false;
            let updateInfo = null;

            if (isInstalled && game.currentVersion) {
                const installedVersion = installedGame.version || '0.0.0';
                if (isNewerVersion(game.currentVersion, installedVersion)) {
                    hasUpdate = true;
                    updateInfo = {
                        fromVersion: installedVersion,
                        toVersion: game.currentVersion
                    };
                }
            }

            const totalSeconds = Number(gamesData.playtimeTotals?.[game.id] || 0);
            const totalPlaytime = formatDurationShort(totalSeconds);

            return {
                gameId: game.id,
                title: game.title,
                description: game.description,
                coverImage: game.coverImage,
                downloadUrl: game.downloadUrl || '',
                ownedAt: game.ownedAt,
                isInstalled: isInstalled ? 'true' : '',
                isDownloading: isDownloading ? 'true' : '',
                isUpdating: isUpdating ? 'true' : '',
                hasUpdate: hasUpdate ? 'true' : '',
                installedVersion: installedGame?.version || '',
                latestVersion: game.currentVersion || '',
                ...(installedGame?.executable && { executable: installedGame.executable.replaceAll('\\','/') }),
                ...(isDownloading && { downloadProgress: gamesData.downloadingGames.get(game.id) || 0 }),
                totalPlaytime,
                totalPlaytimeSeconds: totalSeconds
            };
        })
    );

    VAPR.refresh();
}
async function downloadGame(gameId, gameTitle, gameCover, downloadUrl, version = null) {
    if (!isRunningInTauri()) {
        notify.desktopAppPrompt(() => downloadDesktopApp());
        return;
    }

    try {
        const game = gamesData.userGames.find(g => g.id === gameId);
        if (!game) {
            throw new Error('Game not found');
        }

       
        if (!version) {
            version = game.currentVersion || game.version || '1.0.0';
        }

        const downloadId = `download-${Date.now()}-${gameId}`;

        await window.__TAURI__.core.invoke('start_download', {
            downloadId: downloadId,
            gameId: gameId,
            gameName: gameTitle,
            gameCover: gameCover,
            downloadUrl: downloadUrl,
            version: version
        });

        console.log({
            downloadId: downloadId,
            gameId: gameId,
            gameName: gameTitle,
            gameCover: gameCover,
            downloadUrl: downloadUrl
        });

        await window.__TAURI__.core.invoke('open_downloads_window');

        notify.success('Download started', `${gameTitle} has been added to your downloads.`);

    } catch (error) {
        console.error('Error starting download:', error);
        notify.error('Download Failed', error.message || 'Failed to start download');
    }
}

function updateGameDownloadProgress(gameId, progress) {
    const gameEl = DOM.get(`game-item-${gameId}`);
    if (!gameEl) return;

    const progressFill = DOM.get(`download-fill-${gameId}`);
    if (progressFill) {
        progressFill.style.width = `${progress.percentage}%`;
    }

    const progressEl = DOM.get(`download-progress-${gameId}`);
    if (progressEl) {
        progressEl.textContent = `${Math.round(progress.percentage)}%`;
    }

    const speedEl = DOM.get(`download-speed-${gameId}`);
    if (speedEl) {
        speedEl.textContent = `${progress.speed.toFixed(2)} MB/s`;
    }

    const sizeEl = DOM.get(`download-size-${gameId}`);
    if (sizeEl) {
        const downloaded = (progress.downloaded / 1024 / 1024).toFixed(2);
        const total = (progress.total / 1024 / 1024).toFixed(2);
        sizeEl.textContent = `${downloaded} MB / ${total} MB`;
    }

    const etaEl = DOM.get(`download-eta-${gameId}`);
    if (etaEl) {
        etaEl.textContent = formatTime(progress.eta);
    }
}

function updateGameDownloadStatus(gameId, statusText) {
    const gameEl = DOM.get(`game-item-${gameId}`);
    if (!gameEl) return;

    const subtitleEl = gameEl.querySelector('.download-progress-subtitle');
    if (subtitleEl) DOM.setText(subtitleEl, statusText);
}

function cancelDownload(gameId) {
    gamesData.downloadingGames.delete(gameId);
    gamesData.updatingGames.delete(gameId);
    displayLibrary();
}

async function uninstallGame(gameId, gameTitle, confirmed = false) {

    if(!confirmed){
        confirmed = await notify.confirmDanger(
            'Uninstall Game?',
            `Are you sure you want to uninstall ${gameTitle}? This will remove all game files from your computer.`,
            'Yes, uninstall'
        );
    }


    if (confirmed) {
        try {
            await window.__TAURI__.core.invoke('uninstall_game', { gameId });
            notify.success(`${gameTitle} uninstalled successfully`);
            await loadLibraryData();
        } catch (error) {
            console.error('Error uninstalling game:', error);
            notify.error('Uninstall Failed', error.message || 'Failed to uninstall the game. Please try again.');
        }
    }
}

async function launchGame(executablePath) {

    if (!isRunningInTauri()) return;

    const button = event.target.closest('button');
    const originalContent = button.innerHTML;
    button.disabled = true;
    button.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Launching...';

    try {
        console.log({executablePath});
        await window.__TAURI__.core.invoke('launch_game', {
            executablePath: executablePath
        });
        notify.success("Game launched!");
    } catch (error) {
        console.error('Error launching game:', error);
        notify.error('Launch Failed', error.message || 'Failed to launch the game. Please try again.');
    } finally {
        button.disabled = false;
        button.innerHTML = originalContent;
    }
}

async function downloadUpdate(gameId, version, gameTitle, gameCover, downloadUrl) {
    if (!isRunningInTauri()) {
        notify.desktopAppPrompt(() => downloadDesktopApp());
        return;
    }

    await uninstallGame(gameId, gameTitle, true);
    downloadGame(gameId, gameTitle, gameCover, downloadUrl, version);
}

function formatTime(seconds) {
    if (seconds === 0) return 'Calculating...';

    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
        return `${hours}h ${minutes}m remaining`;
    } else if (minutes > 0) {
        return `${minutes}m ${secs}s remaining`;
    } else {
        return `${secs}s remaining`;
    }
}

let __vaprPlaytimeUnlisten = null;
async function initPlaytimeListener() {
    if (!isRunningInTauri() || __vaprPlaytimeUnlisten) return;
    __vaprPlaytimeUnlisten = await window.__TAURI__.event.listen('playtime-session', async (event) => {
        try {
            const p = event.payload || {};
           
            const startedAt = p.started_at || p.startedAt;
            const endedAt = p.ended_at || p.endedAt;
            const durationSeconds = Number(p.duration_seconds ?? p.durationSeconds ?? 0);
            const executablePath = p.executable_path || p.executablePath || '';

            let gameId = p.game_id || p.gameId || null;
            if (!gameId && Array.isArray(gamesData.installedGames)) {
                const norm = (s) => String(s || '').replaceAll('\\','/').toLowerCase();
                const match = gamesData.installedGames.find(g => norm(g.executable) === norm(executablePath));
                if (match && match.id) gameId = match.id;
            }

            if (!gameId || !durationSeconds || durationSeconds <= 0) {
                console.warn('Skipping playtime session post due to missing data', p);
                return;
            }

            await APIHandler.handle(
                () => api.recordPlaytimeSession({ gameId, startedAt, endedAt, durationSeconds, executablePath }),
                {
                    onSuccess: async () => {
                        try {
                            const res = await api.getPlaytimeTotals();
                            if (res && res.totals) {
                                gamesData.playtimeTotals = {};
                                for (const t of res.totals) {
                                    gamesData.playtimeTotals[t.gameId] = t.totalSeconds || 0;
                                }
                               
                                if (typeof displayLibrary === 'function') displayLibrary();
                            }
                        } catch (e) {
                            console.error('Failed to refresh playtime totals:', e);
                        }
                    },
                    onError: (e) => console.error('Failed to record playtime session:', e),
                    showLoading: false,
                }
            );
        } catch (err) {
            console.error('Error handling playtime-session event:', err);
        }
    });
}

if (isRunningInTauri()) {
    initPlaytimeListener();
}

window.downloadGame = downloadGame;
window.updateGameDownloadProgress = updateGameDownloadProgress;
window.updateGameDownloadStatus = updateGameDownloadStatus;
window.cancelDownload = cancelDownload;
window.uninstallGame = uninstallGame;
window.launchGame = launchGame;
window.downloadUpdate = downloadUpdate;
cardManager.register('library-card', {
    route: '/library',
    onLoad: async () => {
        await loadLibraryData();
    },
    onShow: () => {
        if (isRunningInTauri()) {
            window.__TAURI__.core.invoke('get_installed_games').then(installedGames => {
                if (installedGames && JSON.stringify(installedGames) !== JSON.stringify(gamesData.installedGames)) {
                    gamesData.installedGames = installedGames;
                    displayLibrary();
                }
            }).catch(console.error);
        }
    }
});

function initGameEventListeners() {
    const gamesGrid = DOM.get('games-grid');
    if (gamesGrid) {
        gamesGrid.addEventListener('click', (e) => {
            const gameItem = e.target.closest('.game-item');
            if (gameItem && !e.target.closest('button')) {
                const gameId = gameItem.id.replace('game-item-', '');
                const game = gamesData.allGames.find(g => g.id === gameId);
                if (game && game.externalLink) {
                    window.open(game.externalLink, '_blank');
                }
            }
        });
    }
}

async function openMyLibrary() {
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }
    hideMenu();
    router.navigate('/library', true);
}

function closeLibraryCard() {
    cardManager.hide('library-card');
}

function openRedeemModal() {
    DOM.show('redeem-modal', 'flex');
    DOM.get('game-key-input').value = '';
    DOM.get('game-key-input').focus();
}

function closeRedeemModal() {
    DOM.hide('redeem-modal');
}

async function redeemKey(event) {
    event.preventDefault();

    const keyInput = DOM.get('game-key-input');
    const key = keyInput.value.trim();

    try {
        const response = await api.request('/api/games/redeem-key', {
            method: 'POST',
            body: { key }
        });

        if (response.success) {
            closeRedeemModal();

            await notify.confirm(
                'Success!',
                `You now own ${response.game.title}!`,
                {
                    icon: 'success',
                    confirmButtonText: 'View Library',
                    showCancelButton: false
                }
            );
            openMyLibrary();
            await loadLibraryData();
        }
    } catch (error) {
        notify.error('Invalid Key', error.message || 'The key you entered is invalid or has already been used.');
    }
}

VAPR.on('.game-tag-item', 'mounted', (element) => {
    const titleEl = element.querySelector('.game-tag-item-title');
    if (titleEl) {
        const gameTitle = titleEl.textContent;
        const toSlug = (s) => String(s)
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
        const slug = toSlug(gameTitle);

        element.onclick = (e) => {
            e.preventDefault();
            router.navigate(`/games/${slug}`, true);
        };
    }
});

window.openTaggedGame = async function() {
    loading.show();
    if (window.currentPostTaggedGame && window.currentPostTaggedGame.id) {
        if (current_post && current_post.id) {
            try {
                const gameId = window.currentPostTaggedGame.id;
                console.log('Tracking game click for game:', gameId, 'post:', current_post.id);

                await api.request('/api/creators/track-game-click', {
                    method: 'POST',
                    body: {
                        gameId: gameId,
                        postId: current_post.id
                    }
                });
                console.log('Successfully tracked game click for creator attribution');
            } catch (error) {
                console.error('Failed to track game click:', error);
            }
        }

        if (!gamesData.tebexGames || gamesData.tebexGames.length === 0) {
            await loadTebexGames();
        }

        const toSlug = (s) => String(s)
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
        const slug = toSlug(window.currentPostTaggedGame.title);

        loading.hide();
        router.navigate(`/games/${slug}`, true);
    }
};

document.addEventListener('DOMContentLoaded', () => {
    initGameEventListeners();
    if (isUserLoggedIn()) {
        setTimeout(checkAndShowUpdates, 3000);
    }
});

setInterval(() => {
    if (isUserLoggedIn()) {
        checkAndShowUpdates();
    }
}, 5 * 60 * 1000);
function openRedeemModal() {
    document.getElementById('redeem-modal').style.display = 'flex';
    document.getElementById('game-key-input').value = '';
    document.getElementById('game-key-input').focus();
}

function closeRedeemModal() {
    document.getElementById('redeem-modal').style.display = 'none';
}

async function redeemKey(event) {
    event.preventDefault();

    const keyInput = document.getElementById('game-key-input');
    const key = keyInput.value.trim();

    try {
        const response = await api.request('/api/games/redeem-key', {
            method: 'POST',
            body: { key }
        });

        if (response.success) {
            closeRedeemModal();

            await notify.confirm(
                'Success!',
                `You now own ${response.game.title}!`,
                {
                    icon: 'success',
                    confirmButtonText: 'View Library',
                    showCancelButton: false
                }
            );

            closeGamesCard();
            openMyLibrary();
            await loadLibraryData();
        }
    } catch (error) {
        notify.error('Invalid Key', error.message || 'The key you entered is invalid or has already been used.');
    }
}
window.gamesData = {
    allGames: [],
    userGames: [],
    currentManagingGame: null,
    installedGames: [],
    downloadingGames: new Map(),
    currentKeyFilter: 'all',
    allKeys: [],
    updates: [],
    versions: [],
    updatingGames: new Map(),
   
    playtimeTotals: {}
};
async function loadTebexGames() {
    try {
       
        const tebexResponse = await tebexAPI.getAllPackages();
        const tebexGames = tebexResponse.data || [];

        console.log('Loaded games from multiple Tebex stores:', tebexGames);

        const transformedGames = transformTebexGames(tebexGames);

        gamesData.tebexGames = transformedGames;

        displayGames();
    } catch (error) {
        console.error('Error loading Tebex games:', error);
    }
}

function transformTebexGames(tebexPackages) {
    return tebexPackages.map(pkg => ({
        id: `tebex-${pkg.id}`,
        title: pkg.name,
        description: pkg.description,
        coverImage: pkg.image || 'https://via.placeholder.com/300x169',
        price: pkg.total_price,
        currency: pkg.currency,
        isTebexProduct: true,
        tebexId: pkg.id,
        category: pkg.category?.name || 'Games',
        onSale: pkg.discount > 0,
        originalPrice: pkg.base_price,
        salePrice: pkg.total_price,
        discount: pkg.discount,
       
        storeInfo: pkg.storeInfo,
        developer: pkg.storeInfo?.username || 'Unknown'
    }));
}
async function findGameIdFromPackageId(packageId) {
    const tebexGame = gamesData.tebexGames?.find(g => g.tebexId === packageId);
    if (tebexGame) {
        const vaprGameId = await findVAPRGameIdByTitle(tebexGame.title);
        return vaprGameId;
    }
    return null;
}

function handleCheckoutSuccess() {
    notify.success('Purchase completed successfully!');

    if (window.loadLibraryData) {
        loadLibraryData();
    }
}

function handleCheckoutCancel() {
    notify.info('Checkout cancelled');
}

document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);

    if (window.location.pathname === '/checkout/success') {
        handleCheckoutSuccess();
        window.history.replaceState({}, '', '/');
    } else if (window.location.pathname === '/checkout/cancel') {
        handleCheckoutCancel();
        window.history.replaceState({}, '', '/');
    }
});

const originalLoadUserData = window.loadUserData;
window.loadUserData = function() {
    originalLoadUserData();
};
async function checkForGameUpdates() {
    return api.request('/api/updates/check');
}

async function markUpdateSeen(gameId) {
    return api.request(`/api/updates/${gameId}/seen`, {
        method: 'POST'
    });
}

async function markUpdateDownloaded(gameId, version) {
    return api.request(`/api/updates/${gameId}/downloaded`, {
        method: 'POST',
        body: { version }
    });
}

async function checkAndShowUpdates() {
    if (!isUserLoggedIn() || !isRunningInTauri()) return;

    try {
       
        const installedGames = await window.__TAURI__.core.invoke('get_installed_games');
        gamesData.installedGames = installedGames || [];

       
        const response = await api.request('/api/my-games');
        if (!response.success || !response.games) return;

        const updates = [];

       
        for (const installedGame of gamesData.installedGames) {
           
            const serverGame = response.games.find(g => g.id === installedGame.id);

            if (serverGame && serverGame.currentVersion) {
                const installedVersion = installedGame.version || '0.0.0';
                const latestVersion = serverGame.currentVersion;

               
                if (isNewerVersion(latestVersion, installedVersion)) {
                    updates.push({
                        gameId: installedGame.id,
                        gameName: installedGame.name || serverGame.title,
                        fromVersion: installedVersion,
                        toVersion: latestVersion,
                        downloadUrl: serverGame.downloadUrl
                    });
                }
            }
        }

        gamesData.updates = updates;

        if (updates.length > 0) {
            showUpdateNotification(updates.length);
        }
    } catch (error) {
        console.error('Error checking for updates:', error);
    }
}

function isNewerVersion(latest, current) {
   
    const latestParts = latest.split('.').map(n => parseInt(n) || 0);
    const currentParts = current.split('.').map(n => parseInt(n) || 0);

    for (let i = 0; i < Math.max(latestParts.length, currentParts.length); i++) {
        const latestPart = latestParts[i] || 0;
        const currentPart = currentParts[i] || 0;

        if (latestPart > currentPart) return true;
        if (latestPart < currentPart) return false;
    }

    return false;
}

function showUpdateNotification(count) {
    const libraryMenuItems = DOM.queryAll('.menu-item');
    libraryMenuItems.forEach(item => {
        const icon = item.querySelector('.menu-item-icon.library');
        if (icon && !icon.querySelector('.update-badge')) {
            const badge = DOM.create('span', {
                class: 'update-badge'
            }, count);
            icon.appendChild(badge);
        }
    });
}
function isRunningInTauri() {
    return typeof window.__TAURI__ !== 'undefined';
}

function isGameDeveloper() {
    if (!window.user) return false;

    return gamesData.allGames.some(game => game.ownerId === window.user.id);
}

async function findVAPRGameIdByTitle(title) {
    if (!title) return null;

    try {
        let vaprGames = gamesData.allGames;

        if (!vaprGames || vaprGames.length === 0) {
            const response = await api.request('/api/games');
            if (response.success) {
                vaprGames = response.games;
            } else {
                return null;
            }
        }

        const matchedGame = vaprGames.find(g =>
            g.title.toLowerCase() === title.toLowerCase()
        );

        return matchedGame?.id || null;
    } catch (error) {
        console.error('Error finding VAPR game by title:', error);
        return null;
    }
}

window.findVAPRGameIdByTitle = findVAPRGameIdByTitle;
async function updateGithubStars(element) {
    try {
        const response = await fetch('https://api.github.com/repos/Vic92548/VAPR');
        if (!response.ok) throw new Error('GitHub API error');

        const data = await response.json();
        const stars = data.stargazers_count;

        element.innerHTML = `<i class="fa-solid fa-star"></i> ${stars}`;
    } catch (error) {
        console.error('Failed to fetch GitHub stars:', error);
        element.innerHTML = '<i class="fa-solid fa-star"></i> N/A';
    }
}

if (window.VAPR) {
    VAPR.on('#github_stars', 'mounted', (element) => {
        console.log({element});
        console.log(element.querySelector('.menu-badge'));
        updateGithubStars(element.querySelector('.menu-badge'));
    });
}

function createLegalPage(config) {
    const {
        pageId,
        pageTitle,
        lastUpdated,
        version = "1.0",
        closeFunction,
        content
    } = config;

    return `
    <section id="${pageId}" class="legal-container" style="display:none;">
        <button id="legal_menu_btn" class="create-post-btn glass_bt" onclick="openMenu()"><i class="fa-solid fa-bars"></i></button>
        <div class="legal-header">
            <div class="legal-header-content">
                <button class="legal-back-btn" onclick="${closeFunction}()">
                    <i class="fa-solid fa-arrow-left"></i>
                </button>
                <div class="legal-title-section">
                    <h1 class="legal-title">${pageTitle}</h1>
                    <p class="legal-subtitle">${lastUpdated}</p>
                </div>
            </div>
        </div>

        <div class="legal-body">
            <div class="legal-content">
                ${content}
            </div>

            <div class="legal-footer">
                <div class="legal-footer-content">
                    <div class="legal-contact">
                        <h3>Contact Information</h3>
                        <p>For questions regarding this document, please contact us:</p>
                        <div class="legal-contact-links">
                            <a href="https://discord.gg/vtsnj3zphd" target="_blank" class="legal-contact-btn">
                                <i class="fa-brands fa-discord"></i>
                                <span>Discord Server</span>
                            </a>
                            <a href="mailto:legal@vapr.club" class="legal-contact-btn">
                                <i class="fa-solid fa-envelope"></i>
                                <span>legal@vapr.club</span>
                            </a>
                        </div>
                    </div>

                    <div class="legal-nav">
                        <h3>Legal Documents</h3>
                        <div class="legal-nav-links">
                            <a href="#" onclick="openTermsPage()" class="legal-nav-link">
                                <i class="fa-solid fa-scale-balanced"></i>
                                <span>Terms of Service</span>
                            </a>
                            <a href="#" onclick="openPrivacyPage()" class="legal-nav-link">
                                <i class="fa-solid fa-shield-halved"></i>
                                <span>Privacy Policy</span>
                            </a>
                        </div>
                    </div>
                </div>

                <div class="legal-copyright">
                    <p>&copy; 2025 VAPR. All rights reserved. Document version ${version} - ${lastUpdated}</p>
                </div>
            </div>
        </div>
    </section>`;
}

function createLegalSection(title, content) {
    return `
    <div class="legal-section">
        <h2 class="section-header">${title}</h2>
        ${content}
    </div>`;
}

function createLegalList(items) {
    const listItems = items.map(item => `<li>${item}</li>`).join('');
    return `<ul class="legal-list">${listItems}</ul>`;
}

if (typeof window !== 'undefined') {
    window.createLegalPage = createLegalPage;
    window.createLegalSection = createLegalSection;
    window.createLegalList = createLegalList;
}
function initPlayerPreferences() {
    if (!window.user) {
        const backgroundUrl = localStorage.getItem('background_url');

        if(backgroundUrl){
            equipBackground(backgroundUrl, false);
        }
    }
}

initPlayerPreferences();
let feed_posts = [];
let loading_steps = 2;
let post_seen = 0;
let creators = {};

function showInitialPost() {
    const path = window.location.pathname.split('/');
    showPost();
    if(path.length < 3){
        displayPost();
    }else if(path[1] === "post"){
        displayPost(path[2]);
    }
}

function isUserLoggedIn(){
    if(window.user){
        return true;
    }else{
        return false;
    }
}

function updateUsername() {
    const level_elements = document.getElementsByClassName("username");
    for (let i = 0; i < level_elements.length; i++) {
        level_elements[i].textContent = user.username;
        console.log("updated username : " + user.username);
    }
}

loadUserData();

let current_post_id = undefined;
let current_post = undefined;

function hidePost() {
    DOM.get("post_video").children[0].src = "";
    document.getElementsByClassName("post")[0].style.transform = "translateY(100vh)";
}

function opeNewPostModel() {
    if (isUserLoggedIn()) {
        hideMenu();
        router.navigate('/create');
    } else {
        openRegisterModal();
    }
}

function closeAddPostCard() {
    if (typeof window.closeAddPostPage === 'function') {
        window.closeAddPostPage();
    }
}

function openRegisterModal() {
    DOM.show("register", "flex");
}

async function updateFollowButton() {
    const follow_bt = DOM.get("follow");

    if(isUserLoggedIn()){
        let following;

        console.log("CURRENT POST");
        console.log(current_post);

        if(creators[current_post.userId]){
            following = creators[current_post.userId].following;
        }else{
            creators[current_post.userId] = {
                following: false
            }
        }

        if(following === undefined){
            following = await checkUserFollowsCreator(current_post.userId);
            creators[current_post.userId].following = following;
        }

        follow_bt.style.opacity = "0";
        follow_bt.style.display = "inline-block";

        if(following){
            follow_bt.innerHTML = '<i class="fa-solid fa-user-minus"></i>';
            follow_bt.onclick = unfollowPost;
            follow_bt.style.border = "1px solid rgb(206 220 247 / 42%)";
            follow_bt.style.backgroundColor = "rgb(190 213 255 / 40%)";
        }else{
            follow_bt.innerHTML = '<i class="fa-solid fa-user-plus"></i>';
            follow_bt.onclick = followPost;
            follow_bt.style.border = "1px solid rgb(77 137 245)";
            follow_bt.style.backgroundColor = "rgb(95 148 243)";
        }

        follow_bt.style.opacity = "1";

        if(current_post.userId === user.id){
            follow_bt.style.opacity = "0";
            follow_bt.style.display = "none";
        }
    }else{
        follow_bt.onclick = openRegisterModal;
    }
}

function followPost() {
    creators[current_post.userId].following = true;
    updateFollowButton();
    if(isUserLoggedIn()){
        APIHandler.handle(
            () => api.followPost(current_post.id),
            {
                errorMessage: 'Error when trying to follow. Please try again.'
            }
        );
    }else{
        openRegisterModal();
    }
}

function unfollowPost() {
    creators[current_post.userId].following = false;
    updateFollowButton();
    if(isUserLoggedIn()){
        APIHandler.handle(
            () => api.unfollowPost(current_post.id)
        );
    }else{
        openRegisterModal();
    }
}

async function checkUserFollowsCreator(creatorId) {
    try {
        const isFollowing = await api.checkFollowStatus(creatorId);
        console.log('Check follow status:', isFollowing);
        return isFollowing;
    } catch (error) {
        console.error('Error checking follow status:', error);
        return false;
    }
}


if(window.innerWidth >= 768){
    DOM.show("menu", 'flex');
}

function processJoinQueryParam() {
    const url = new URL(window.location.href);
    const params = url.searchParams;

    if (params.has('join')) {
        const joinValue = params.get('join');
        console.log("Join param found with value = " + joinValue);
        localStorage.setItem('referrerId', joinValue);
        params.delete('join');
        window.history.replaceState({}, '', url.toString());
    }
}

function handleReferral() {
    const referrerId = localStorage.getItem('referrerId');

    if (referrerId) {
        APIHandler.handle(
            () => api.acceptInvitation(referrerId),
            {
                onSuccess: (data) => {
                    console.log('Invitation processed:', data);
                    if(creators[referrerId]){
                        creators[referrerId].following = true;
                        updateFollowButton();
                    }
                    localStorage.removeItem('referrerId');
                },
                onError: (error) => {
                    localStorage.removeItem('referrerId');
                }
            }
        );
    }
}

function closeTextModal() {
    DOM.hide("text_modal");
}

function copyReferrerId() {
    if(isUserLoggedIn()){
        const referralUrl = `https://vapr.club?join=${user.id}`;
        notify.copyToClipboard(referralUrl, "Invitation link copied to clipboard!");
    }else{
        openRegisterModal();
    }
}

processJoinQueryParam();

function navigateToMyProfile() {
    router.navigate(`/@${window.user.username}`, false);
}

window.closeProfileCard = function() {
    cardManager.hide('profile-card');
};

router.handleRoute();
function initMenu() {
    if (isUserLoggedIn()) {
        updateMenuUserInfo();
        showMenuUserElements();
        showAuthRequiredElements();
    } else {
        hideAuthRequiredElements();
        showPublicMenuElements();
    }

    updateOnlineUsers();
    addMenuAnimations();

    if (window.innerWidth >= 769) {
        initMenuCollapseState();
        addCollapsedMenuInteractions();
    }
}

function updateDeveloperSection() {
    const devSection = DOM.query('.menu-section[title="Developer"]');
    if (devSection) {
        devSection.style.display = isGameDeveloper() ? 'block' : 'none';
    }
}

function toggleMenuCollapse() {
    const menuContainer = DOM.query('.menu-container');
    const mainElement = DOM.query('main');
    const toggleButton = DOM.query('.menu-toggle i');

    if (!menuContainer) return;

    menuContainer.classList.toggle('collapsed');

    if (mainElement) {
        mainElement.classList.toggle('menu-collapsed');
    }

    const isCollapsed = menuContainer.classList.contains('collapsed');
    localStorage.setItem('menuCollapsed', isCollapsed);

    updateMenuTooltips(isCollapsed);

    if (toggleButton) {
        toggleButton.style.transform = isCollapsed ? 'rotate(180deg)' : 'rotate(0deg)';
    }
}

function updateMenuTooltips(isCollapsed) {
    const menuItems = DOM.queryAll('.menu-item');

    menuItems.forEach(item => {
        if (isCollapsed) {
            const title = item.querySelector('.menu-item-title');
            if (title) {
                item.setAttribute('data-tooltip', title.textContent);
            }
        } else {
            item.removeAttribute('data-tooltip');
        }
    });
}

function initMenuCollapseState() {
    const savedState = localStorage.getItem('menuCollapsed');
    const menuContainer = DOM.query('.menu-container');
    const mainElement = DOM.query('main');

    if (savedState === 'true' && menuContainer) {
        menuContainer.classList.add('collapsed');
        if (mainElement) {
            mainElement.classList.add('menu-collapsed');
        }
        updateMenuTooltips(true);

        const toggleButton = DOM.query('.menu-toggle i');
        if (toggleButton) {
            toggleButton.style.transform = 'rotate(180deg)';
        }
    }
}

function addCollapsedMenuInteractions() {
    const menuContainer = DOM.query('.menu-container');
    if (!menuContainer) return;
}

function updateMenuUserInfo() {
    if (!window.user) return;

    const menuAvatar = DOM.get('menu_user_avatar');
    if (menuAvatar && window.user.avatar) {
        menuAvatar.src = `https://cdn.discordapp.com/avatars/${window.user.id}/${window.user.avatar}.png?size=128`;
    } else if (menuAvatar) {
        menuAvatar.src = 'https://vapr-club.b-cdn.net/default_vapr_avatar.png';
    }

    const menuUsername = DOM.get('menu_username');
    if (menuUsername) {
        menuUsername.textContent = '@' + window.user.username;
    }

    const menuLevel = DOM.get('menu_user_level');
    if (menuLevel) {
        menuLevel.textContent = window.user.level || 0;
    }

    updateMenuXPBar();
}

function updateMenuXPBar() {
    if (!window.user) return;

    const xp = window.user.xp || 0;
    const xpRequired = window.user.xp_required || 700;
    const xpPercentage = (xp / xpRequired) * 100;

    const xpBar = DOM.get('menu_xp_bar');
    const xpText = DOM.get('menu_xp_text');

    if (xpBar) {
        xpBar.style.width = xpPercentage + '%';
    }

    if (xpText) {
        xpText.textContent = `${xp} / ${xpRequired} XP`;
    }
}

function showMenuUserElements() {
    const userCard = DOM.get('menu_user_info');
    const accountSection = DOM.get('account_section');
    const publicAuthSection = DOM.get('public_auth_section');

    if (userCard) DOM.show(userCard, 'flex');
    if (accountSection) DOM.show(accountSection);

   
    if (publicAuthSection) DOM.hide(publicAuthSection);
}

function showAuthRequiredElements() {
    const authElements = DOM.queryAll('.auth-required');
    authElements.forEach(element => {
        DOM.show(element);
    });
}

function hideAuthRequiredElements() {
    const authElements = DOM.queryAll('.auth-required');
    authElements.forEach(element => {
        DOM.hide(element);
    });
}

function showPublicMenuElements() {
   
    const publicSections = DOM.queryAll('menu-section:not(.auth-required):not(.developer-section):not([id="account_section"])');
    publicSections.forEach(section => {
        DOM.show(section);
    });

   
    const publicAuthSection = DOM.get('public_auth_section');
    if (publicAuthSection) {
        DOM.show(publicAuthSection);
    }

   
    const publicMenuItems = [
       
        DOM.query('menu-item[onclick*="store"]'),
       
        DOM.query('menu-item[onclick*="github"]'),
        DOM.query('menu-item[onclick*="discord"]'),
       
        DOM.query('menu-item[onclick*="terms"]'),
        DOM.query('menu-item[onclick*="privacy"]')
    ];

    publicMenuItems.forEach(item => {
        if (item && !item.classList.contains('auth-required')) {
            DOM.show(item);
        }
    });
}

async function updateOnlineUsers() {
    try {
        const data = await api.getUserCount();

        const onlineEl = DOM.get('online_users');
        if (onlineEl && data.count) {
            onlineEl.textContent = data.count.toLocaleString() + ' users';
        }
    } catch (error) {
        console.error('Error fetching online users:', error);
    }
}

function addMenuAnimations() {
    const menuItems = DOM.queryAll('.menu-item');

    menuItems.forEach((item, index) => {
        item.style.opacity = '0';
        item.style.transform = 'translateX(-20px)';

        setTimeout(() => {
            item.style.transition = 'all 0.3s ease';
            item.style.opacity = '1';
            item.style.transform = 'translateX(0)';
        }, index * 50);

        item.addEventListener('mouseenter', () => {
        });
    });
}

function isRunningInTauri() {
    return typeof window.__TAURI__ !== 'undefined';
}

function getLatestVersion() {
    const versionElement = DOM.query('.menu-version span');
    if (versionElement) {
        const versionText = versionElement.textContent;
        const versionMatch = versionText.match(/v(\d+\.\d+\.\d+)/);
        if (versionMatch) {
            return versionMatch[1];
        }
    }
    return '1.1.19';
}

function downloadDesktopApp() {
    const version = getLatestVersion();
    const downloadUrl = `https://github.com/Vic92548/VAPR/releases/download/v${version}/VAPR_${version}_x64_en-US.msi`;

    if (window.analytics && window.analytics.track) {
        window.analytics.track('desktop_app_download_clicked', {
            version: version,
            platform: 'windows'
        });
    }

    window.open(downloadUrl, '_blank');

    notify.info("Download started!", `The VAPR desktop app download should begin shortly.<br><small>Windows 64-bit • v${version}</small>`, {
        timer: 5000
    });
}

function openMenu() {
    const menu = DOM.get('menu');
    if (!menu) return;

    DOM.show(menu, 'flex');

    if (isUserLoggedIn()) {
        updateMenuUserInfo();
        showMenuUserElements();
        showAuthRequiredElements();
    } else {
        const accountSection = DOM.get('account_section');
        if (accountSection) DOM.hide(accountSection);
        hideAuthRequiredElements();
        showPublicMenuElements();
    }

    const menuContainer = menu.querySelector('.menu-container');
    if (menuContainer) {
        menuContainer.style.transform = 'translateX(-100%)';
        menuContainer.style.opacity = '0';

        setTimeout(() => {
            menuContainer.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
            menuContainer.style.transform = 'translateX(0)';
            menuContainer.style.opacity = '1';
        }, 10);
    }

    addMenuAnimations();
}

function hideMenu() {
    const menu = DOM.get('menu');
    if (!menu) return;

    const menuContainer = menu.querySelector('.menu-container');
    if (menuContainer) {
        menuContainer.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        menuContainer.style.transform = 'translateX(-100%)';
        menuContainer.style.opacity = '0';

        setTimeout(() => {
            DOM.hide(menu);
        }, 300);
    } else {
        DOM.hide(menu);
    }
}

async function logout() {
    const confirmed = await notify.confirm('Logout', 'Are you sure you want to logout?');

    if (confirmed) {
        try {
            await fetch('/logout', {
                method: 'POST',
                credentials: 'include'
            });

            localStorage.removeItem('userData');

            if (window.clearSDKUserInfo) {
                window.clearSDKUserInfo();
            }

            window.user = null;
            window.location.href = '/';
        } catch (error) {
            console.error('Logout error:', error);
            window.location.href = '/';
        }
    }
}

let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        if (window.innerWidth < 769) {
            const menuContainer = DOM.query('.menu-container');
            const mainElement = DOM.query('main');

            if (menuContainer) {
                menuContainer.classList.remove('collapsed');
            }
            if (mainElement) {
                mainElement.classList.remove('menu-collapsed');
            }
        } else {
            initMenuCollapseState();
        }
    }, 250);
});

const originalOpenNewPostModel = window.opeNewPostModel;
window.opeNewPostModel = function() {
    hideMenu();
    router.navigate('/create');
};

const originalOpenAnalytics = window.openAnalytics;
window.openAnalytics = function() {
    hideMenu();
    originalOpenAnalytics();
};

const originalOpenLeaderboardModal = window.openLeaderboardModal;
window.openLeaderboardModal = function() {
    hideMenu();
    originalOpenLeaderboardModal();
};

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        initMenu();

        if (window.innerWidth >= 769) {
            initMenuCollapseState();
        }

        if (window.user && window.VAPR) {
            insertVAPRUserInfo();
        }
    });

    const originalLoadUserData = window.loadUserData;
    window.loadUserData = function() {
        originalLoadUserData();
        setTimeout(() => {
            initMenu();
            if (window.user && window.VAPR) {
                insertVAPRUserInfo();
            }
        }, 500);
    };
}

if (window.VAPR && typeof window.VAPR.on === 'function') {
    const toggleAccountSection = (el) => {
        if (isUserLoggedIn()) {
            DOM.show(el);
        } else {
            DOM.hide(el);
        }
    };

    window.VAPR.on('#account_section', 'created', toggleAccountSection);
    window.VAPR.on('#account_section', 'mounted', toggleAccountSection);
}

function insertVAPRUserInfo() {
    const menuHeader = DOM.query('.menu-header');
    if (!menuHeader) return;

    const container = menuHeader.parentElement;
    const menuNav = container.querySelector('.menu-nav');

    const existingUserInfo = DOM.get('menu_user_info');
    if (existingUserInfo) existingUserInfo.remove();

    const avatarUrl = window.user.avatar
        ? `https://cdn.discordapp.com/avatars/${window.user.id}/${window.user.avatar}.png?size=128`
        : 'https://vapr-club.b-cdn.net/default_vapr_avatar.png';

    const xpPercent = ((window.user.xp || 0) / (window.user.xp_required || 700)) * 100;

    const userInfo = DOM.create('user-info-card', {
        id: 'menu_user_info',
        avatar: avatarUrl,
        username: '@' + window.user.username,
        level: window.user.level || 0,
        xp: window.user.xp || 0,
        'xp-required': window.user.xp_required || 700,
        'xp-percent': xpPercent.toFixed(1)
    });

    container.insertBefore(userInfo, menuNav);
}
function drawPost(data){
    displayReactions();

    APIHandler.handle(
        () => api.registerView(data.id),
        {
            onSuccess: (data) => {
                console.log(data);
                console.log("Views updated");
            }
        }
    );

    post_seen++;
    showPost();
    console.log("Post DATA:");
    console.log(data);

    updateFollowButton();

    const titleEl = DOM.get("post_title");
    const showMoreButtonEl = DOM.get("post_title_show_more");
    titleEl.textContent = data.title;

    requestAnimationFrame(() => {
        const isClamped = titleEl.scrollHeight > titleEl.clientHeight;

        if (isClamped) {
            showMoreButtonEl.style.display = "inline-block";
            showMoreButtonEl.onclick = () => {
                titleEl.classList.toggle("expanded");
                const isExpanded = titleEl.classList.contains("expanded");
                showMoreButtonEl.innerHTML = isExpanded
                    ? `<i class="fa-solid fa-chevron-up"></i> Show less`
                    : `<i class="fa-solid fa-chevron-down"></i> Show more`;

                if (isExpanded) {
                    titleEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            };
        } else {
            showMoreButtonEl.style.display = "none";
        }
    });

    const username = data.username;
    DOM.setText("post_username", "@" + username);

    const avatarImg = DOM.get("user_avatar_img");
    const avatarLetter = DOM.get("avatar_letter");
    const avatarEl = DOM.get("user_avatar");

    function showLetterAvatar() {
        DOM.hide(avatarImg);
        DOM.show(avatarLetter, "flex");
        avatarLetter.textContent = username.charAt(0).toUpperCase();

        const hue = username.charCodeAt(0) * 3 % 360;
        avatarEl.style.background = `linear-gradient(135deg, hsl(${hue}, 70%, 50%), hsl(${hue + 30}, 70%, 60%))`;
    }

    function showDiscordAvatar(avatarHash) {
        if (avatarHash) {
            avatarImg.src = `https://cdn.discordapp.com/avatars/${data.userId}/${avatarHash}.png?size=128`;
            DOM.show(avatarImg);
            DOM.hide(avatarLetter);
            avatarEl.style.background = "none";

            avatarImg.onerror = () => {
                console.log("Failed to load Discord avatar, showing fallback");
                showLetterAvatar();
            };
        } else {
            showLetterAvatar();
        }
    }

    if (data.userAvatar !== undefined) {
        showDiscordAvatar(data.userAvatar);

        if (!window.creators) {
            window.creators = {};
        }
        if (!window.creators[data.userId]) {
            window.creators[data.userId] = {};
        }
        window.creators[data.userId].avatar = data.userAvatar;
        window.creators[data.userId].username = data.username;
        window.creators[data.userId].level = data.userLevel || 0;
    }
    else if (window.creators && window.creators[data.userId] && window.creators[data.userId].avatar !== undefined) {
        showDiscordAvatar(window.creators[data.userId].avatar);
    }
    else {
        APIHandler.handle(
            () => api.getUser(data.userId),
            {
                onSuccess: (userInfo) => {
                    if (!window.creators) {
                        window.creators = {};
                    }
                    if (!window.creators[data.userId]) {
                        window.creators[data.userId] = {};
                    }

                    window.creators[data.userId].avatar = userInfo.avatar || null;
                    window.creators[data.userId].username = userInfo.username;
                    window.creators[data.userId].level = userInfo.level || 0;

                    showDiscordAvatar(userInfo.avatar);
                },
                onError: (error) => {
                    console.error("Failed to fetch user info:", error);
                    showLetterAvatar();

                    if (!window.creators) {
                        window.creators = {};
                    }
                    if (!window.creators[data.userId]) {
                        window.creators[data.userId] = {};
                    }
                    window.creators[data.userId].avatar = null;
                }
            }
        );
    }

    DOM.setText("post_time", timeAgo(data.timestamp));

    animateViewCount(data.views);

    if(!data.content){
        data.content = "https://vapr.b-cdn.net/posts/200w.gif";
    }

    if(data.content.split("/posts/")[0] === "https://vapr-club.b-cdn.net"){
        DOM.get("post_image").src = data.content;
        DOM.show("post_image");
        DOM.hide("post_content");
        DOM.hide("post_video");

        const imageEl = DOM.get("post_image");
        imageEl.style.filter = "blur(10px)";
        imageEl.onload = () => {
            imageEl.style.filter = "none";
            imageEl.style.transition = "filter 0.3s ease";
        };

        window.currentPostImageUrl = data.content;
        window.currentPostId = data.id;
        updateSetBackgroundButton();
    }else if(data.content.includes("iframe.mediadelivery.net")){
        DOM.show("post_video");
        setTimeout(() => {
            DOM.get("post_video").children[0].src = data.content;
        }, 100);
        DOM.hide("post_content");
        DOM.hide("post_image");
        window.currentPostImageUrl = null;
        window.currentPostId = null;
        updateSetBackgroundButton();
    }

    DOM.get("post_image").onclick = function () {
        toggleImageZoom(DOM.get("post_image"));
    }

    const headerGameButton = DOM.get("header_game_button");

    DOM.hide(headerGameButton);

    if(data.taggedGame && data.taggedGame.id) {
        window.currentPostTaggedGame = data.taggedGame;
        DOM.show(headerGameButton, 'inline-flex');
        headerGameButton.innerHTML = `<i class="fa-solid fa-gamepad"></i><span>${data.taggedGame.title}</span>`;

        headerGameButton.style.opacity = '0';
        headerGameButton.style.transform = 'translateY(10px)';

        setTimeout(() => {
            headerGameButton.style.transition = 'all 0.3s ease';
            headerGameButton.style.opacity = '1';
            headerGameButton.style.transform = 'translateY(0)';
        }, 100);
    } else {
        window.currentPostTaggedGame = null;
    }
}

function updateSetBackgroundButton() {
    let setBackgroundBtn = DOM.get("set_background_btn");

    if (!setBackgroundBtn) {
        setBackgroundBtn = DOM.create('button', {
            id: 'set_background_btn',
            class: 'glass-button set-background-btn',
            onclick: () => setPostAsBackground()
        });
        setBackgroundBtn.innerHTML = '<i class="fa-solid fa-image"></i><span>Set as Background</span>';

        const actionBar = DOM.query('.action-bar');
        if (actionBar) {
            actionBar.appendChild(setBackgroundBtn);
        }
    }

    if (window.currentPostImageUrl && window.currentPostId) {
        DOM.show(setBackgroundBtn, 'inline-flex');

        const currentBackgroundId = localStorage.getItem('background_id');
        if (currentBackgroundId === window.currentPostId) {
            setBackgroundBtn.innerHTML = '<i class="fa-solid fa-check"></i><span>Current Background</span>';
            setBackgroundBtn.classList.add('active');
            setBackgroundBtn.disabled = true;
        } else {
            setBackgroundBtn.innerHTML = '<i class="fa-solid fa-image"></i><span>Set as Background</span>';
            setBackgroundBtn.classList.remove('active');
            setBackgroundBtn.disabled = false;
        }
    } else {
        DOM.hide(setBackgroundBtn);
    }
}

function setPostAsBackground() {
    if (!window.currentPostImageUrl || !window.currentPostId) return;

    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }

   
    equipBackground(window.currentPostId, true);

    updateSetBackgroundButton();
    notify.success("Background updated!");

    if (typeof confetti !== 'undefined') {
        confetti({
            particleCount: 50,
            spread: 50,
            origin: { y: 0.6 },
            colors: ['#4ecdc4', '#44a3aa', '#3d9a92']
        });
    }
}

window.openTaggedGame = async function() {
    loading.show();
    if (window.currentPostTaggedGame && window.currentPostTaggedGame.id) {
        if (current_post && current_post.id) {
            try {
                const gameId = window.currentPostTaggedGame.id;
                console.log('Tracking game click for game:', gameId, 'post:', current_post.id);

                await api.request('/api/creators/track-game-click', {
                    method: 'POST',
                    body: {
                        gameId: gameId,
                        postId: current_post.id
                    }
                });
                console.log('Successfully tracked game click for creator attribution');
            } catch (error) {
                console.error('Failed to track game click:', error);
            }
        }

        if (!gamesData.tebexGames || gamesData.tebexGames.length === 0) {
            await loadTebexGames();
        }

        const toSlug = (s) => String(s)
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
        const slug = toSlug(window.currentPostTaggedGame.title);

        loading.hide();
        router.navigate(`/games/${slug}`, true);
    }
}

function navigateToProfile() {
    if (current_post && current_post.username) {
        router.navigate(`/@${current_post.username}`);
    }
}

function animateViewCount(targetViews) {
    const viewsEl = DOM.get("post_views");
    const startViews = parseInt(viewsEl.textContent) || 0;
    const duration = 1000;
    const startTime = performance.now();

    function updateViews(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        const easeOutQuart = 1 - Math.pow(1 - progress, 4);

        const currentViews = Math.floor(startViews + (targetViews - startViews) * easeOutQuart);
        viewsEl.textContent = formatViews(currentViews);

        if (progress < 1) {
            requestAnimationFrame(updateViews);
        }
    }

    requestAnimationFrame(updateViews);
}

function toggleImageZoom(img) {
    if (img.classList.contains('zoomed')) {
        img.classList.remove('zoomed');
        DOM.query('.image-overlay')?.remove();
    } else {
        const overlay = DOM.create('div', {
            class: 'image-overlay',
            onclick: () => toggleImageZoom(img)
        });

        const zoomedImg = img.cloneNode();
        zoomedImg.className = 'zoomed-image';

        overlay.appendChild(zoomedImg);
        document.body.appendChild(overlay);

        img.classList.add('zoomed');

        requestAnimationFrame(() => {
            overlay.classList.add('active');
        });
    }
}
function showPost() {
    const post = document.getElementsByClassName("post")[0];
    post.style.transform = "translate(0px, 0px) rotate(0deg)";
    post.style.backgroundColor = "";
    post.style.boxShadow = "";
    post.style.animation = 'none';
}

function displayPost(postId = undefined){
    hidePost();
    if(!postId){
        if(feed_posts.length > 0){
            const data = feed_posts.shift();
            loading_steps--;
            current_post_id = data.id;
            current_post = data;
            drawPost(data);
            if (!cardManager.isNavigating) {
                history.pushState(null, null, "/post/" + data.id);
            }
        }else{
            APIHandler.handle(
                () => api.getFeed(),
                {
                    onSuccess: (data) => {
                        console.log(data);
                        feed_posts = data.sort((a, b) => 0.5 - Math.random());
                        console.log(data);
                        displayPost();
                    }
                }
            );
        }
    }else{
        APIHandler.handle(
            () => api.getPost(postId),
            {
                onSuccess: (data) => {
                    loading_steps--;
                    current_post_id = data.id;
                    current_post = data;
                    drawPost(data);
                    if (!cardManager.isNavigating) {
                        history.pushState(null, null, "/post/" + data.id);
                    }
                }
            }
        );
    }
}
function openPrivacyPage() {
    let privacyPage = DOM.get('privacy-page');
    const feed = DOM.get('feed');

   
    if (!privacyPage) {
        const privacyContent = createPrivacyContent();
        const privacyPageHTML = createLegalPage({
            pageId: 'privacy-page',
            pageTitle: 'Privacy Policy',
            lastUpdated: 'Last updated: January 17, 2025',
            version: '1.0',
            closeFunction: 'closePrivacyPage',
            content: privacyContent
        });

       
        const main = document.querySelector('main');
        if (main) {
            main.insertAdjacentHTML('beforeend', privacyPageHTML);
            privacyPage = DOM.get('privacy-page');
        }
    }

    if (privacyPage && feed) {
       
        feed.style.display = 'none';
        privacyPage.style.display = 'flex';

       
        const privacyBody = privacyPage.querySelector('.legal-body');
        if (privacyBody) {
            privacyBody.scrollTop = 0;
        }

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'privacy'}, 'Privacy Policy - VAPR', '/privacy');
        }

       
        document.title = 'Privacy Policy - VAPR';
    }
}

function closePrivacyPage() {
    const privacyPage = DOM.get('privacy-page');
    const feed = DOM.get('feed');

    if (privacyPage && feed) {
       
        privacyPage.style.display = 'none';
        feed.style.display = 'block';

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'home'}, 'VAPR - The Gamer\'s Social Network', '/');
        }

       
        document.title = 'VAPR';
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const path = window.location.pathname;
    if (path === '/privacy') {
       
        setTimeout(() => {
            openPrivacyPage();
        }, 100);
    }
});

function createPrivacyContent() {
    return `
        ${createLegalSection('1. Information We Collect', `
            <p>We collect information you provide directly to us, such as when you create an account, post content, or contact us. This includes:</p>
            ${createLegalList([
                'Discord account information (username, email, profile picture)',
                'Content you post on our platform (text, images, videos)',
                'Messages and communications with us',
                'Usage data and analytics information'
            ])}
        `)}

        ${createLegalSection('2. How We Use Your Information', `
            <p>We use the information we collect to provide, maintain, and improve our services:</p>
            ${createLegalList([
                'Operating and maintaining the VAPR platform',
                'Personalizing your experience and content feed',
                'Communicating with you about updates and features',
                'Ensuring platform security and preventing abuse',
                'Analytics and improving our services'
            ])}
        `)}

        ${createLegalSection('3. Information Sharing', `
            <p>We do not sell, trade, or otherwise transfer your personal information to third parties, except in the following circumstances:</p>
            ${createLegalList([
                'With your explicit consent',
                'To comply with legal obligations or court orders',
                'To protect our rights and prevent fraud or abuse',
                'With service providers who assist in operating our platform',
                'In connection with business transfers or acquisitions'
            ])}
        `)}

        ${createLegalSection('4. Data Storage and Security', `
            <p>We implement appropriate security measures to protect your personal information:</p>
            ${createLegalList([
                'Encrypted data transmission using industry-standard protocols',
                'Secure server infrastructure and database protection',
                'Regular security audits and vulnerability assessments',
                'Limited access to personal data on a need-to-know basis',
                'Incident response procedures for potential data breaches'
            ])}
        `)}

        ${createLegalSection('5. Discord Integration', `
            <p>VAPR uses Discord for authentication and user identification. By using our service, you acknowledge:</p>
            ${createLegalList([
                'We access basic Discord profile information for account creation',
                'Discord\'s Privacy Policy also applies to authentication data',
                'We do not store Discord passwords or sensitive authentication tokens',
                'You can revoke Discord access through your Discord account settings'
            ])}
        `)}

        ${createLegalSection('6. Cookies and Tracking', `
            <p>We use cookies and similar technologies to enhance your experience:</p>
            ${createLegalList([
                'Essential cookies for platform functionality and security',
                'Analytics cookies to understand usage patterns (via Umami and PostHog)',
                'Preference cookies to remember your settings',
                'You can control cookie preferences through your browser settings'
            ])}
        `)}

        ${createLegalSection('7. Your Rights and Choices', `
            <p>You have certain rights regarding your personal information:</p>
            ${createLegalList([
                'Access and review your personal data',
                'Request correction of inaccurate information',
                'Delete your account and associated data',
                'Export your content and data',
                'Opt out of non-essential communications'
            ])}
        `)}

        ${createLegalSection('8. Data Retention', `
            <p>We retain your information for as long as necessary to provide our services and comply with legal obligations. Specifically:</p>
            ${createLegalList([
                'Account data is retained while your account is active',
                'Content may be retained for platform integrity after account deletion',
                'Analytics data is anonymized and retained for service improvement',
                'Legal compliance may require longer retention periods'
            ])}
        `)}

        ${createLegalSection('9. International Data Transfers', `
            <p>VAPR operates globally, and your information may be transferred to and processed in countries other than your own. We ensure appropriate safeguards are in place for international transfers.</p>
        `)}

        ${createLegalSection('10. Children\'s Privacy', `
            <p>Our service is not intended for children under 13 years of age. We do not knowingly collect personal information from children under 13. If we become aware of such collection, we will take steps to delete the information.</p>
        `)}

        ${createLegalSection('11. Changes to Privacy Policy', `
            <p>We may update this Privacy Policy from time to time. We will notify you of any material changes by posting the new Privacy Policy on this page and updating the "Last updated" date. Your continued use of the service after changes constitutes acceptance of the updated policy.</p>
        `)}

        ${createLegalSection('12. Contact Information', `
            <p>If you have questions about this Privacy Policy or our data practices, please contact us using the information provided in the footer below.</p>
        `)}
    `;
}

if (typeof window !== 'undefined') {
    window.openPrivacyPage = openPrivacyPage;
    window.closePrivacyPage = closePrivacyPage;
}
let user_previous_reaction = null;
let isProcessingReaction = false;
let isEmojiDropdownOpen = false;

function initEnhancedReactions() {
   
    document.addEventListener('click', (e) => {
        const emojiOverlay = DOM.query('.emoji-reaction-overlay');
        if (emojiOverlay && !emojiOverlay.contains(e.target) && isEmojiDropdownOpen) {
            closeEmojiDropdown();
        }
    });

   
    updateEmojiTrigger();
}

function toggleEmojiDropdown() {
    if (!isUserLoggedIn()) {
        const emojiTrigger = DOM.get('emoji-trigger');
        emojiTrigger.style.animation = 'shake 0.5s ease';
        setTimeout(() => {
            emojiTrigger.style.animation = '';
            openRegisterModal();
        }, 500);
        return;
    }

    const dropdown = DOM.get('emoji-dropdown');
    const triggerBtn = DOM.get('emoji-trigger');

    if (isEmojiDropdownOpen) {
        closeEmojiDropdown();
    } else {
        openEmojiDropdown();
    }
}

function openEmojiDropdown() {
    const dropdown = DOM.get('emoji-dropdown');
    const triggerBtn = DOM.get('emoji-trigger');

    dropdown.style.display = 'block';
    triggerBtn.classList.add('active');
    isEmojiDropdownOpen = true;

   
    updateDropdownCounts();
}

function closeEmojiDropdown() {
    const dropdown = DOM.get('emoji-dropdown');
    const triggerBtn = DOM.get('emoji-trigger');

    dropdown.style.display = 'none';
    triggerBtn.classList.remove('active');
    isEmojiDropdownOpen = false;
}

function selectReaction(emoji) {
    if (isProcessingReaction) return;

   
    closeEmojiDropdown();

   
    addReaction(emoji);
}

function createRipple(event, button) {
    const rect = button.getBoundingClientRect();
    const size = Math.max(rect.width, rect.height);
    const x = event.clientX - rect.left - size / 2;
    const y = event.clientY - rect.top - size / 2;

    const ripple = DOM.create('span', {
        style: {
            position: 'absolute',
            width: `${size}px`,
            height: `${size}px`,
            borderRadius: '50%',
            background: 'rgba(255, 255, 255, 0.5)',
            pointerEvents: 'none',
            transform: `translate(${x}px, ${y}px) scale(0)`,
            animation: 'rippleEffect 0.6s ease-out'
        }
    });

    button.appendChild(ripple);
    setTimeout(() => ripple.remove(), 600);
}

function incrementEmoji(emoji) {
    const emoji_count = DOM.get(`count-${emoji}`);
    if (!emoji_count) return;

    const currentCount = parseInt(emoji_count.textContent);
    const newCount = currentCount + 1;

    emoji_count.style.transform = 'scale(1.5)';
    emoji_count.style.color = '#4ecdc4';

    setTimeout(() => {
        emoji_count.textContent = newCount;
        emoji_count.style.transform = 'scale(1)';
        emoji_count.style.color = '';
    }, 200);
}

function decrementEmoji(emoji) {
    const emoji_count = DOM.get(`count-${emoji}`);
    if (!emoji_count) return;

    const currentCount = parseInt(emoji_count.textContent);
    const newCount = Math.max(0, currentCount - 1);

    emoji_count.style.transform = 'scale(0.8)';
    emoji_count.style.color = '#e74c3c';

    setTimeout(() => {
        emoji_count.textContent = newCount;
        emoji_count.style.transform = 'scale(1)';
        emoji_count.style.color = '';
    }, 200);
}

function resetEmoji(emoji) {
    const emoji_count = DOM.get(`count-${emoji}`);
    if (emoji_count) {
        emoji_count.textContent = "0";
    }
}

function updateEmojiTrigger() {
    const currentEmojiEl = DOM.get('current-emoji');
    if (!currentEmojiEl) return;

    if (user_previous_reaction) {
        currentEmojiEl.textContent = user_previous_reaction;
    } else {
        currentEmojiEl.textContent = '😊';
    }
}

function updateDropdownCounts() {
   
    const emojis = ['💩', '👀', '😂', '💯'];
    emojis.forEach(emoji => {
        const countEl = DOM.get(`count-${emoji}`);
        if (countEl) {
           
           
        }
    });

   
    DOM.queryAll('.emoji-option').forEach(btn => {
        btn.classList.remove('active');
    });

    if (user_previous_reaction) {
        const activeBtn = DOM.query(`[data-reaction="${user_previous_reaction}"]`);
        if (activeBtn) {
            activeBtn.classList.add('active');
        }
    }
}

function addReaction(emoji) {
    if (!isUserLoggedIn()) {
        const emojiTrigger = DOM.get('emoji-trigger');
        emojiTrigger.style.animation = 'shake 0.5s ease';
        setTimeout(() => {
            emojiTrigger.style.animation = '';
            openRegisterModal();
        }, 500);
        return;
    }

    if (isProcessingReaction) return;

    isProcessingReaction = true;

   
    if (user_previous_reaction && user_previous_reaction !== emoji) {
        decrementEmoji(user_previous_reaction);
    }

   
    let wasRemoving = false;
    if (emoji === null || (user_previous_reaction === emoji)) {
       
        if (user_previous_reaction) {
            decrementEmoji(user_previous_reaction);
        }
        emoji = null;
        wasRemoving = true;
    } else {
       
        incrementEmoji(emoji);
        createFloatingReaction(emoji);
    }

    APIHandler.handle(
        () => api.addReaction(current_post_id, emoji),
        {
            onSuccess: (data) => {
                console.log('Reaction updated:', data);
                user_previous_reaction = emoji;
                updateEmojiTrigger();
                isProcessingReaction = false;
            },
            onError: (error) => {
                console.error('Error updating reaction:', error);
               
                if (wasRemoving && user_previous_reaction) {
                    incrementEmoji(user_previous_reaction);
                } else if (!wasRemoving && emoji) {
                    decrementEmoji(emoji);
                }
                isProcessingReaction = false;
            }
        }
    );
}

function animateReactionIcon(icon) {
    icon.style.animation = 'none';
    setTimeout(() => {
        icon.style.animation = 'bounce 0.5s ease';
    }, 10);
}

function createFloatingReaction(emoji) {
    const triggerBtn = DOM.get('emoji-trigger');
    if (!triggerBtn) return;

    const rect = triggerBtn.getBoundingClientRect();

    const floater = DOM.create('div', {
        class: 'floating-reaction',
        style: {
            position: 'fixed',
            left: `${rect.left + rect.width / 2}px`,
            top: `${rect.top}px`,
            fontSize: '30px',
            pointerEvents: 'none',
            zIndex: '1000',
            animation: 'floatUp 1s ease-out forwards'
        }
    }, emoji);

    document.body.appendChild(floater);
    setTimeout(() => floater.remove(), 1000);
}

function displayReactions() {
   
    resetEmoji('💩');
    resetEmoji('👀');
    resetEmoji('😂');
    resetEmoji('💯');

    console.log("Post id : " + current_post_id);

    APIHandler.handle(
        () => api.getReactions(current_post_id),
        {
            onSuccess: (data) => {
                console.log('Reactions received:', data);
                user_previous_reaction = null;

                data.reactions.forEach((reaction, index) => {
                    setTimeout(() => {
                        incrementEmoji(reaction.emoji);

                        if (reaction.userId === window.user?.id) {
                            user_previous_reaction = reaction.emoji;
                        }
                    }, index * 50);
                });

               
                setTimeout(() => {
                    updateEmojiTrigger();
                }, data.reactions.length * 50 + 100);
            }
        }
    );
}

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', initEnhancedReactions);
}
function closeRegisterModal() {
   
    openAuthPage();
}

function openRegisterModal() {
    openAuthPage();
}

document.addEventListener('DOMContentLoaded', function() {
    const userCountEl = DOM.get('user_count');
    const userCountCtaEl = DOM.get('user_count_cta');

    if (userCountEl && userCountCtaEl) {
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'childList' || mutation.type === 'characterData') {
                    userCountCtaEl.textContent = userCountEl.textContent;
                }
            });
        });

        observer.observe(userCountEl, { childList: true, characterData: true, subtree: true });
    }
});

if (typeof window !== 'undefined') {
    window.closeRegisterModal = closeRegisterModal;
    window.openRegisterModal = openRegisterModal;
}
function setXPProgress(old_user, disable_xp_notif = false, force_update = false) {
    if (!user.xp) user.xp = 0;
    if (!user.level) user.level = 0;

    const total_xp = user.xp;
    const xp = Math.min(total_xp - old_user.xp, old_user.xp_required);

    updateLevel();
    updateXPDisplay();

    if (xp > 0 || force_update) {
        const diff = (xp / old_user.xp_required) * 100;
        const new_value = (total_xp / old_user.xp_required) * 100;

        const xp_bar_progress_visual = DOM.get("xp_bar_progress_visual");
        const xp_bar_progress = DOM.get("xp_bar_progress");

        xp_bar_progress_visual.style.width = diff + "%";
        xp_bar_progress_visual.style.left = (new_value - diff) + "%";

        if (!disable_xp_notif) {
            notify.showXP(xp);

            setTimeout(() => {
                if (old_user.level < user.level) {
                    notify.levelUp(user.level);
                    setXPProgress(window.user, true, true);
                }
            }, 1500);
        }

        setTimeout(() => {
            xp_bar_progress.style.width = new_value + "%";
            xp_bar_progress_visual.style.width = "0%";
            xp_bar_progress_visual.style.left = new_value + "%";
        }, 300);
    }
}

function updateLevel() {
    const level_elements = document.getElementsByClassName("xp_level");
    for (let i = 0; i < level_elements.length; i++) {
        level_elements[i].textContent = user.level;
    }

    const xp_level_elements = document.getElementsByClassName("xp-level");
    for (let i = 0; i < xp_level_elements.length; i++) {
        xp_level_elements[i].textContent = user.level;
    }
}

function updateXPDisplay() {
    const username = DOM.query('.xp-username');

    if (username) username.textContent = user.username || 'username';

    const oldUsername = DOM.query('.username');
    if (oldUsername) oldUsername.textContent = user.username || 'username';
}
async function updateSDKUserInfo() {
    if (!isRunningInTauri() || !window.user) return;

    try {
        let avatarHash = null;
        if (window.user.avatar) {
            avatarHash = window.user.avatar;
        } else if (window.user.avatar_url) {
            const match = window.user.avatar_url.match(/avatars\/\d+\/([^.]+)/);
            if (match) {
                avatarHash = match[1];
            }
        }

        await window.__TAURI__.core.invoke('update_sdk_user_info', {
            userId: window.user.id,
            username: window.user.username,
            level: window.user.level || 0,
            xp: window.user.xp || 0,
            xpRequired: window.user.xp_required || 700,
            avatar: avatarHash
        });

        console.log('SDK user info updated');
    } catch (error) {
        console.error('Failed to update SDK user info:', error);
    }
}

async function clearSDKUserInfo() {
    if (!isRunningInTauri()) return;

    try {
        await window.__TAURI__.core.invoke('clear_sdk_user_info');
        console.log('SDK user info cleared');
    } catch (error) {
        console.error('Failed to clear SDK user info:', error);
    }
}

async function getSDKConnectedSessions() {
    if (!isRunningInTauri()) return [];

    try {
        const sessions = await window.__TAURI__.core.invoke('get_sdk_connected_sessions');
        return sessions;
    } catch (error) {
        console.error('Failed to get connected sessions:', error);
        return [];
    }
}

async function monitorSDKConnections() {
    if (!isRunningInTauri()) return;

    setInterval(async () => {
        const sessions = await getSDKConnectedSessions();
        if (sessions.length > 0) {
            console.log(`Games connected via SDK: ${sessions.length}`);
        }
    }, 30000);
}

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        monitorSDKConnections();
    });
}
function createStorePage(content) {
    return `
    <section id="store-page" class="store-container" style="display:none;">
        <button id="store_menu_btn" class="create-post-btn glass_bt" onclick="openMenu()"><i class="fa-solid fa-bars"></i></button>

        <div class="store-header">
            <div class="store-header-content">
                <div class="store-title-section">
                    <h1 class="store-title">RSPWN</h1>
                    <p class="store-subtitle">Discover amazing games and digital content</p>
                </div>
                <div class="store-header-search">
                    <div class="search-input-wrapper">
                        <i class="fa-solid fa-search search-icon"></i>
                        <input type="text" class="store-search-input" placeholder="Search games..." id="store-search-input">
                    </div>
                </div>
            </div>
        </div>

        <div class="store-body">
            <div class="store-content">
                ${content}
            </div>
        </div>
    </section>`;
}

function openStorePage() {
    let storePage = DOM.get('store-page');
    const feed = DOM.get('feed');

   
    if (!storePage) {
        const storeContent = createStoreContent();
        const storePageHTML = createStorePage(storeContent);

       
        const main = document.querySelector('main');
        if (main) {
            main.insertAdjacentHTML('beforeend', storePageHTML);
            storePage = DOM.get('store-page');
        }
    }

    if (storePage && feed) {
       
        feed.style.display = 'none';
        storePage.style.display = 'flex';

       
        const storeBody = storePage.querySelector('.store-body');
        if (storeBody) {
            storeBody.scrollTop = 0;
        }

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'store'}, 'Game Store - VAPR', '/store');
        }

       
        document.title = 'Game Store - VAPR';

       
        setTimeout(() => {
            initializeStore();
        }, 100);
    }
}

function closeStorePage() {
    const storePage = DOM.get('store-page');
    const feed = DOM.get('feed');

    if (storePage && feed) {
       
        storePage.style.display = 'none';
        feed.style.display = 'block';

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'home'}, 'RSPWN - The Gamer\'s Social Network', '/');
        }

       
        document.title = 'RSPWN';
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const path = window.location.pathname;
    if (path === '/store') {
       
        setTimeout(() => {
            openStorePage();
        }, 100);
    }
});

function createStoreContent() {
    return `
        <div class="featured-carousel-section">
            ${createFeaturedCarousel()}
        </div>

        <div class="store-filters" id="store-filters">
            ${createStoreFilters()}
        </div>

        <div class="store-grid" id="store-grid">
            ${createStoreGrid()}
        </div>
    `;
}

function createFeaturedCarousel() {
    const featuredGames = [
        {
            id: 'featured-1',
            title: 'Cyber Warriors 2077',
            description: 'Experience the ultimate cyberpunk adventure in a dystopian future. Battle through neon-lit streets, hack corporate systems, and uncover dark conspiracies that threaten humanity\'s last hope.',
            price: '$29.99',
            originalPrice: '$59.99',
            discount: '50%',
            category: 'action',
            rating: '4.8',
            reviews: '2.1k',
            image: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            backgroundImage: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            badge: 'featured',
            tags: ['Action', 'RPG', 'Cyberpunk', 'Open World']
        },
        {
            id: 'featured-2',
            title: 'Mystic Realms',
            description: 'Embark on an epic fantasy journey through magical worlds filled with ancient mysteries. Discover powerful artifacts, battle mythical creatures, and shape the destiny of entire realms.',
            price: '$24.99',
            originalPrice: '$39.99',
            discount: '37%',
            category: 'adventure',
            rating: '4.6',
            reviews: '1.8k',
            image: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            backgroundImage: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            badge: 'new',
            tags: ['Adventure', 'Fantasy', 'Magic', 'Story Rich']
        },
        {
            id: 'featured-3',
            title: 'Space Colony Alpha',
            description: 'Build and manage thriving colonies across the galaxy. Master resource management, research cutting-edge technologies, and ensure the survival of humanity among the stars.',
            price: '$27.99',
            originalPrice: '$44.99',
            discount: '38%',
            category: 'strategy',
            rating: '4.5',
            reviews: '780',
            image: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            backgroundImage: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            badge: 'featured',
            tags: ['Strategy', 'Simulation', 'Space', 'Colony Management']
        }
    ];

    return `
        <div class="featured-carousel">
            <div class="featured-main" id="featured-main">
                ${createFeaturedMainDisplay(featuredGames[0])}
            </div>
            <div class="featured-sidebar">
                <h3 class="featured-sidebar-title">Featured Games</h3>
                <div class="featured-list" id="featured-list">
                    ${featuredGames.map((game, index) => createFeaturedListItem(game, index)).join('')}
                </div>
            </div>
        </div>
    `;
}

function createFeaturedMainDisplay(game) {
    return `
        <div class="featured-main-bg" style="background-image: url('${game.image}')"></div>
        <div class="featured-main-overlay"></div>
        <div class="featured-main-content">
            <div class="featured-game-info">
                <h1 class="featured-title">${game.title}</h1>
                <div class="featured-price-section">
                    <div class="featured-discount">-${game.discount}</div>
                    <div class="featured-prices">
                        <span class="featured-original-price">${game.originalPrice}</span>
                        <span class="featured-current-price">${game.price}</span>
                    </div>
                </div>
                <div class="featured-actions">
                    <button class="featured-buy-btn" onclick="purchaseGame('${game.id}')">
                        <i class="fa-solid fa-shopping-cart"></i>
                        Buy Now
                    </button>
                    <button class="featured-wishlist-btn" onclick="addToWishlist('${game.id}')">
                        <i class="fa-solid fa-heart"></i>
                        Wishlist
                    </button>
                </div>
            </div>
        </div>
    `;
}

function createFeaturedListItem(game, index) {
    return `
        <div class="featured-list-item ${index === 0 ? 'active' : ''}" data-game-index="${index}" onclick="selectFeaturedGame(${index})">
            <div class="featured-item-image">
                <img src="${game.image}" alt="${game.title}" loading="lazy">
            </div>
            <div class="featured-item-info">
                <h4 class="featured-item-title">${game.title}</h4>
                <div class="featured-item-price">${game.price}</div>
            </div>
            <div class="featured-item-progress">
                <div class="progress-bar" id="progress-${index}">
                    <div class="progress-fill"></div>
                </div>
            </div>
        </div>
    `;
}

function createStoreFilters() {
    const filters = [
        { category: 'all', label: 'All Games', active: true },
        { category: 'action', label: 'Action', active: false },
        { category: 'adventure', label: 'Adventure', active: false },
        { category: 'strategy', label: 'Strategy', active: false },
        { category: 'indie', label: 'Indie', active: false },
        { category: 'featured', label: 'Featured', active: false }
    ];

    return filters.map(filter =>
        `<store-filter category="${filter.category}" label="${filter.label}" ${filter.active ? 'active="true"' : ''}></store-filter>`
    ).join('');
}

function createStoreGrid() {
    const mockGames = [
        {
            id: 'game-1',
            title: 'Cyber Warriors 2077',
            description: 'An epic cyberpunk adventure in a dystopian future. Battle through neon-lit streets and uncover corporate conspiracies.',
            price: '$29.99',
            category: 'action',
            rating: '4.8',
            reviews: '2.1k',
            image: 'https://via.placeholder.com/300x180/0066cc/ffffff?text=Cyber+Warriors',
            badge: 'featured',
            isFeatured: true
        },
        {
            id: 'game-2',
            title: 'Mystic Realms',
            description: 'Explore magical worlds filled with ancient mysteries and powerful artifacts. Your destiny awaits.',
            price: '$24.99',
            category: 'adventure',
            rating: '4.6',
            reviews: '1.8k',
            image: 'https://via.placeholder.com/300x180/8b5cf6/ffffff?text=Mystic+Realms',
            badge: 'new'
        },
        {
            id: 'game-3',
            title: 'Empire Builder',
            description: 'Build and manage your own civilization. Lead armies, research technologies, and conquer new lands.',
            price: '$34.99',
            category: 'strategy',
            rating: '4.7',
            reviews: '950',
            image: 'https://via.placeholder.com/300x180/059669/ffffff?text=Empire+Builder',
            badge: ''
        },
        {
            id: 'game-4',
            title: 'Neon Racer',
            description: 'High-speed racing through futuristic cities. Customize your vehicle and dominate the competition.',
            price: '$19.99',
            category: 'action',
            rating: '4.4',
            reviews: '1.2k',
            image: 'https://via.placeholder.com/300x180/dc2626/ffffff?text=Neon+Racer',
            badge: ''
        },
        {
            id: 'game-5',
            title: 'Pixel Quest',
            description: 'A charming indie adventure with retro graphics and modern gameplay. Perfect for casual gaming sessions.',
            price: '$14.99',
            category: 'indie',
            rating: '4.9',
            reviews: '3.4k',
            image: 'https://via.placeholder.com/300x180/f59e0b/ffffff?text=Pixel+Quest',
            badge: 'featured',
            isFeatured: true
        },
        {
            id: 'game-6',
            title: 'Space Colony Alpha',
            description: 'Manage resources and build thriving colonies across the galaxy. The future of humanity is in your hands.',
            price: '$27.99',
            category: 'strategy',
            rating: '4.5',
            reviews: '780',
            image: 'https://via.placeholder.com/300x180/7c3aed/ffffff?text=Space+Colony',
            badge: 'new'
        },
        {
            id: 'game-7',
            title: 'Shadow Legends',
            description: 'An epic fantasy RPG with deep character customization and engaging storylines.',
            price: '$39.99',
            category: 'adventure',
            rating: '4.3',
            reviews: '2.7k',
            image: 'https://via.placeholder.com/300x180/1f2937/ffffff?text=Shadow+Legends',
            badge: ''
        },
        {
            id: 'game-8',
            title: 'Retro Arcade Mix',
            description: 'A collection of classic arcade games reimagined for modern players. Nostalgia meets innovation.',
            price: '$12.99',
            category: 'indie',
            rating: '4.6',
            reviews: '1.5k',
            image: 'https://via.placeholder.com/300x180/ec4899/ffffff?text=Retro+Arcade',
            badge: ''
        }
    ];

    return mockGames.map(game => createStoreItem(game)).join('');
}

function createStoreItem(game) {
    const stars = '★'.repeat(Math.floor(parseFloat(game.rating)));

    return `<store-item
        id="${game.id}"
        title="${game.title}"
        description="${game.description}"
        price="${game.price}"
        category="${game.category}"
        rating="${game.rating}"
        reviews="${game.reviews}"
        image="${game.image}"
        stars="${stars}"
        ${game.badge ? `badge="${game.badge}"` : ''}
    ></store-item>`;
}

function initializeStore() {
   
    setTimeout(() => {
        initializeStoreFilters();
        initializeStoreSearch();
        initializeFeaturedCarousel();
    }, 100);
}

function initializeStoreFilters() {
   
    const filterBtns = document.querySelectorAll('.store-filter-btn');
    filterBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            const category = this.dataset.category;
            filterGames(category);

           
            filterBtns.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
        });
    });
}

function initializeStoreSearch() {
   
    const searchInput = document.getElementById('store-search-input');
    const mobileSearchInput = document.getElementById('store-search-mobile-input');

    if (searchInput) {
        searchInput.addEventListener('input', function() {
            searchGames(this.value);
        });
    }

    if (mobileSearchInput) {
        mobileSearchInput.addEventListener('input', function() {
            searchGames(this.value);
        });
    }

   
    if (window.innerWidth <= 768) {
        const mobileSearch = document.querySelector('.store-search-mobile');
        if (mobileSearch) {
            mobileSearch.style.display = 'block';
        }
    }
}

function filterGames(category) {
    const storeItems = document.querySelectorAll('.store-item');

    storeItems.forEach(item => {
        if (category === 'all' || item.dataset.category === category) {
            item.style.display = 'block';
        } else {
            item.style.display = 'none';
        }
    });
}

function searchGames(query) {
    const storeItems = document.querySelectorAll('.store-item');
    const lowercaseQuery = query.toLowerCase();

    storeItems.forEach(item => {
        const title = item.querySelector('.store-item-title').textContent.toLowerCase();
        const description = item.querySelector('.store-item-description').textContent.toLowerCase();
        const category = item.dataset.category.toLowerCase();

        if (title.includes(lowercaseQuery) ||
            description.includes(lowercaseQuery) ||
            category.includes(lowercaseQuery)) {
            item.style.display = 'block';
        } else {
            item.style.display = 'none';
        }
    });
}

function purchaseGame(gameId) {
   
    alert(`Purchase functionality for game ${gameId} would be implemented here`);
}


function addToWishlist(gameId) {
   
    alert(`Added ${gameId} to wishlist`);
}

let currentFeaturedIndex = 0;
let carouselInterval;
let progressIntervals = [];
const CAROUSEL_DURATION = 8000;

function initializeFeaturedCarousel() {
    const featuredGames = getFeaturedGamesData();

    if (featuredGames.length === 0) return;

   
    startCarouselTimer();

   
    startProgressBars();
}

function getFeaturedGamesData() {
   
    return [
        {
            id: 'featured-1',
            title: 'Cyber Warriors 2077',
            description: 'Experience the ultimate cyberpunk adventure in a dystopian future. Battle through neon-lit streets, hack corporate systems, and uncover dark conspiracies that threaten humanity\'s last hope.',
            price: '$29.99',
            originalPrice: '$59.99',
            discount: '50%',
            category: 'action',
            rating: '4.8',
            reviews: '2.1k',
            image: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            backgroundImage: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            badge: 'featured',
            tags: ['Action', 'RPG', 'Cyberpunk', 'Open World']
        },
        {
            id: 'featured-2',
            title: 'Mystic Realms',
            description: 'Embark on an epic fantasy journey through magical worlds filled with ancient mysteries. Discover powerful artifacts, battle mythical creatures, and shape the destiny of entire realms.',
            price: '$24.99',
            originalPrice: '$39.99',
            discount: '37%',
            category: 'adventure',
            rating: '4.6',
            reviews: '1.8k',
            image: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            backgroundImage: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            badge: 'new',
            tags: ['Adventure', 'Fantasy', 'Magic', 'Story Rich']
        },
        {
            id: 'featured-3',
            title: 'Space Colony Alpha',
            description: 'Build and manage thriving colonies across the galaxy. Master resource management, research cutting-edge technologies, and ensure the survival of humanity among the stars.',
            price: '$27.99',
            originalPrice: '$44.99',
            discount: '38%',
            category: 'strategy',
            rating: '4.5',
            reviews: '780',
            image: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            backgroundImage: 'https://vapr-club.b-cdn.net/posts/0c31c343-a6ab-4e3d-937f-ae6bc757e9df.png',
            badge: 'featured',
            tags: ['Strategy', 'Simulation', 'Space', 'Colony Management']
        }
    ];
}

function selectFeaturedGame(index) {
    const featuredGames = getFeaturedGamesData();

    if (index < 0 || index >= featuredGames.length) return;

    currentFeaturedIndex = index;

   
    updateFeaturedMainDisplay(featuredGames[index]);

   
    updateFeaturedListActive(index);

   
    resetCarouselTimer();
    resetProgressBars();
    startProgressBars();
}

function updateFeaturedMainDisplay(game) {
    const mainDisplay = document.getElementById('featured-main');
    if (mainDisplay) {
        mainDisplay.innerHTML = createFeaturedMainDisplay(game);
    }
}

function updateFeaturedListActive(activeIndex) {
    const listItems = document.querySelectorAll('.featured-list-item');
    listItems.forEach((item, index) => {
        if (index === activeIndex) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });
}

function startCarouselTimer() {
    carouselInterval = setInterval(() => {
        const featuredGames = getFeaturedGamesData();
        currentFeaturedIndex = (currentFeaturedIndex + 1) % featuredGames.length;
        selectFeaturedGame(currentFeaturedIndex);
    }, CAROUSEL_DURATION);
}

function resetCarouselTimer() {
    if (carouselInterval) {
        clearInterval(carouselInterval);
    }
    startCarouselTimer();
}

function startProgressBars() {
    const featuredGames = getFeaturedGamesData();

   
    progressIntervals.forEach(interval => clearInterval(interval));
    progressIntervals = [];

   
    featuredGames.forEach((_, index) => {
        const listItem = document.querySelector(`.featured-list-item[data-game-index="${index}"]`);
        if (listItem) {
            listItem.style.setProperty('--progress-width', '0%');
        }
    });

   
    startProgressForItem(currentFeaturedIndex);
}

function startProgressForItem(index) {
    const listItem = document.querySelector(`.featured-list-item[data-game-index="${index}"]`);
    if (!listItem) return;

    let progress = 0;
    const increment = 100 / (CAROUSEL_DURATION / 50);

    const interval = setInterval(() => {
        progress += increment;
        const progressWidth = Math.min(progress, 100);
        listItem.style.setProperty('--progress-width', `${progressWidth}%`);

        if (progress >= 100) {
            clearInterval(interval);
        }
    }, 50);

    progressIntervals.push(interval);
}

function resetProgressBars() {
   
    progressIntervals.forEach(interval => clearInterval(interval));
    progressIntervals = [];

   
    const featuredGames = getFeaturedGamesData();
    featuredGames.forEach((_, index) => {
        const listItem = document.querySelector(`.featured-list-item[data-game-index="${index}"]`);
        if (listItem) {
            listItem.style.setProperty('--progress-width', '0%');
        }
    });
}

if (typeof window.VAPR !== 'undefined') {
   
    VAPR.on('store-filter', 'mounted', (element) => {
        element.addEventListener('click', function() {
            const category = this.dataset.category;
            filterGames(category);

           
            const filterBtns = document.querySelectorAll('.store-filter-btn');
            filterBtns.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
        });
    });

   
    VAPR.on('store-item', 'mounted', (element) => {
       
        console.log('Store item mounted:', element.dataset.gameId);
    });
}

if (typeof window !== 'undefined') {
    window.openStorePage = openStorePage;
    window.closeStorePage = closeStorePage;
    window.purchaseGame = purchaseGame;
    window.addToWishlist = addToWishlist;
    window.selectFeaturedGame = selectFeaturedGame;
}
class TebexAPI {
    constructor() {
        this.baseURL = 'https://headless.tebex.io/api';
        this.configs = [];
    }

    async loadConfigs() {
        try {
            const response = await fetch('/api/tebex-configs', {
                credentials: 'include'
            });
            const data = await response.json();
            if (data.success) {
                this.configs = data.configs;
            }
        } catch (error) {
            console.error('Failed to load Tebex configurations:', error);
        }
    }

    async request(path, options = {}, webstoreToken = null) {
        const url = `${this.baseURL}${path}`;

        try {
            const response = await fetch(url, {
                ...options,
                headers: {
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            });

            if (!response.ok) {
                throw new Error(`Tebex API error: ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Tebex API request failed:', error);
            throw error;
        }
    }

    async getAllPackages() {
        await this.loadConfigs();

        const allPackages = [];

        for (const config of this.configs) {
            try {
                const response = await this.request(`/accounts/${config.webstoreToken}/packages`);
                const packages = response.data || [];

                const packagesWithStore = packages.map(pkg => ({
                    ...pkg,
                    storeInfo: {
                        userId: config.userId,
                        username: config.username,
                        storeName: config.storeName,
                        webstoreToken: config.webstoreToken
                    }
                }));

                allPackages.push(...packagesWithStore);
            } catch (error) {
                console.error(`Failed to load packages for store ${config.storeName}:`, error);
            }
        }

        return { data: allPackages };
    }

    async applyCreatorCode(basketIdent, creatorCode, webstoreToken) {
        return this.request(`/accounts/${webstoreToken}/baskets/${basketIdent}/creator-codes`, {
            method: 'POST',
            body: JSON.stringify({
                creator_code: creatorCode
            })
        });
    }
}

window.tebexAPI = new TebexAPI();
function handleCheckoutSuccess() {
    notify.success('Purchase completed successfully!');

    if (window.loadLibraryData) {
        loadLibraryData();
    }
}

function handleCheckoutCancel() {
    notify.info('Checkout cancelled');
}

document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);

    if (window.location.pathname === '/checkout/success') {
        handleCheckoutSuccess();
        window.history.replaceState({}, '', '/');
    } else if (window.location.pathname === '/checkout/cancel') {
        handleCheckoutCancel();
        window.history.replaceState({}, '', '/');
    }
});
function openTermsPage() {
    let termsPage = DOM.get('terms-page');
    const feed = DOM.get('feed');

   
    if (!termsPage) {
        const termsContent = createTermsContent();
        const termsPageHTML = createLegalPage({
            pageId: 'terms-page',
            pageTitle: 'Terms of Service',
            lastUpdated: 'Last updated: January 17, 2025',
            version: '1.0',
            closeFunction: 'closeTermsPage',
            content: termsContent
        });

       
        const main = document.querySelector('main');
        if (main) {
            main.insertAdjacentHTML('beforeend', termsPageHTML);
            termsPage = DOM.get('terms-page');
        }
    }

    if (termsPage && feed) {
       
        feed.style.display = 'none';
        termsPage.style.display = 'flex';

       
        const termsBody = termsPage.querySelector('.legal-body');
        if (termsBody) {
            termsBody.scrollTop = 0;
        }

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'terms'}, 'Terms of Service - VAPR', '/terms');
        }

       
        document.title = 'Terms of Service - VAPR';
    }
}

function closeTermsPage() {
    const termsPage = DOM.get('terms-page');
    const feed = DOM.get('feed');

    if (termsPage && feed) {
       
        termsPage.style.display = 'none';
        feed.style.display = 'block';

       
        if (window.history && window.history.pushState) {
            window.history.pushState({page: 'home'}, 'VAPR - The Gamer\'s Social Network', '/');
        }

       
        document.title = 'VAPR';
    }
}

window.addEventListener('popstate', function(event) {
    const path = window.location.pathname;

    if (path === '/terms') {
        openTermsPage();
    } else if (path === '/privacy') {
       
        if (typeof window.openPrivacyPage === 'function') {
            window.openPrivacyPage();
        }
    } else if (path === '/store') {
       
        if (typeof window.openStorePage === 'function') {
            window.openStorePage();
        }
    } else {
       
        const termsPage = DOM.get('terms-page');
        const privacyPage = DOM.get('privacy-page');
        const storePage = DOM.get('store-page');

        if (termsPage && termsPage.style.display !== 'none') {
            closeTermsPage();
        }
        if (privacyPage && privacyPage.style.display !== 'none') {
            if (typeof window.closePrivacyPage === 'function') {
                window.closePrivacyPage();
            }
        }
        if (storePage && storePage.style.display !== 'none') {
            if (typeof window.closeStorePage === 'function') {
                window.closeStorePage();
            }
        }
    }
});

document.addEventListener('DOMContentLoaded', function() {
    const path = window.location.pathname;
    if (path === '/terms') {
       
        setTimeout(() => {
            openTermsPage();
        }, 100);
    }
});

function createTermsContent() {
    return `
        ${createLegalSection('1. Acceptance of Terms', `
            <p>By accessing and using VAPR ("the Service"), you accept and agree to be bound by the terms and provision of this agreement. If you do not agree to abide by the above, please do not use this service.</p>
        `)}

        ${createLegalSection('2. Description of Service', `
            <p>VAPR is a gamified social platform where creators share content through a swipe-based interface. The platform includes user authentication via Discord, content posting with reactions, an XP/leveling system, and multiple specialized dashboards.</p>
            ${createLegalList([
                'Social content sharing and discovery',
                'Gamification features including XP and leveling',
                'Creator tools and analytics',
                'Game integration and digital marketplace'
            ])}
        `)}

        ${createLegalSection('3. User Accounts', `
            <p>To access certain features of the Service, you must create an account using Discord authentication. You are responsible for:</p>
            ${createLegalList([
                'Maintaining the confidentiality of your account',
                'All activities that occur under your account',
                'Notifying us immediately of any unauthorized use',
                'Ensuring your account information is accurate and up-to-date'
            ])}
        `)}

        ${createLegalSection('4. Content Guidelines', `
            <p>Users are responsible for all content they post. Prohibited content includes:</p>
            ${createLegalList([
                'Illegal, harmful, or offensive material',
                'Content that violates intellectual property rights',
                'Spam, harassment, or abusive behavior',
                'Adult content or material inappropriate for all audiences',
                'False or misleading information'
            ])}
            <p>We reserve the right to remove content and suspend accounts that violate these guidelines.</p>
        `)}

        ${createLegalSection('5. Creator Program', `
            <p>Our Creator Program allows eligible users to monetize their content. Participation requires:</p>
            ${createLegalList([
                'Compliance with all platform guidelines',
                'Original, high-quality content creation',
                'Active engagement with the community',
                'Valid payment information for revenue sharing'
            ])}
            <p>Creator Program terms may change with notice to participants.</p>
        `)}

        ${createLegalSection('6. Game Integration', `
            <p>VAPR integrates with various games and digital platforms. Users acknowledge:</p>
            ${createLegalList([
                'Game keys and digital items are subject to third-party terms',
                'We are not responsible for external platform policies',
                'Digital purchases are final and non-refundable unless required by law',
                'Game availability may change without notice'
            ])}
        `)}

        ${createLegalSection('7. Privacy and Data', `
            <p>Your privacy is important to us. Please review our Privacy Policy for details on how we collect, use, and protect your information. By using VAPR, you consent to our data practices as outlined in our Privacy Policy.</p>
        `)}

        ${createLegalSection('8. Intellectual Property', `
            <p>The Service and its original content, features, and functionality are owned by VAPR and are protected by international copyright, trademark, patent, trade secret, and other intellectual property laws.</p>
        `)}

        ${createLegalSection('9. Limitation of Liability', `
            <p>In no event shall VAPR, its directors, employees, partners, agents, suppliers, or affiliates be liable for any indirect, incidental, special, consequential, or punitive damages, including without limitation, loss of profits, data, use, goodwill, or other intangible losses.</p>
        `)}

        ${createLegalSection('10. Termination', `
            <p>We may terminate or suspend your account and bar access to the Service immediately, without prior notice or liability, under our sole discretion, for any reason whatsoever, including without limitation if you breach the Terms.</p>
        `)}

        ${createLegalSection('11. Changes to Terms', `
            <p>We reserve the right to modify or replace these Terms at any time. If a revision is material, we will provide at least 30 days notice prior to any new terms taking effect.</p>
        `)}
    `;
}

if (typeof window !== 'undefined') {
    window.openTermsPage = openTermsPage;
    window.closeTermsPage = closeTermsPage;
}
document.addEventListener('DOMContentLoaded', (event) => {
    const post = document.getElementsByClassName("post")[0];
    let startX = 0;
    let startY = 0;
    let currentX = 0;
    let currentY = 0;
    let startTime = 0;

    post.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        currentX = startX;
        currentY = startY;
        startTime = new Date().getTime();
        post.style.transition = 'none';
        post.style.animation = 'none';
    });

    post.addEventListener('touchmove', (e) => {
        currentX = e.touches[0].clientX;
        currentY = e.touches[0].clientY;
        let changeX = currentX - startX;
        let changeY = currentY - startY;
        post.style.transform = `translate(${changeX}px, ${changeY}px) rotate(${changeX * 0.1}deg)`;
    });

    post.addEventListener('touchend', (e) => {
        let changeX = currentX - startX;
        let changeY = currentY - startY;
        let elapsedTime = new Date().getTime() - startTime;
        let velocity = Math.abs(changeX) / elapsedTime;
        let velocityy = Math.abs(changeY) / elapsedTime;

        if (velocity > 0.3 || Math.abs(changeX) > 100) {
            if (changeX < -100) {
                dislikePost();
            } else if (changeX > 100) {
                likePost();
            }
        }else if (velocityy > 0.3 || Math.abs(changeY) > 100) {
            if (changeY < -100) {
                skipPost();
            }
        } else {
            resetPostPosition();
        }
    });

    function resetPostPosition() {
        post.style.transition = 'transform 0.3s ease';
        post.style.transform = 'translate(0px, 0px) rotate(0deg)';
    }
});

function setInitialTransform(post) {
    const transform = post.style.transform || '';

    let translateX = 0;
    let translateY = 0;
    let rotate = 0;

    if (transform) {
        const translateMatch = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
        if (translateMatch) {
            translateX = parseInt(translateMatch[1]) || 0;
            translateY = parseInt(translateMatch[2]) || 0;
        }

        const rotateMatch = transform.match(/rotate\(([^)]+)\)/);
        if (rotateMatch) {
            rotate = parseInt(rotateMatch[1]) || 0;
        }
    }

    console.log({
        translateX: translateX,
        translateY: translateY,
        rotate: rotate
    });

    post.style.setProperty('--start-translate-x', `${translateX}px`);
    post.style.setProperty('--start-translate-y', `${translateY}px`);
    post.style.setProperty('--start-rotate', `${rotate}deg`);

    post.style.transform = "translateY(100vh)";
    post.style.transition = 'all 1s ease-in-out';
}

function displayLikeAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'swipeRight 0.6s';
    post.style.transform = "translateY(100vh)";

    notify.showActionFeedback('liked');

    confetti({
        particleCount: 100,
        spread: 70,
        origin: { y: 0.6 },
        colors: ['#22c55e', '#10b981', '#059669']
    });
}

function displayDislikeAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'swipeLeft 0.6s';
    post.style.transform = "translateY(100vh)";

    notify.showActionFeedback('passed');
}

function displaySkipAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'skip 0.6s';
    post.style.transform = "translateY(100vh)";

    notify.showActionFeedback('skipped');
}

function likePost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displayLikeAnimation();
        APIHandler.handle(
            () => api.likePost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displayLikeAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}

function skipPost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displaySkipAnimation();
        APIHandler.handle(
            () => api.skipPost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displaySkipAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}

function dislikePost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displayDislikeAnimation();
        APIHandler.handle(
            () => api.dislikePost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displayDislikeAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}
const uploadArea = DOM.query('.upload-area');
const fileInput = DOM.get('file');

if (uploadArea) {
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        uploadArea.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
        uploadArea.addEventListener(eventName, () => {
            uploadArea.classList.add('dragging');
        }, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
        uploadArea.addEventListener(eventName, () => {
            uploadArea.classList.remove('dragging');
        }, false);
    });

    uploadArea.addEventListener('drop', handleDrop, false);

    function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;

        if (files.length > 0) {
            fileInput.files = files;
            handleFileSelect(files[0]);
        }
    }
}

if (fileInput) {
    fileInput.addEventListener('change', function() {
        if (this.files && this.files[0]) {
            handleFileSelect(this.files[0]);
        }
    });
}

function handleFileSelect(file) {
    const fileType = file.type;
    const placeholder = DOM.get('upload-placeholder');
    const preview = DOM.get('upload-preview');
    const previewImage = DOM.get('preview_img');
    const previewVideo = DOM.get('preview_video');

    if (file.size > 50 * 1024 * 1024) {
        notify.error('File too large', 'Please select a file under 50MB');
        return;
    }

    const reader = new FileReader();
    reader.onload = function(e) {
        DOM.hide(placeholder);
        DOM.show(preview);

        if (fileType.startsWith('video/')) {
            previewVideo.src = e.target.result;
            DOM.show(previewVideo);
            DOM.hide(previewImage);
        } else if (fileType.startsWith('image/')) {
            previewImage.src = e.target.result;
            DOM.show(previewImage);
            DOM.hide(previewVideo);
        } else {
            notify.error('Invalid file type', 'Please upload an image or video file');
            DOM.show(placeholder, 'flex');
            DOM.hide(preview);
            return;
        }
    };
    reader.readAsDataURL(file);
}

const titleInput = DOM.get('title');
const titleCount = DOM.get('title-count');

if (titleInput && titleCount) {
    titleInput.addEventListener('input', function() {
        titleCount.textContent = this.value.length;
    });
}

let selectedGameForTag = null;

window.openGameTagModal = async function() {
    DOM.show('game-tag-modal', 'flex');
    await loadGamesForTagging();
}

window.closeGameTagModal = function() {
    DOM.hide('game-tag-modal');
}

window.selectGameForTag = function(gameId, gameTitle, gameCover) {
    selectedGameForTag = {
        id: gameId,
        title: gameTitle,
        coverImage: gameCover
    };

    DOM.hide('game-tag-button');
    DOM.show('selected-game', 'flex');
    DOM.get('selected-game-title').textContent = gameTitle;
    DOM.get('selected-game-cover').src = gameCover;

    closeGameTagModal();
}

window.removeGameTag = function() {
    selectedGameForTag = null;
    DOM.show('game-tag-button', 'inline-flex');
    DOM.hide('selected-game');
}

async function loadGamesForTagging() {
    try {
        const response = await api.request('/api/games');
        if (response.success) {
            displayGamesForTagging(response.games);
        }
    } catch (error) {
        console.error('Error loading games:', error);
    }
}

function displayGamesForTagging(games) {
    const container = DOM.get('game-tag-list');
    container.innerHTML = '';

    games.forEach(game => {
        const gameItem = DOM.create('div', {
            class: 'game-tag-item',
            onclick: () => selectGameForTag(game.id, game.title, game.coverImage)
        });

        gameItem.innerHTML = `
            <img src="${game.coverImage}" alt="${game.title}" class="game-tag-item-cover">
            <span class="game-tag-item-title">${game.title}</span>
        `;

        container.appendChild(gameItem);
    });
}

window.searchGamesForTag = function() {
    const searchTerm = DOM.get('game-tag-search').value.toLowerCase();
    const items = DOM.queryAll('.game-tag-item');

    items.forEach(item => {
        const title = item.querySelector('.game-tag-item-title').textContent.toLowerCase();
        if (title.includes(searchTerm)) {
            DOM.show(item, 'flex');
        } else {
            DOM.hide(item);
        }
    });
}

window.submitPost = async function(event) {
    event.preventDefault();

    const submitBtn = DOM.get('submit-post-btn');
    const uploadProgress = DOM.get('upload-progress');
    const progressFill = DOM.get('progress-fill');

    const title = DOM.get('title').value;
    const file = DOM.get('file').files[0];

    if (!file) {
        notify.warning('No media selected', 'Please select an image or video to upload');
        return;
    }

    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> <span>Publishing...</span>';

    const formData = new FormData();
    formData.append('title', title);

    if (selectedGameForTag) {
        formData.append('taggedGameId', selectedGameForTag.id);
    }

    if (file) {
        const fileExtension = file.name.split('.').pop();
        const fileName = `${new Date().getTime()}.${fileExtension}`;
        const fileContentType = file.type || 'application/octet-stream';
        const blob = new Blob([file], { type: fileContentType });
        formData.append("file", blob, fileName);
    }

    try {
        DOM.show(uploadProgress);

        let progress = 0;
        const progressInterval = setInterval(() => {
            progress += Math.random() * 15;
            if (progress > 90) progress = 90;
            progressFill.style.width = progress + '%';
        }, 200);

        const result = await api.createPost(formData);

        clearInterval(progressInterval);
        progressFill.style.width = '100%';

        if (result.success || result.id) { 
            confetti({
                particleCount: 100,
                spread: 70,
                origin: { y: 0.6 }
            });

           
            DOM.get('title').value = '';
            DOM.get('file').value = '';
            DOM.show('upload-placeholder', 'flex');
            DOM.hide('upload-preview');
            const titleCount = DOM.get('title-count');
            if (titleCount) {
                titleCount.textContent = '0';
            }

            removeGameTag();

            notify.success("Post published successfully!");

           
            if (window.user && result.user) {
                const oldUser = {
                    xp: window.user.xp,
                    level: window.user.level,
                    xp_required: window.user.xp_required
                };

                window.user = result.user;
                setXPProgress(oldUser);
            }

           
            closeAddPostCard();

           
            setTimeout(() => {
                router.navigate(`/post/${result.id}`, true);
            }, 300);

        } else {
            throw new Error(result.error || 'Failed to create post');
        }

    } catch (error) {
        console.error('Failed to submit post:', error);
        notify.error('Upload failed', error.message || 'Failed to create post. Please try again.');

    } finally {
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="fa-solid fa-paper-plane"></i> <span>Publish Post</span>';
        DOM.hide(uploadProgress);
        progressFill.style.width = '0%';
    }
}
const AnimationUtils = {
    animateCounter(element, start, end, duration = 1000, formatter = null) {
        if (!element) return;

        const startTime = performance.now();
        const defaultFormatter = (val) => this.formatNumber(val);
        const format = formatter || defaultFormatter;

        const updateCounter = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            const easeOutQuart = 1 - Math.pow(1 - progress, 4);
            const currentValue = Math.floor(start + (end - start) * easeOutQuart);

            element.textContent = format(currentValue);

            if (progress < 1) {
                requestAnimationFrame(updateCounter);
            }
        };

        requestAnimationFrame(updateCounter);
    },

    formatNumber(num) {
        if (num < 1000) return num.toString();
        if (num < 1000000) return (num / 1000).toFixed(1) + 'K';
        if (num < 1000000000) return (num / 1000000).toFixed(1) + 'M';
        return (num / 1000000000).toFixed(1) + 'B';
    },

    timeAgo(dateParam) {
        if (!dateParam) return null;

        const date = typeof dateParam === 'object' ? dateParam : new Date(dateParam);
        const today = new Date();
        const seconds = Math.round((today - date) / 1000);
        const minutes = Math.round(seconds / 60);
        const hours = Math.round(minutes / 60);
        const days = Math.round(hours / 24);
        const months = Math.round(days / 30.4);
        const years = Math.round(days / 365);

        if (seconds < 60) {
            return `${seconds}s ago`;
        } else if (minutes < 60) {
            return `${minutes}m ago`;
        } else if (hours < 24) {
            return `${hours}h ago`;
        } else if (days < 30) {
            return `${days}d ago`;
        } else if (months < 12) {
            return `${months}mo ago`;
        } else {
            return `${years}y ago`;
        }
    },

    formatViews(viewCount) {
        return this.formatNumber(viewCount);
    },

    escapeHtml(text) {
        const div = DOM.create('div');
        div.textContent = text;
        return div.innerHTML;
    }
};

window.animateCounter = AnimationUtils.animateCounter.bind(AnimationUtils);
window.formatNumber = AnimationUtils.formatNumber;
window.timeAgo = AnimationUtils.timeAgo;
window.formatViews = AnimationUtils.formatViews;
window.escapeHtml = AnimationUtils.escapeHtml;
const LoadingUtils = {
    loadingElement: null,
    loadingCount: 0,

    init() {
        if (!this.loadingElement) {
            const loading = document.createElement('div');
            loading.id = 'global-loading';
            loading.className = 'global-loading';
            loading.innerHTML = `
                <div class="loading-spinner">
                    <i class="fa-solid fa-spinner fa-spin"></i>
                </div>
            `;
            document.body.appendChild(loading);
            this.loadingElement = loading;
        }
    },

    show() {
        this.init();
        this.loadingElement.style.display = 'flex';
        document.body.style.overflow = 'hidden';
    },

    hide() {
        if (this.loadingElement) {
            this.loadingElement.style.display = 'none';
            document.body.style.overflow = '';
        }
    }
};

window.loading = LoadingUtils;
const NotificationUtils = {
    getToast() {
        if (typeof Swal === 'undefined') return null;

        return Swal.mixin({
            toast: true,
            position: "top-end",
            showConfirmButton: false,
            timer: 3000,
            timerProgressBar: true,
            didOpen: (toast) => {
                toast.onmouseenter = Swal.stopTimer;
                toast.onmouseleave = Swal.resumeTimer;
            }
        });
    },

    success(title, options = {}) {
        const Toast = this.getToast();
        if (!Toast) return;

        Toast.fire({
            icon: "success",
            title,
            ...options
        });
    },

    error(title, text = null, options = {}) {
        if (typeof Swal === 'undefined') return;

        if (text) {
            Swal.fire({
                icon: 'error',
                title,
                text,
                ...options
            });
        } else {
            const Toast = this.getToast();
            Toast?.fire({
                icon: "error",
                title,
                ...options
            });
        }
    },

    info(title, text = null, options = {}) {
        if (typeof Swal === 'undefined') {
            console.error('SweetAlert2 not loaded');
            return Promise.resolve({ isConfirmed: false });
        }

        if (text) {
            return Swal.fire({
                icon: 'info',
                title,
                text,
                ...options
            });
        } else {
            const Toast = this.getToast();
            if (Toast) {
                Toast.fire({
                    icon: "info",
                    title,
                    ...options
                });
            }
            return Promise.resolve({ isConfirmed: false });
        }
    },

    warning(title, text, options = {}) {
        if (typeof Swal === 'undefined') return;

        Swal.fire({
            icon: 'warning',
            title,
            text,
            ...options
        });
    },

    async confirm(title, text, options = {}) {
        if (typeof Swal === 'undefined') return false;

        const result = await Swal.fire({
            title,
            text,
            icon: 'question',
            showCancelButton: true,
            confirmButtonText: 'Yes',
            cancelButtonText: 'Cancel',
            confirmButtonColor: '#4ecdc4',
            ...options
        });

        return result.isConfirmed;
    },

    async confirmDanger(title, text, confirmText = 'Yes, delete it', options = {}) {
        if (typeof Swal === 'undefined') return false;

        const result = await Swal.fire({
            title,
            text,
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: confirmText,
            cancelButtonText: 'Cancel',
            confirmButtonColor: '#e74c3c',
            ...options
        });

        return result.isConfirmed;
    },

    levelUp(level) {
        if (typeof confetti !== 'undefined') {
            confetti({
                particleCount: 50,
                spread: 50,
                origin: { y: 0.3 },
                colors: ['#ffffff', '#4ecdc4', '#667eea']
            });
        }

        this.success(`Level ${level} reached! 🎉`);
    },

    showXP(amount) {
        const notification = DOM.get('xp-notification');
        if (!notification) return;

        notification.style.animation = 'xpNotificationAnimation 1.5s';
        notification.textContent = `+${amount} XP`;

        setTimeout(() => {
            notification.style.animation = 'none';
        }, 1500);
    },

    showActionFeedback(action) {
        const feedback = DOM.create('div', {
            class: 'action-feedback ' + action
        });
        feedback.innerHTML = `<i class="fa-solid fa-${action === 'liked' ? 'heart' : action === 'passed' ? 'heart-crack' : 'forward'}"></i> ${action.charAt(0).toUpperCase() + action.slice(1)}!`;

        document.body.appendChild(feedback);

        setTimeout(() => {
            feedback.remove();
        }, 1000);
    },

    desktopAppPrompt(onConfirm) {
        if (typeof Swal === 'undefined') return;

        Swal.fire({
            title: 'Desktop App Required',
            html: `
                <p>To download and play games, you need the VAPR desktop app.</p>
                <p style="margin-top: 20px; font-size: 14px; color: rgba(255, 255, 255, 0.7);">
                    The desktop app allows you to:
                </p>
                <ul style="text-align: left; margin: 10px 0; font-size: 14px; color: rgba(255, 255, 255, 0.7);">
                    <li>Download and install games directly</li>
                    <li>Launch games with one click</li>
                    <li>Track your playtime</li>
                    <li>Get automatic updates</li>
                </ul>
            `,
            icon: 'info',
            showCancelButton: true,
            confirmButtonText: '<i class="fa-solid fa-download"></i> Download Desktop App',
            cancelButtonText: 'Maybe Later',
            confirmButtonColor: '#4ecdc4',
            customClass: {
                container: 'download-prompt-container'
            }
        }).then((result) => {
            if (result.isConfirmed && onConfirm) {
                onConfirm();
            }
        });
    },

    copyToClipboard(text, successMessage = 'Copied to clipboard!') {
        navigator.clipboard.writeText(text).then(() => {
            this.success(successMessage);
        }).catch(() => {
            const textArea = DOM.create('textarea', {
                value: text,
                style: {
                    position: 'absolute',
                    left: '-9999px'
                }
            });
            document.body.appendChild(textArea);
            textArea.select();
            textArea.setSelectionRange(0, 99999);

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    this.success(successMessage);
                } else {
                    this.error('Failed to copy to clipboard');
                }
            } catch (err) {
                this.error('Failed to copy to clipboard');
            }

            document.body.removeChild(textArea);
        });
    }
};

window.notify = NotificationUtils;
window.showToast = (type, title, options) => NotificationUtils[type](title, options);
let versionCheckInterval = null;
let isVersionCheckModalOpen = false;

function getWebVersion() {
    const versionElement = DOM.query('.menu-version span');
    if (versionElement) {
        const versionText = versionElement.textContent;
        const versionMatch = versionText.match(/v(\d+\.\d+\.\d+)/);
        if (versionMatch) {
            return versionMatch[1];
        }
    }
    return null;
}

function getDesktopVersion() {
    if (window.__TAURI__ && window.__TAURI__.app) {
        return window.__TAURI__.app.getVersion();
    }
    return null;
}

async function checkDesktopVersion() {
    if (!isRunningInTauri() || isVersionCheckModalOpen) {
        return;
    }

    try {
        const webVersion = getWebVersion();
        const desktopVersion = await getDesktopVersion();

        if (!webVersion || !desktopVersion) {
            console.error('Could not retrieve version information');
            return;
        }

        if (webVersion !== desktopVersion) {
            showVersionUpdateModal({
                current_version: desktopVersion,
                required_version: webVersion
            });
        }
    } catch (error) {
        console.error('Version check failed:', error);
    }
}

function showVersionUpdateModal(versionInfo) {
    if (isVersionCheckModalOpen) return;

    isVersionCheckModalOpen = true;

    if (versionCheckInterval) {
        clearInterval(versionCheckInterval);
        versionCheckInterval = null;
    }

    const downloadUrl = `https://github.com/Vic92548/VAPR/releases/download/v${versionInfo.required_version}/VAPR_${versionInfo.required_version}_x64_en-US.msi`;

    const modal = DOM.create('div', {
        id: 'version-update-modal',
        class: 'version-modal-overlay'
    });

    modal.innerHTML = `
        <div class="version-modal-content">
            <div class="version-modal-header">
                <i class="fa-solid fa-exclamation-triangle"></i>
                <h2>Update Available</h2>
            </div>
            <div class="version-modal-body">
                <p>A new version of VAPR desktop app is available. Update now for the latest features and improvements.</p>
                <div class="version-info">
                    <div class="version-item">
                        <span class="version-label">Your version:</span>
                        <span class="version-value outdated">v${versionInfo.current_version}</span>
                    </div>
                    <div class="version-item">
                        <span class="version-label">Latest version:</span>
                        <span class="version-value required">v${versionInfo.required_version}</span>
                    </div>
                </div>
                <p class="version-note">We recommend updating to ensure the best experience and compatibility.</p>
            </div>
            <div class="version-modal-actions">
                <button class="version-download-btn" onclick="downloadLatestDesktopVersion('${downloadUrl}')">
                    <i class="fa-solid fa-download"></i>
                    Download Latest Version
                </button>
                <button class="version-skip-btn" onclick="skipVersionUpdate('${versionInfo.required_version}')">
                    <i class="fa-solid fa-clock"></i>
                    Skip for now <span class="skip-warning">(not recommended, may cause bugs)</span>
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';
}

function skipVersionUpdate(skippedVersion) {
    const modal = DOM.get('version-update-modal');
    if (modal) {
        modal.remove();
        document.body.style.overflow = '';
    }

    isVersionCheckModalOpen = false;
}

function downloadLatestDesktopVersion(downloadUrl) {
    window.open(downloadUrl, '_blank');

    setTimeout(() => {
        notify.info(
            'Download Started',
            `<p>The download should begin shortly.</p>
            <p style="margin-top: 15px; font-size: 14px; color: rgba(255, 255, 255, 0.7);">
                After installing the new version, please restart VAPR to continue.
            </p>`,
            {
                confirmButtonText: 'OK',
                confirmButtonColor: '#4ecdc4'
            }
        );
    }, 500);
}

function initVersionCheck() {
    if (!isRunningInTauri()) return;

    setTimeout(() => {
        checkDesktopVersion();
    }, 3000);
}

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        initVersionCheck();
    });

    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'childList' && DOM.query('.menu-version span')) {
                observer.disconnect();
                checkDesktopVersion();
            }
        });
    });

    observer.observe(document.body, { childList: true, subtree: true });
}
