const cardManager = {
    currentCard: null,
    cards: new Map(),

    register(cardId, options = {}) {
        this.cards.set(cardId, {
            onShow: options.onShow || (() => {}),
            onHide: options.onHide || (() => {}),
            onLoad: options.onLoad || null,
            ...options
        });
    },

    async show(cardId) {
        const card = document.getElementById(cardId);
        if (!card) {
            console.error(`Card ${cardId} not found`);
            return;
        }

        if (window.hideMenu) hideMenu();

        if (this.currentCard && this.currentCard !== cardId) {
            await this.hideCard(this.currentCard, true);
        }

        const post = document.querySelector('.post');
        if (post) {
            post.style.display = 'none';
        }

        card.style.display = 'block';

        setTimeout(() => {
            card.classList.add('show');
        }, 10);

        this.currentCard = cardId;

        const config = this.cards.get(cardId) || {};
        if (config.onLoad) {
            this.showLoading(cardId);
            try {
                await config.onLoad();
            } catch (error) {
                console.error(`Error loading card ${cardId}:`, error);
            } finally {
                this.hideLoading(cardId);
            }
        }

        config.onShow();
    },

    hide(cardId) {
        return this.hideCard(cardId, false);
    },

    hideCard(cardId, skipPostRestore = false) {
        return new Promise((resolve) => {
            const card = document.getElementById(cardId);
            if (!card) {
                resolve();
                return;
            }

            const config = this.cards.get(cardId) || {};

            card.classList.remove('show');

            setTimeout(() => {
                card.style.display = 'none';

                if (!skipPostRestore) {
                    const post = document.querySelector('.post');
                    if (post) {
                        post.style.display = 'block';
                    }
                }

                config.onHide();

                if (this.currentCard === cardId) {
                    this.currentCard = null;
                }

                resolve();
            }, 800);
        });
    },

    showLoading(cardId) {
        const card = document.getElementById(cardId);

        if (cardId === 'analytics-card') {
            const loading = document.getElementById('analytics-loading');
            const content = document.querySelector('.analytics-body');
            if (loading) loading.style.display = 'block';
            if (content) content.style.opacity = '0.3';
        }
        else if (cardId === 'backgrounds-card') {
            const loading = document.getElementById('backgrounds-loading');
            const content = document.getElementById('backgroundsContent');
            if (loading) loading.style.display = 'block';
            if (content) content.style.opacity = '0.3';
        }
        else if (cardId === 'games-card') {
            const loading = document.getElementById('games-loading');
            const content = document.getElementById('gamesContent');
            if (loading) loading.style.display = 'block';
            if (content) content.style.opacity = '0.3';
        }
    },

    hideLoading(cardId) {
        const card = document.getElementById(cardId);

        if (cardId === 'analytics-card') {
            const loading = document.getElementById('analytics-loading');
            const content = document.querySelector('.analytics-body');
            if (loading) loading.style.display = 'none';
            if (content) content.style.opacity = '1';
        }
        else if (cardId === 'backgrounds-card') {
            const loading = document.getElementById('backgrounds-loading');
            const content = document.getElementById('backgroundsContent');
            if (loading) loading.style.display = 'none';
            if (content) content.style.opacity = '1';
        }
        else if (cardId === 'games-card') {
            const loading = document.getElementById('games-loading');
            const content = document.getElementById('gamesContent');
            if (loading) loading.style.display = 'none';
            if (content) content.style.opacity = '1';
        }
    },

    isShown(cardId) {
        return this.currentCard === cardId;
    },

    getCurrentCard() {
        return this.currentCard;
    }
};

window.cardManager = cardManager;
window.analytics = {};

function isOnMainePage(){
    if(document.getElementById("sign_in")){
        return true;
    }

    return false;
}

window.MainPage = isOnMainePage();
class VAPRTemplateEngine {
    constructor() {
        this.templates = new Map();
        this.rendered = new WeakSet();
        this.hooks = new Map();
    }

    init() {
        this.loadTemplates();
        this.processDocument();
        this.observeDOM();
    }

    on(selector, event, callback) {
        const key = `${selector}:${event}`;
        if (!this.hooks.has(key)) {
            this.hooks.set(key, []);
        }
        this.hooks.get(key).push(callback);
    }

    off(selector, event, callback) {
        const key = `${selector}:${event}`;
        if (this.hooks.has(key)) {
            const callbacks = this.hooks.get(key);
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }

    emit(element, event) {
        const tagName = element.tagName.toLowerCase();
        const id = element.id;
        const classes = Array.from(element.classList);

        const selectors = [
            tagName,
            ...classes.map(c => `.${c}`),
            id ? `#${id}` : null
        ].filter(Boolean);

        selectors.forEach(selector => {
            const key = `${selector}:${event}`;
            if (this.hooks.has(key)) {
                this.hooks.get(key).forEach(callback => {
                    callback(element);
                });
            }
        });

        const customSelectors = element.getAttribute('data-hook');
        if (customSelectors) {
            customSelectors.split(' ').forEach(selector => {
                const key = `${selector}:${event}`;
                if (this.hooks.has(key)) {
                    this.hooks.get(key).forEach(callback => {
                        callback(element);
                    });
                }
            });
        }
    }

    loadTemplates() {
        const templates = document.querySelectorAll('template[data-vapr]');
        templates.forEach(template => {
            const name = template.dataset.vapr;
            this.templates.set(name.toLowerCase(), template.innerHTML.trim());
        });
        console.log(`VAPR: Loaded ${this.templates.size} templates`);
    }

    processDocument() {
        this.templates.forEach((template, name) => {
            this.processElements(name);
        });
    }

    processElements(tagName) {
        const elements = document.querySelectorAll(tagName);
        elements.forEach(element => {
            if (!this.rendered.has(element)) {
                this.renderElement(element, tagName);
            }
        });
    }

    processConditionals(html, attributes) {
        const processBlock = (text, isNegative) => {
            const regex = isNegative
                ? /\{\{\^([\w-]+)\}\}/g
                : /\{\{#([\w-]+)\}\}/g;

            let result = text;
            let match;

            const openings = [];
            while ((match = regex.exec(text)) !== null) {
                openings.push({
                    attr: match[1],
                    start: match.index,
                    end: match.index + match[0].length,
                    tag: match[0]
                });
            }

            for (let i = openings.length - 1; i >= 0; i--) {
                const opening = openings[i];
                const closingTag = `{{/${opening.attr}}}`;
                const closingIndex = result.indexOf(closingTag, opening.end);

                if (closingIndex !== -1) {
                    const content = result.substring(opening.end, closingIndex);
                    const value = attributes[opening.attr];

                    let shouldShow;
                    if (isNegative) {
                        shouldShow = !value || value === 'false' || value === '';
                    } else {
                        shouldShow = value && value !== 'false' && value !== '';
                    }

                    const replacement = shouldShow ? this.processConditionals(content, attributes) : '';

                    result = result.substring(0, opening.start) +
                        replacement +
                        result.substring(closingIndex + closingTag.length);
                }
            }

            return result;
        };

        html = processBlock(html, true);
        html = processBlock(html, false);

        return html;
    }

    renderElement(element, tagName) {
        const template = this.templates.get(tagName.toLowerCase());
        if (!template) return;

        const content = element.innerHTML;
        const attributes = {};

        for (let attr of element.attributes) {
            attributes[attr.name] = attr.value;
        }

        let html = template;

        html = html.replace(/<slot\s*\/?>/gi, content);

        html = this.processConditionals(html, attributes);

        html = html.replace(/\{\{([\w-]+)\}\}/g, (match, attrName) => {
            const value = attributes[attrName];
            return value !== undefined && value !== null ? value : '';
        });

        const wrapper = document.createElement('div');
        wrapper.innerHTML = html;

        let rootElement;
        let elementsToEmit = [];

        if (wrapper.children.length === 1) {
            const newElement = wrapper.firstElementChild;

            for (let attr of element.attributes) {
                if (!newElement.hasAttribute(attr.name)) {
                    newElement.setAttribute(attr.name, attr.value);
                }
            }

            element.replaceWith(newElement);
            rootElement = newElement;

            elementsToEmit = [newElement, ...newElement.querySelectorAll('*')];
        } else {
            element.innerHTML = wrapper.innerHTML;
            rootElement = element;

            elementsToEmit = [element, ...element.querySelectorAll('*')];
        }

        this.rendered.add(rootElement);

        elementsToEmit.forEach(el => {
            this.emit(el, 'created');
        });

        requestAnimationFrame(() => {
            if (rootElement.isConnected) {
                const connectedElements = wrapper.children.length === 1
                    ? [rootElement, ...rootElement.querySelectorAll('*')]
                    : [rootElement, ...rootElement.querySelectorAll('*')];

                connectedElements.forEach(el => {
                    if (el.isConnected) {
                        this.emit(el, 'mounted');
                    }
                });
            }
        });
    }

    observeDOM() {
        const observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === 1) {
                        const tagName = node.tagName?.toLowerCase();

                        if (tagName && this.templates.has(tagName)) {
                            if (!this.rendered.has(node)) {
                                this.renderElement(node, tagName);
                            }
                        }

                        this.templates.forEach((template, name) => {
                            const children = node.querySelectorAll(name);
                            children.forEach(child => {
                                if (!this.rendered.has(child)) {
                                    this.renderElement(child, name);
                                }
                            });
                        });
                    }
                });
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    }

    refresh() {
        this.rendered = new WeakSet();
        this.processDocument();
    }

    render(element) {
        const tagName = element.tagName.toLowerCase();
        if (this.templates.has(tagName)) {
            this.renderElement(element, tagName);
        }
    }

    querySelector(selector) {
        return document.querySelector(selector);
    }

    querySelectorAll(selector) {
        return document.querySelectorAll(selector);
    }

    createElement(tagName, attributes = {}) {
        const element = document.createElement(tagName);

        Object.entries(attributes).forEach(([key, value]) => {
            const attrName = key.replace(/([A-Z])/g, '-$1').toLowerCase();

            if (value === null || value === undefined) {
                return;
            } else if (typeof value === 'boolean') {
                element.setAttribute(attrName, value.toString());
            } else if (typeof value === 'object') {
                element.setAttribute(attrName, JSON.stringify(value));
            } else {
                element.setAttribute(attrName, value.toString());
            }
        });

        return element;
    }

    appendElement(container, tagName, attributes = {}) {
        const element = this.createElement(tagName, attributes);
        container.appendChild(element);
        return element;
    }

    createElements(tagName, dataArray) {
        return dataArray.map(data => this.createElement(tagName, data));
    }

    appendElements(container, tagName, dataArray) {
        const elements = this.createElements(tagName, dataArray);
        elements.forEach(el => container.appendChild(el));
        return elements;
    }

    createElementWithContent(tagName, attributes = {}, content = '') {
        const element = this.createElement(tagName, attributes);
        if (content) {
            element.innerHTML = content;
        }
        return element;
    }
}

window.VAPR = new VAPRTemplateEngine();
window.VAPR.init();
let analyticsData = {
    posts: [],
    fullData: null
};

cardManager.register('analytics-card', {
    onLoad: async () => {
        resetAnalyticsUI();
        await loadAnalyticsData();
    }
});

async function openAnalytics() {
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }

    await cardManager.show('analytics-card');
}

function closeAnalyticsCard() {
    cardManager.hide('analytics-card');
}

function resetAnalyticsUI() {
    const analyticsCard = document.getElementById('analytics-card');
    if (analyticsCard) {
        analyticsCard.querySelector('#total_views').textContent = "0";
        analyticsCard.querySelector('#total_likes').textContent = "0";
        analyticsCard.querySelector('#total_followers').textContent = "0";
        analyticsCard.querySelector('#total_clicks').textContent = "0";
    }
}

async function loadAnalyticsData() {
    try {
        const fallbackData = await api.getMyPosts();
        console.log('Loaded posts data:', fallbackData);

        if (!fallbackData || fallbackData.length === 0) {
            document.getElementById("posts_list").innerHTML = '<div style="text-align: center; padding: 20px;">No posts found</div>';
            return;
        }

        analyticsData.posts = fallbackData;

        setTimeout(() => {
            calculateOverviewMetrics();
            populatePostsList();
            setupEventListeners();
        }, 100);
    } catch (error) {
        console.error("Error loading analytics data:", error);
        document.getElementById("posts_list").innerHTML = '<div style="text-align: center; padding: 20px; color: #e74c3c;">Failed to load analytics data</div>';
    }
}

function calculateOverviewMetrics() {
    const posts = analyticsData.posts;

    let totalViews = 0;
    let totalLikes = 0;
    let totalDislikes = 0;
    let totalFollows = 0;
    let totalClicks = 0;

    posts.forEach(post => {
        totalViews += post.viewsCount || 0;
        totalLikes += post.likesCount || 0;
        totalDislikes += post.dislikesCount || 0;
        totalFollows += post.followersCount || 0;
        totalClicks += post.linkClicksCount || 0;
    });

    console.log('Total views calculated:', totalViews);

    const analyticsCard = document.getElementById('analytics-card');
    if (!analyticsCard) {
        console.error('Analytics card not found!');
        return;
    }

    const elements = {
        views: analyticsCard.querySelector('#total_views'),
        likes: analyticsCard.querySelector('#total_likes'),
        followers: analyticsCard.querySelector('#total_followers'),
        clicks: analyticsCard.querySelector('#total_clicks')
    };

    if (elements.views) animateCounter(elements.views, 0, totalViews, 1000);
    if (elements.likes) animateCounter(elements.likes, 0, totalLikes, 1000);
    if (elements.followers) animateCounter(elements.followers, 0, totalFollows, 1000);
    if (elements.clicks) animateCounter(elements.clicks, 0, totalClicks, 1000);
}

function populatePostsList(sortBy = 'views') {
    const container = document.getElementById("posts_list");
    container.innerHTML = '';

    const posts = analyticsData.posts;
    if (!posts || posts.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 20px;">No posts found</div>';
        return;
    }

    let sortedPosts = [...posts];
    switch(sortBy) {
        case 'views':
            sortedPosts.sort((a, b) => (b.viewsCount || 0) - (a.viewsCount || 0));
            break;
        case 'likes':
            sortedPosts.sort((a, b) => (b.likesCount || 0) - (a.likesCount || 0));
            break;
        case 'engagement':
            sortedPosts.sort((a, b) => {
                const engA = calculatePostEngagement(a);
                const engB = calculatePostEngagement(b);
                return parseFloat(engB) - parseFloat(engA);
            });
            break;
        case 'recent':
            sortedPosts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            break;
    }

    sortedPosts.forEach((post, index) => {
        const postItem = document.createElement('div');
        postItem.className = 'post-item';
        postItem.style.opacity = '0';
        postItem.style.transform = 'translateY(10px)';

        const engagement = calculatePostEngagement(post);

        postItem.innerHTML = `
            <div class="post-item-header">
                <h4 class="post-title">${escapeHtml(post.title)}</h4>
                <span class="post-engagement-badge">${engagement}%</span>
            </div>
            <div class="post-metrics">
                <div class="post-metric">
                    <span class="post-metric-value">${formatNumber(post.viewsCount || 0)}</span>
                    <span class="post-metric-label"><i class="fa-solid fa-eye"></i> Views</span>
                </div>
                <div class="post-metric">
                    <span class="post-metric-value">${formatNumber(post.likesCount || 0)}</span>
                    <span class="post-metric-label"><i class="fa-solid fa-heart"></i> Likes</span>
                </div>
                <div class="post-metric">
                    <span class="post-metric-value">${formatNumber(post.followersCount || 0)}</span>
                    <span class="post-metric-label"><i class="fa-solid fa-user-plus"></i> Follows</span>
                </div>
                <div class="post-metric">
                    <span class="post-metric-value">${formatNumber(post.linkClicksCount || 0)}</span>
                    <span class="post-metric-label"><i class="fa-solid fa-link"></i> Clicks</span>
                </div>
            </div>
            <div class="post-item-footer">
                <span class="post-date">${timeAgo(post.timestamp)}</span>
                <a href="/post/${post.id}" class="view-post-link" target="_blank">
                    View Post <i class="fa-solid fa-external-link-alt"></i>
                </a>
            </div>
        `;

        postItem.onclick = (e) => {
            if (!e.target.classList.contains('view-post-link') && !e.target.parentElement.classList.contains('view-post-link')) {
                window.open(`/post/${post.id}`, '_blank');
            }
        };

        container.appendChild(postItem);

        setTimeout(() => {
            postItem.style.transition = 'all 0.3s ease';
            postItem.style.opacity = '1';
            postItem.style.transform = 'translateY(0)';
        }, index * 50);
    });
}

function calculatePostEngagement(post) {
    const views = post.viewsCount || 0;
    if (views === 0) return 0;

    const likes = post.likesCount || 0;
    const dislikes = post.dislikesCount || 0;
    const follows = post.followersCount || 0;

    const engagements = likes + dislikes + follows;
    return ((engagements / views) * 100).toFixed(1);
}

function setupEventListeners() {
    const sortDropdown = document.getElementById('sort_posts');

    if (sortDropdown) {
        const newDropdown = sortDropdown.cloneNode(true);
        sortDropdown.parentNode.replaceChild(newDropdown, sortDropdown);

        newDropdown.addEventListener('change', (e) => {
            populatePostsList(e.target.value);
        });
    }
}

window.closeAnalytics = closeAnalyticsCard;
class API {
    constructor() {
        this.baseURL = '';
        this.defaultHeaders = {
            'Content-Type': 'application/json'
        };
    }

    clearAuth() {
        localStorage.removeItem('userData');
        window.user = null;
    }

    async request(path, options = {}) {
        const {
            method = 'GET',
            body = null,
            requireAuth = true,
            headers = {},
            isFormData = false
        } = options;

        const requestHeaders = {
            ...(!isFormData ? this.defaultHeaders : {}),
            ...headers
        };

        try {
            const response = await fetch(path, {
                method,
                headers: requestHeaders,
                body: isFormData ? body : (body ? JSON.stringify(body) : null),
                credentials: 'include'
            });

            if (!response.ok) {
                if (response.status === 401 && requireAuth) {
                    this.clearAuth();
                    window.location.href = '/login';
                    throw new Error('Unauthorized');
                }
                throw new Error(`Network response was not ok: ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            throw error;
        }
    }

    get(path, requireAuth = true) {
        return this.request(path, { requireAuth });
    }

    post(path, body, options = {}) {
        return this.request(path, {
            method: 'POST',
            body,
            ...options
        });
    }

    async getMe() {
        return this.get('/me');
    }

    async getFeed() {
        return this.get('/feed', false);
    }

    async getPost(id) {
        if (!/^[a-f0-9-]{36}$/.test(id)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/posts/${id}`, false);
    }

    async createPost(formData) {
        return this.request('/posts', {
            method: 'POST',
            body: formData,
            isFormData: true,
            requireAuth: true
        });
    }

    async likePost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/like/${postId}`);
    }

    async dislikePost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/dislike/${postId}`);
    }

    async skipPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/skip/${postId}`);
    }

    async followPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/manage-follow?action=follow&postId=${postId}`);
    }

    async unfollowPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/manage-follow?action=unfollow&postId=${postId}`);
    }

    async checkFollowStatus(creatorId) {
        const data = await this.get(`/check-follow/${creatorId}`);
        return data.isFollowing || false;
    }

    async addReaction(postId, emoji) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        const allowedEmojis = ['💩', '👀', '😂', '❤️', '💯', 'null'];
        if (!allowedEmojis.includes(emoji)) {
            throw new Error('Invalid emoji');
        }
        return this.get(`/add-reaction?postId=${postId}&emoji=${encodeURIComponent(emoji)}`);
    }

    async getReactions(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/get-reactions?postId=${postId}`, false);
    }

    async registerView(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/register-view?postId=${postId}`, false);
    }

    async clickLink(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/click-link?postId=${postId}`, false);
    }

    async getMyPosts() {
        return this.get('/me/posts');
    }

    async updateBackground(backgroundId) {
        if (!/^[a-zA-Z0-9_-]+$/.test(backgroundId)) {
            throw new Error('Invalid background ID format');
        }
        return this.get(`/me/update-background?backgroundId=${encodeURIComponent(backgroundId)}`);
    }

    async acceptInvitation(ambassadorUserId) {
        return this.get(`/accept-invitation?ambassadorUserId=${ambassadorUserId}`);
    }

    async getAnalytics(range = 7) {
        if (!['7', '30', 'all'].includes(String(range))) {
            range = 7;
        }
        return this.get(`/api/analytics?range=${range}`);
    }

    async getDailyXP() {
        return this.get('/api/xp-today');
    }

    async getUserCount() {
        const response = await fetch('/api/user-count', {
            credentials: 'include'
        });
        return response.json();
    }

    async getUser(userId) {
        return this.get(`/api/user/${userId}`, false);
    }
}

class APIHandler {
    static async handle(apiCall, options = {}) {
        const {
            onSuccess = () => {},
            onError = null,
            showLoading = false,
            successMessage = null,
            errorMessage = 'An error occurred',
            updateXP = false
        } = options;

        if (showLoading) showLoading();

        try {
            const data = await apiCall();

            if (updateXP && window.user && data.user) {
                const oldUser = {
                    xp: window.user.xp,
                    level: window.user.level,
                    xp_required: window.user.xp_required
                };
                window.user = data.user;
                setXPProgress(oldUser);
            }

            if (successMessage && window.notify) {
                window.notify.success(successMessage);
            }

            await onSuccess(data);
            return data;

        } catch (error) {
            console.error(error);

            if (onError) {
                await onError(error);
            } else if (window.notify) {
                window.notify.error('Error', errorMessage);
            }

            throw error;
        } finally {
            if (showLoading) hideLoading();
        }
    }
}

const api = new API();
window.api = api;
window.APIHandler = APIHandler;

window.makeApiRequest = function(path, requireAuth = true) {
    return api.get(path, requireAuth);
};
function loadUserData(){
    if(MainPage){
        document.getElementById("sign_in").style.display = "none";
        document.getElementById("add_post").style.display = "none";
    }

    fetch('/me', {
        credentials: 'include'
    })
        .then(response => {
            if (!response.ok) {
                throw new Error('Not authenticated');
            }
            return response.json();
        })
        .then(data => {
            window.user = data;

            if (window.updateSDKUserInfo) {
                window.updateSDKUserInfo();
            }

            if(!MainPage){
                return;
            }

            updateUsername();
            updateLevel();

            const oldUser = {
                xp: 0,
                level: window.user.level,
                xp_required: window.user.xp_required
            };

            setXPProgress(oldUser, true);

            syncBackgroundFromBackend();

            document.getElementById("sign_in").style.display = "none";
            if(window.innerWidth <= 768){
                document.getElementById("add_post").style.display = "block";
            }

            document.getElementById("xp_bar").style.display = "block";

            loading_steps--;
            hideLoading();

            handleReferral();

            setTimeout(() => {
                migrateLocalBackgroundToBackend();
            }, 1000);

            if (MainPage) {
                loadGamesData().then(() => {
                    updateDeveloperSection();
                    if (window.user) {
                        initializeTebexIntegration();
                        document.getElementById('cart-button').style.display = 'none';
                    }
                });

                checkAndShowUpdates();
            }

        }).catch( error => {
        document.getElementById("sign_in").style.display = "block";
        if(window.innerWidth <= 768){
            document.getElementById("add_post").style.display = "block";
        }
        document.getElementById("add_post").onclick = openRegisterModal;
        loading_steps--;
        hideLoading();
    });
}

function syncBackgroundFromBackend() {
    if (window.user && window.user.backgroundId) {
        const userBackground = background_images.find(bg => bg.id === window.user.backgroundId);

        if (userBackground) {
            equipBackground(userBackground.image_url, true);
            localStorage.setItem('background_url', userBackground.image_url);
            localStorage.setItem('background_id', userBackground.id);
            console.log('Background synchronized from backend:', userBackground.title);
        } else {
            console.log('User background ID not found in available backgrounds:', window.user.backgroundId);
            setDefaultBackground();
        }
    } else {
        const savedBackgroundUrl = localStorage.getItem('background_url');
        if (savedBackgroundUrl) {
            equipBackground(savedBackgroundUrl, false);
        } else {
            setDefaultBackground();
        }
    }
}

function setDefaultBackground() {
    if (background_images.length > 0) {
        const defaultBg = background_images[0];
        equipBackground(defaultBg.image_url, true);
        localStorage.setItem('background_url', defaultBg.image_url);
        localStorage.setItem('background_id', defaultBg.id);
    }
}
background_images = [
    {
        "id": "sunset_crush",
        "title": "Sunset Crush",
        "description": "Illustration from the music album Sunset Crush by Bip Bop Music",
        "image_url": "https://vapr-club.b-cdn.net/backgrounds/sunset_crush.png",
        "link": "https://www.youtube.com/watch?v=OU55Q9k7538&list=OLAK5uy_lSbP59KQr3hAI9h3DDdFI32BXO8AnpAJA",
        "link_text": "Listen on YouTube",
        "unlock": 0,
        "new": false
    },
    {
        "id": "pixel_mirage",
        "title": "Pixel Mirage",
        "description": "Illustration from the music album Pixel Mirage by Bip Bop Music",
        "image_url": "https://vapr-club.b-cdn.net/backgrounds/pixel_mirage.png",
        "link": "https://music.youtube.com/playlist?list=OLAK5uy_lD663FKcik2jpJwnZzkPLeQbaOgPqN75Y",
        "link_text": "Listen on YouTube Music",
        "unlock": 0,
        "new": false
    },
    {
        "id": "bip_bop_music",
        "title": "Bip Bop Music",
        "description": "Illustration from Bip Bop Music",
        "image_url": "https://vapr-club.b-cdn.net/backgrounds/bip_bop_music.png",
        "link": "https://www.youtube.com/@BipBopMusic",
        "link_text": "Subscribe on YouTube",
        "unlock": 2,
        "new": false
    },
    {
        "id": "redline_bg",
        "title": "Redline Background",
        "description": "Illustration from The fortnite Game called Redline",
        "image_url": "https://vapr-club.b-cdn.net/backgrounds/redline_bg.webp",
        "link": "https://www.youtube.com/@StarkiteGames",
        "link_text": "Subscribe on YouTube",
        "unlock": 5,
        "new": true
    },
    {
        "id": "valorant_bg",
        "title": "Valorant Inspired Art",
        "description": "Illustration inspired from Valorant made by Ashley",
        "image_url": "https://vapr-club.b-cdn.net/backgrounds/valorant_bg.png",
        "link": "https://www.youtube.com/@StarkiteGames",
        "link_text": "Follow on VAPR",
        "unlock": 10,
        "new": true
    },
]
cardManager.register('backgrounds-card', {
    onShow: () => {
        displayBackgroundImages();
    }
});

function openCustomizationMenu() {
    if (!isUserLoggedIn() && MainPage) {
        openRegisterModal();
        return;
    }

    cardManager.show('backgrounds-card');
}

function closeBackgroundsCard() {
    cardManager.hide('backgrounds-card');
}

function closeCustomizationMenu() {
    closeBackgroundsCard();
}

function displayBackgroundImages() {
    if (!isUserLoggedIn() && MainPage) {
        openRegisterModal();
        return;
    }

    const container = document.getElementById("backgrounds-grid");
    container.innerHTML = '';

    const currentBackground = localStorage.getItem('background_url');

    background_images.forEach((bg, index) => {
        const isUnlocked = user.level >= bg.unlock;
        const isEquipped = currentBackground === bg.image_url;
        const progress = Math.min((user.level / bg.unlock) * 100, 100);

        const card = document.createElement('div');
        card.className = `background-item ${!isUnlocked ? 'locked' : ''} ${isEquipped ? 'equipped' : ''}`;

        card.innerHTML = `
            ${bg.new && isUnlocked ? '<div class="new-badge">NEW</div>' : ''}
            
            <img src="${bg.image_url}" class="background-preview" alt="${bg.title}" loading="lazy">
            
            <div class="background-info">
                <h4 class="background-title">${bg.title}</h4>
                <p class="background-description">${bg.description}</p>
                ${bg.link ? `
                    <a href="${bg.link}" target="_blank" class="background-link" onclick="event.stopPropagation()">
                        <i class="fa-solid fa-external-link-alt"></i>
                        ${bg.link_text || 'View Source'}
                    </a>
                ` : ''}
            </div>
            
            ${!isUnlocked ? `
                <div class="lock-overlay">
                    <i class="fa-solid fa-lock lock-icon"></i>
                    <div class="unlock-text">Unlock at Level ${bg.unlock}</div>
                    <div class="unlock-progress">
                        <div class="unlock-progress-fill" style="width: ${progress}%"></div>
                    </div>
                </div>
            ` : ''}
        `;

        if (isUnlocked && !isEquipped) {
            card.onclick = () => {
                card.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    card.style.transform = '';
                }, 100);

                updateBackgroundId(bg.id);
                equipBackground(bg.image_url);

                if (typeof confetti !== 'undefined') {
                    confetti({
                        particleCount: 50,
                        spread: 50,
                        origin: { y: 0.6 },
                        colors: ['#4ecdc4', '#44a3aa', '#3d9a92']
                    });
                }

                displayBackgroundImages();
            };
        }

        container.appendChild(card);
    });
}

function equipBackground(url, save = true) {
    if(!MainPage){
        return;
    }

    document.body.style.backgroundImage = 'url(' + url + ')';

    if (save) {
        localStorage.setItem('background_url', url);

        const bgData = background_images.find(bg => bg.image_url === url);
        if (bgData) {
            localStorage.setItem('background_id', bgData.id);
        }
    }
}

function updateBackgroundId(newBackgroundId) {
    if (!isUserLoggedIn()) {
        alert('You must be logged in to update your background.');
        return;
    }

    if (!navigator.onLine) {
        localStorage.setItem('pending_background_id', newBackgroundId);

        const bg = background_images.find(b => b.id === newBackgroundId);
        if (bg) {
            equipBackground(bg.image_url, true);
        }

        notify.info('Offline Mode', 'Background will be synced when you\'re back online');
        return;
    }

    api.updateBackground(newBackgroundId)
        .then(response => {
            console.log('Background updated successfully:', response);

            if (window.user) {
                window.user.backgroundId = newBackgroundId;
            }

            notify.success("Background equipped!");
        })
        .catch(error => {
            console.error('Failed to update background:', error);
            alert('Failed to update background. Please try again.');
        });
}

async function migrateLocalBackgroundToBackend() {
    if (!isUserLoggedIn()) return;

    if (!window.user.backgroundId) {
        const localBackgroundId = localStorage.getItem('background_id');
        const localBackgroundUrl = localStorage.getItem('background_url');

        if (localBackgroundId) {
            try {
                await api.updateBackground(localBackgroundId);
                console.log('Migrated local background to backend');
            } catch (error) {
                console.error('Failed to migrate background:', error);
            }
        } else if (localBackgroundUrl) {
            const bgData = background_images.find(bg => bg.image_url === localBackgroundUrl);
            if (bgData) {
                try {
                    await api.updateBackground(bgData.id);
                    localStorage.setItem('background_id', bgData.id);
                    console.log('Migrated local background URL to backend');
                } catch (error) {
                    console.error('Failed to migrate background:', error);
                }
            }
        }
    }
}

window.addEventListener('online', async () => {
    if (isUserLoggedIn()) {
        const pendingBackgroundId = localStorage.getItem('pending_background_id');
        if (pendingBackgroundId) {
            try {
                await api.updateBackground(pendingBackgroundId);
                localStorage.removeItem('pending_background_id');
                console.log('Synced pending background change');
            } catch (error) {
                console.error('Failed to sync pending background:', error);
            }
        }
    }
});
let developerData = {
    myGames: [],
    totalKeys: 0,
    totalPlayers: 0,
    totalDownloads: 0
};

cardManager.register('developer-dashboard-card', {
    onLoad: async () => {
        await loadDeveloperData();
    }
});

async function openDeveloperDashboard() {
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }

    await cardManager.show('developer-dashboard-card');
}

function closeDeveloperDashboard() {
    cardManager.hide('developer-dashboard-card');
}

async function loadDeveloperData() {
    try {
        document.getElementById('developer-loading').style.display = 'block';

       
        const allGamesResponse = await api.request('/api/games');

        if (allGamesResponse.success) {
           
            developerData.myGames = allGamesResponse.games.filter(game =>
                game.ownerId === window.user.id
            );

           
            let totalKeys = 0;
            let totalUsedKeys = 0;

           
            for (const game of developerData.myGames) {
                try {
                    const keysResponse = await api.request(`/api/games/${game.id}/keys`);
                    if (keysResponse.success) {
                        const keys = keysResponse.keys;
                        totalKeys += keys.length;
                        totalUsedKeys += keys.filter(k => k.usedBy).length;

                       
                        game.totalKeys = keys.length;
                        game.usedKeys = keys.filter(k => k.usedBy).length;
                        game.players = keys.filter(k => k.usedBy).length;
                    }
                } catch (error) {
                    console.error(`Error loading keys for game ${game.id}:`, error);
                    game.totalKeys = 0;
                    game.usedKeys = 0;
                    game.players = 0;
                }
            }

            developerData.totalKeys = totalKeys;
            developerData.totalPlayers = totalUsedKeys;
            developerData.totalDownloads = totalUsedKeys;

            displayDeveloperStats();
            displayDeveloperGames();
        }
    } catch (error) {
        console.error('Error loading developer data:', error);
        notify.error('Failed to load developer data');
    } finally {
        document.getElementById('developer-loading').style.display = 'none';
    }
}

function displayDeveloperStats() {
    document.getElementById('dev-total-games').textContent = developerData.myGames.length;
    document.getElementById('dev-total-keys').textContent = formatNumber(developerData.totalKeys);
    document.getElementById('dev-total-players').textContent = formatNumber(developerData.totalPlayers);
    document.getElementById('dev-total-downloads').textContent = formatNumber(developerData.totalDownloads);
}

function displayDeveloperGames() {
    const container = document.getElementById('dev-games-grid');
    container.innerHTML = '';

    if (developerData.myGames.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <i class="fa-solid fa-gamepad"></i>
                <h4>No games yet</h4>
                <p>Start by adding your first game to VAPR</p>
            </div>
        `;
        return;
    }

    VAPR.appendElements(container, 'developer-game-item',
        developerData.myGames.map(game => ({
            gameId: game.id,
            title: game.title,
            coverImage: game.coverImage,
            totalKeys: game.totalKeys || 0,
            usedKeys: game.usedKeys || 0,
            availableKeys: (game.totalKeys || 0) - (game.usedKeys || 0),
            players: game.players || 0,
            currentVersion: game.currentVersion || '1.0.0',
            hasUpdate: false
        }))
    );

    VAPR.refresh();
}

async function openGameDashboard(gameId) {
    gamesData.currentManagingGame = developerData.myGames.find(g => g.id === gameId);
    if (gamesData.currentManagingGame) {
        await cardManager.show('game-management-card');
    }
}

async function quickGenerateKeys(gameId) {
    const { value: count } = await Swal.fire({
        title: 'Generate Keys',
        input: 'number',
        inputLabel: 'Number of keys to generate',
        inputValue: 5,
        inputAttributes: {
            min: 1,
            max: 100
        },
        showCancelButton: true,
        confirmButtonText: 'Generate',
        confirmButtonColor: '#4ecdc4',
        background: 'rgba(23, 33, 43, 0.95)',
        color: '#fff'
    });

    if (count) {
        try {
            const response = await api.request(`/api/games/${gameId}/generate-keys`, {
                method: 'POST',
                body: { count: parseInt(count), tag: null }
            });

            if (response.success) {
                notify.success(`${count} keys generated successfully!`);
                await loadDeveloperData();
            }
        } catch (error) {
            console.error('Error generating keys:', error);
            notify.error('Failed to generate keys');
        }
    }
}

window.quickGenerateKeys = quickGenerateKeys;
window.openDeveloperDashboard = openDeveloperDashboard;
window.closeDeveloperDashboard = closeDeveloperDashboard;
window.openGameDashboard = openGameDashboard;
async function loadGamesData() {
    try {
        document.getElementById('games-loading').style.display = 'block';

        const [gamesResponse, userGamesResponse] = await Promise.all([
            api.request('/api/games'),
            isUserLoggedIn() ? api.request('/api/my-games') : Promise.resolve({ games: [] })
        ]);

        gamesData.allGames = gamesResponse.games || [];
        gamesData.userGames = userGamesResponse.games || [];

        if (isRunningInTauri()) {
            try {
                const installedGames = await window.__TAURI__.core.invoke('get_installed_games');
                gamesData.installedGames = installedGames || [];
            } catch (error) {
                console.error('Error loading installed games:', error);
                gamesData.installedGames = [];
            }
        }

        displayGames();
    } catch (error) {
        console.error('Error loading games:', error);
    } finally {
        document.getElementById('games-loading').style.display = 'none';
    }
}

async function loadLibraryData() {
    try {
        document.getElementById('library-loading').style.display = 'block';

        const response = await api.request('/api/my-games');
        gamesData.userGames = response.games || [];

        if (isRunningInTauri()) {
            try {
                const installedGames = await window.__TAURI__.core.invoke('get_installed_games');
                gamesData.installedGames = installedGames || [];
            } catch (error) {
                console.error('Error loading installed games:', error);
                gamesData.installedGames = [];
            }
        }

        displayLibrary();
    } catch (error) {
        console.error('Error loading library:', error);
    } finally {
        document.getElementById('library-loading').style.display = 'none';
    }
}
let currentGameDetails = null;

cardManager.register('game-details-card', {
    onLoad: async () => {
        if (currentGameDetails) {
            await loadGameDetails(currentGameDetails);
        }
    }
});

async function showGameDetails(gameId) {
    currentGameDetails = gameId;
    await cardManager.show('game-details-card');
}

function closeGameDetails() {
    cardManager.hide('game-details-card');
    currentGameDetails = null;
}

async function loadGameDetails(gameId) {
    try {
        document.getElementById('game-details-loading').style.display = 'block';

        let game = null;
        let vaprGame = null;
        let playerCount = 0;

        if (gameId.startsWith('tebex-')) {
            game = gamesData.tebexGames.find(g => g.id === gameId);

            if (game) {
                const vaprGamesResponse = await api.request('/api/games');
                if (vaprGamesResponse.success) {
                    vaprGame = vaprGamesResponse.games.find(g =>
                        g.title.toLowerCase() === game.title.toLowerCase()
                    );

                    if (vaprGame) {
                        game = {
                            ...game,
                            ownerId: vaprGame.ownerId,
                            currentVersion: vaprGame.currentVersion || game.currentVersion,
                            createdAt: vaprGame.createdAt || game.createdAt
                        };

                        try {
                            const keysResponse = await api.request(`/api/games/${vaprGame.id}/keys`);
                            if (keysResponse.success) {
                                playerCount = keysResponse.keys.filter(k => k.usedBy).length;
                            }
                        } catch (error) {
                            console.error('Error loading player count:', error);
                        }
                    }
                }
            }
        } else {
            game = gamesData.allGames.find(g => g.id === gameId);

            if (!game) {
                const response = await api.request(`/api/games`);
                if (response.success) {
                    game = response.games.find(g => g.id === gameId);
                }
            }

            if (game) {
                try {
                    const keysResponse = await api.request(`/api/games/${game.id}/keys`);
                    if (keysResponse.success) {
                        playerCount = keysResponse.keys.filter(k => k.usedBy).length;
                    }
                } catch (error) {
                    console.error('Error loading player count:', error);
                }
            }
        }

        if (!game) {
            throw new Error('Game not found');
        }

        game.playerCount = playerCount;

        console.log('Final game data with ownerId:', game);

        await displayGameDetails(game);

    } catch (error) {
        console.error('Error loading game details:', error);
        notify.error('Failed to load game details');
    } finally {
        document.getElementById('game-details-loading').style.display = 'none';
    }
}

async function displayGameDetails(game) {
    console.log({ game });

    document.getElementById('game-details-cover').src = game.coverImage;
    document.getElementById('game-details-backdrop').src = game.coverImage;
    document.getElementById('game-hero-title').textContent = game.title;
    document.getElementById('game-details-description').innerHTML = game.description;

    const versionEl = document.getElementById('game-details-version');
    const metaVersionEl = document.getElementById('game-details-meta-version');
    const version = game.currentVersion || game.version || '1.0.0';
    versionEl.textContent = version;
    if (metaVersionEl) metaVersionEl.textContent = version;

    const playerCountEl = document.getElementById('game-details-players');
    if (playerCountEl) {
        playerCountEl.textContent = game.playerCount || 0;
    }

    const developerEl = document.getElementById('game-details-developer');
    const heroDeveloperEl = document.getElementById('game-hero-developer');

    const updateDeveloperElements = (text, href = '#', clickable = false) => {
        [developerEl, heroDeveloperEl].forEach(el => {
            if (el) {
                el.textContent = text;
                el.href = href;
                el.style.cursor = clickable ? 'pointer' : 'default';
                el.onclick = clickable ? (e) => {
                    e.preventDefault();
                    closeGameDetails();
                    setTimeout(() => {
                        window.location.href = href;
                    }, 300);
                } : (e) => e.preventDefault();
            }
        });
    };

    updateDeveloperElements('Loading...', '#', false);

    console.log('Game ownerId:', game.ownerId);

    if (game.ownerId) {
        try {
            let developerInfo = null;

            if (window.creators && window.creators[game.ownerId]) {
                developerInfo = {
                    username: window.creators[game.ownerId].username,
                    id: game.ownerId
                };
                console.log('Developer from cache:', developerInfo);
            } else {
                const response = await fetch(`/api/user/${game.ownerId}`, {
                    credentials: 'include'
                });

                if (response.ok) {
                    developerInfo = await response.json();
                    console.log('Developer from API:', developerInfo);

                    if (!window.creators) {
                        window.creators = {};
                    }
                    if (!window.creators[game.ownerId]) {
                        window.creators[game.ownerId] = {};
                    }
                    window.creators[game.ownerId].username = developerInfo.username;
                }
            }

            if (developerInfo && developerInfo.username) {
                updateDeveloperElements('@' + developerInfo.username, `/@${developerInfo.username}`, true);
            } else {
                throw new Error('Could not get developer info');
            }
        } catch (error) {
            console.error('Error fetching developer:', error);

            if (window.user && window.user.id === game.ownerId) {
                updateDeveloperElements('@' + window.user.username, `/@${window.user.username}`, true);
            } else {
                updateDeveloperElements('Unknown Developer', '#', false);
            }
        }
    } else if (game.developer) {
        updateDeveloperElements(game.developer, '#', false);
    } else {
        updateDeveloperElements('Unknown Developer', '#', false);
    }

    const releaseDateEl = document.getElementById('game-details-release-date');
    const heroReleaseDateEl = document.getElementById('game-hero-release-date');
    const releaseDate = game.createdAt ? new Date(game.createdAt).toLocaleDateString() : 'TBA';

    if (releaseDateEl) releaseDateEl.textContent = releaseDate;
    if (heroReleaseDateEl) heroReleaseDateEl.textContent = releaseDate;

    const userGameIds = gamesData.userGames.map(g => g.id);
    const isOwned = userGameIds.includes(game.id) ||
        (game.isTebexProduct && userGameIds.some(id => {
            const ownedGame = gamesData.userGames.find(g => g.id === id);
            return ownedGame && ownedGame.title.toLowerCase() === game.title.toLowerCase();
        }));

    const priceSection = document.getElementById('game-details-price-section');
    const ownedSection = document.getElementById('game-details-owned-section');
    const giftButton = document.getElementById('game-details-gift-button');
    const priceBox = document.querySelector('.price-box');
    const originalPriceEl = document.getElementById('game-details-original-price');
    const currentPriceEl = document.getElementById('game-details-price');
    const disclaimerSection = document.getElementById('game-details-disclaimer-section');

    if (game.isTebexProduct) {
        priceBox.style.display = 'flex';
        disclaimerSection.style.display = 'block';

        if (game.onSale) {
            originalPriceEl.style.display = 'inline';
            originalPriceEl.textContent = `${game.currency} ${game.originalPrice.toFixed(2)}`;
        } else {
            originalPriceEl.style.display = 'none';
        }

        currentPriceEl.textContent = `${game.currency} ${game.price.toFixed(2)}`;

        if (isOwned) {
            priceSection.style.display = 'none';
            ownedSection.style.display = 'flex';
            giftButton.style.display = 'inline-flex';
            giftButton.onclick = () => {
                addToCart(game.tebexId);
                closeGameDetails();
            };
        } else {
            priceSection.style.display = 'flex';
            ownedSection.style.display = 'none';

            const addToCartBtn = document.getElementById('game-details-add-to-cart');
            addToCartBtn.onclick = () => {
                addToCart(game.tebexId);
                closeGameDetails();
            };
        }
    } else {
        priceBox.style.display = 'none';
        priceSection.style.display = 'none';
        disclaimerSection.style.display = 'none';

        if (isOwned) {
            ownedSection.style.display = 'flex';
            giftButton.style.display = 'none';
        } else {
            ownedSection.style.display = 'none';
        }
    }

    const changelogSection = document.getElementById('game-details-changelog-section');
    const changelogContainer = document.getElementById('game-details-changelog');

    if (game.changelog || game.updates) {
        changelogSection.style.display = 'block';
        changelogContainer.innerHTML = game.changelog || game.updates || 'No recent updates';
    } else {
        changelogSection.style.display = 'none';
    }

    const externalSection = document.getElementById('game-details-external-section');
    const externalLink = document.getElementById('game-details-external-link');

    if (game.externalLink) {
        externalSection.style.display = 'block';
        externalLink.href = game.externalLink;
    } else {
        externalSection.style.display = 'none';
    }
}

function toggleDisclaimer() {
    const disclaimerContent = document.getElementById('disclaimer-content');
    const disclaimerToggle = document.getElementById('disclaimer-toggle');

    if (disclaimerContent.classList.contains('collapsed')) {
        disclaimerContent.classList.remove('collapsed');
        disclaimerToggle.innerHTML = '<i class="fa-solid fa-chevron-up"></i>';
    } else {
        disclaimerContent.classList.add('collapsed');
        disclaimerToggle.innerHTML = '<i class="fa-solid fa-chevron-down"></i>';
    }
}

window.showGameDetails = showGameDetails;
window.closeGameDetails = closeGameDetails;
window.toggleDisclaimer = toggleDisclaimer;
function displayGames() {
    const container = document.getElementById('games-grid');
    container.innerHTML = '';

    const userGameIds = gamesData.userGames.map(g => g.id);
    const tebexGames = gamesData.tebexGames || [];
    const regularGames = gamesData.allGames.filter(g => !g.isTebexProduct);

    const tebexGameTitles = tebexGames.map(g => g.title.toLowerCase());
    const gamesToDisplay = regularGames.filter(game =>
        !tebexGameTitles.includes(game.title.toLowerCase())
    );

    const allGamesToShow = [...gamesToDisplay, ...tebexGames];

    allGamesToShow.forEach(game => {
        const isOwned = userGameIds.includes(game.id) ||
            userGameIds.some(id => {
                const ownedGame = gamesData.userGames.find(g => g.id === id);
                return ownedGame && ownedGame.title.toLowerCase() === game.title.toLowerCase();
            });

        if (game.isTebexProduct) {
            VAPR.appendElement(container, 'tebex-game-item', {
                gameId: game.id,
                title: game.title,
                coverImage: game.coverImage,
                price: game.price.toFixed(2),
                currency: game.currency,
                onSale: game.onSale ? 'true' : '',
                originalPrice: game.originalPrice?.toFixed(2),
                discount: game.discount || 0,
                tebexId: game.tebexId,
                externalLink: game.externalLink || '',
                isOwned: isOwned ? 'true' : ''
            });
        } else {
            VAPR.appendElement(container, 'game-item', {
                gameId: game.id,
                title: game.title,
                description: game.description,
                coverImage: game.coverImage,
                isOwned: isOwned ? 'true' : '',
                isOwner: isUserLoggedIn() && game.ownerId === window.user.id ? 'true' : '',
                externalLink: game.externalLink || ''
            });
        }
    });

    VAPR.refresh();
}

function displayLibrary() {
    const container = document.getElementById('library-grid');
    container.innerHTML = '';

    if (gamesData.userGames.length === 0) {
        container.innerHTML += '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: rgba(255, 255, 255, 0.6);">No games in your library yet. Redeem a key to get started!</div>';
        return;
    }

    VAPR.appendElements(container, 'library-game-item',
        gamesData.userGames.map(game => {
            const isInstalled = gamesData.installedGames.some(g => g.id === game.id);
            const isDownloading = gamesData.downloadingGames.has(game.id);
            const isUpdating = gamesData.updatingGames.has(game.id);
            const installedGame = isInstalled ? gamesData.installedGames.find(g => g.id === game.id) : null;
            const hasUpdate = gamesData.updates.some(u => u.gameId === game.id);
            const updateInfo = hasUpdate ? gamesData.updates.find(u => u.gameId === game.id) : null;

            return {
                gameId: game.id,
                title: game.title,
                description: game.description,
                coverImage: game.coverImage,
                downloadUrl: game.downloadUrl || '',
                ownedAt: game.ownedAt,
                isInstalled: isInstalled ? 'true' : '',
                isDownloading: isDownloading ? 'true' : '',
                isUpdating: isUpdating ? 'true' : '',
                hasUpdate: hasUpdate ? 'true' : '',
                installedVersion: installedGame?.version || game.installedVersion || '',
                latestVersion: updateInfo?.toVersion || game.currentVersion || '',
                ...(installedGame?.executable && { executable: installedGame.executable.replaceAll('\\','/') }),
                ...(isDownloading && { downloadProgress: gamesData.downloadingGames.get(game.id) || 0 })
            };
        })
    );

    VAPR.refresh();
}
async function downloadGame(event, gameId, gameTitle, downloadUrl) {
    event.stopPropagation();

    if (!isRunningInTauri()) {
        notify.desktopAppPrompt(() => downloadDesktopApp());
        return;
    }

    gamesData.downloadingGames.set(gameId, 0);
    displayLibrary();

    try {
        const unlisten = await window.__TAURI__.event.listen('download-progress', (event) => {
            const progress = event.payload;
            if (progress.game_id === gameId) {
                gamesData.downloadingGames.set(gameId, progress.percentage);
                updateGameDownloadProgress(gameId, progress);
            }
        });

        const statusUnlisten = await window.__TAURI__.event.listen('download-status', (event) => {
            const data = event.payload;
            if (data.game_id === gameId) {
                updateGameDownloadStatus(gameId, data.status);
            }
        });

        const result = await window.__TAURI__.core.invoke('download_and_install_game', {
            gameId: gameId,
            gameName: gameTitle,
            downloadUrl: downloadUrl
        });

        unlisten();
        statusUnlisten();

        if (result.success) {
            gamesData.downloadingGames.delete(gameId);
            notify.success(`${gameTitle} installed successfully!`);
            await loadLibraryData();
        } else {
            throw new Error(result.error || 'Installation failed');
        }
    } catch (error) {
        console.error('Error downloading game:', error);
        gamesData.downloadingGames.delete(gameId);
        displayLibrary();
        notify.error('Download Failed', error.message || 'Failed to download the game. Please try again.');
    }
}

function updateGameDownloadProgress(gameId, progress) {
    const gameEl = document.getElementById(`game-item-${gameId}`);
    if (!gameEl) return;

    const progressFill = gameEl.querySelector('.download-progress-fill');
    const progressValue = gameEl.querySelector('.download-stat-value');
    const speedEl = document.getElementById(`download-speed-${gameId}`);
    const sizeEl = document.getElementById(`download-size-${gameId}`);
    const etaEl = document.getElementById(`download-eta-${gameId}`);

    if (progressFill) progressFill.style.width = `${progress.percentage}%`;
    if (progressValue) progressValue.textContent = `${Math.round(progress.percentage)}%`;
    if (speedEl) speedEl.textContent = `${progress.speed.toFixed(2)} MB/s`;

    if (sizeEl) {
        const downloaded = (progress.downloaded / 1024 / 1024).toFixed(2);
        const total = (progress.total / 1024 / 1024).toFixed(2);
        sizeEl.textContent = `${downloaded} MB / ${total} MB`;
    }

    if (etaEl) {
        etaEl.textContent = formatTime(progress.eta);
    }
}

function updateGameDownloadStatus(gameId, statusText) {
    const gameEl = document.getElementById(`game-item-${gameId}`);
    if (!gameEl) return;

    const subtitleEl = gameEl.querySelector('.download-progress-subtitle');
    if (subtitleEl) subtitleEl.textContent = statusText;
}

function cancelDownload(gameId) {
    gamesData.downloadingGames.delete(gameId);
    gamesData.updatingGames.delete(gameId);
    displayLibrary();
}

async function uninstallGame(event, gameId, gameTitle) {
    event.stopPropagation();

    const confirmed = await notify.confirmDanger(
        'Uninstall Game?',
        `Are you sure you want to uninstall ${gameTitle}? This will remove all game files from your computer.`,
        'Yes, uninstall'
    );

    if (confirmed) {
        try {
            await window.__TAURI__.core.invoke('uninstall_game', { gameId });
            notify.success(`${gameTitle} uninstalled successfully`);
            await loadLibraryData();
        } catch (error) {
            console.error('Error uninstalling game:', error);
            notify.error('Uninstall Failed', error.message || 'Failed to uninstall the game. Please try again.');
        }
    }
}

async function launchGame(event, executablePath) {
    event.stopPropagation();

    if (!isRunningInTauri()) return;

    const button = event.target.closest('button');
    const originalContent = button.innerHTML;
    button.disabled = true;
    button.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Launching...';

    try {
        console.log({executablePath});
        await window.__TAURI__.core.invoke('launch_game', {
            executablePath: executablePath
        });
        notify.success("Game launched!");
    } catch (error) {
        console.error('Error launching game:', error);
        notify.error('Launch Failed', error.message || 'Failed to launch the game. Please try again.');
    } finally {
        button.disabled = false;
        button.innerHTML = originalContent;
    }
}

async function downloadUpdate(gameId, version, downloadUrl) {
    if (!isRunningInTauri()) {
        notify.desktopAppPrompt(() => downloadDesktopApp());
        return;
    }

    const game = gamesData.userGames.find(g => g.id === gameId);
    if (!game) return;

    gamesData.updatingGames.set(gameId, true);
    gamesData.downloadingGames.set(gameId, 0);

    await markUpdateSeen(gameId);

    displayLibrary();

    try {
        const unlisten = await window.__TAURI__.event.listen('download-progress', (event) => {
            const progress = event.payload;
            if (progress.game_id === gameId) {
                gamesData.downloadingGames.set(gameId, progress.percentage);
                updateGameDownloadProgress(gameId, progress);
            }
        });

        const statusUnlisten = await window.__TAURI__.event.listen('download-status', (event) => {
            const data = event.payload;
            if (data.game_id === gameId) {
                updateGameDownloadStatus(gameId, data.status);
            }
        });

        const result = await window.__TAURI__.core.invoke('download_and_install_game', {
            gameId: gameId,
            gameName: game.title,
            downloadUrl: downloadUrl
        });

        unlisten();
        statusUnlisten();

        if (result.success) {
            await markUpdateDownloaded(gameId, version);

            gamesData.updates = gamesData.updates.filter(u => u.gameId !== gameId);

            if (gamesData.updates.length === 0) {
                const updateBadge = document.querySelector('.update-badge');
                if (updateBadge) updateBadge.remove();
            }

            gamesData.downloadingGames.delete(gameId);
            gamesData.updatingGames.delete(gameId);

            notify.success(`${game.title} updated to v${version}!`);
            await loadLibraryData();
        } else {
            throw new Error(result.error || 'Update failed');
        }
    } catch (error) {
        console.error('Error updating game:', error);
        gamesData.downloadingGames.delete(gameId);
        gamesData.updatingGames.delete(gameId);
        displayLibrary();
        notify.error('Update Failed', error.message || 'Failed to update the game. Please try again.');
    }
}

function formatTime(seconds) {
    if (seconds === 0) return 'Calculating...';

    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
        return `${hours}h ${minutes}m remaining`;
    } else if (minutes > 0) {
        return `${minutes}m ${secs}s remaining`;
    } else {
        return `${secs}s remaining`;
    }
}
cardManager.register('games-card', {
    onLoad: async () => {
        await Promise.all([
            loadGamesData(),
            loadTebexGames()
        ]);
    }
});

cardManager.register('library-card', {
    onLoad: async () => {
        await loadLibraryData();
    }
});

function initGameEventListeners() {
    const gamesGrid = document.getElementById('games-grid');
    if (gamesGrid) {
        gamesGrid.addEventListener('click', (e) => {
            const gameItem = e.target.closest('.game-item');
            if (gameItem && !e.target.closest('button')) {
                const gameId = gameItem.id.replace('game-item-', '');
                const game = gamesData.allGames.find(g => g.id === gameId);
                if (game && game.externalLink) {
                    window.open(game.externalLink, '_blank');
                }
            }
        });
    }
}

async function openGamesShowcase() {
    await cardManager.show('games-card');
}

async function openMyLibrary() {
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }
    await cardManager.show('library-card');
}

function closeGamesCard() {
    cardManager.hide('games-card');
}

function closeLibraryCard() {
    cardManager.hide('library-card');
}

function openRedeemModal() {
    document.getElementById('redeem-modal').style.display = 'flex';
    document.getElementById('game-key-input').value = '';
    document.getElementById('game-key-input').focus();
}

function closeRedeemModal() {
    document.getElementById('redeem-modal').style.display = 'none';
}

async function redeemKey(event) {
    event.preventDefault();

    const keyInput = document.getElementById('game-key-input');
    const key = keyInput.value.trim();

    try {
        const response = await api.request('/api/games/redeem-key', {
            method: 'POST',
            body: { key }
        });

        if (response.success) {
            closeRedeemModal();

            await notify.confirm(
                'Success!',
                `You now own ${response.game.title}!`,
                {
                    icon: 'success',
                    confirmButtonText: 'View Library',
                    showCancelButton: false
                }
            );

            closeGamesCard();
            openMyLibrary();
            await loadLibraryData();
        }
    } catch (error) {
        notify.error('Invalid Key', error.message || 'The key you entered is invalid or has already been used.');
    }
}

async function openKeyManagement(gameId) {
    const game = gamesData.allGames.find(g => g.id === gameId) ||
        developerData.myGames.find(g => g.id === gameId);

    if (!game) return;

    gamesData.currentManagingGame = game;

    let existingCard = document.getElementById('key-management-card');
    if (!existingCard) {
        const keyCard = VAPR.createElement('key-management-card', {
            gameTitle: game.title
        });
        document.querySelector('#feed').appendChild(keyCard);

        VAPR.refresh();

        cardManager.register('key-management-card', {
            onLoad: async () => {
                if (gamesData.currentManagingGame) {
                    await loadGameKeys(gamesData.currentManagingGame.id);
                }
            }
        });
    }

    await cardManager.show('key-management-card');
}

async function openVersionManagement(gameId) {
    const game = gamesData.allGames.find(g => g.id === gameId) ||
        developerData.myGames.find(g => g.id === gameId);

    if (!game) return;

    gamesData.currentManagingGame = game;

    let existingCard = document.getElementById('version-management-card');
    if (!existingCard) {
        const versionCard = VAPR.createElementWithContent('version-management-card',
            { gameTitle: game.title },
            `<version-form></version-form>
             <div class="versions-list" id="versions-list"></div>`
        );
        document.querySelector('#feed').appendChild(versionCard);

        VAPR.refresh();

        cardManager.register('version-management-card', {
            onLoad: async () => {
                if (gamesData.currentManagingGame) {
                    await loadGameVersions(gamesData.currentManagingGame.id);
                }
            }
        });
    }

    await cardManager.show('version-management-card');
}

function closeKeyManagementCard() {
    cardManager.hide('key-management-card');
}

function closeVersionManagementCard() {
    cardManager.hide('version-management-card');
}

document.addEventListener('DOMContentLoaded', () => {
    initGameEventListeners();
    if (isUserLoggedIn()) {
        setTimeout(checkAndShowUpdates, 3000);
    }
});

setInterval(() => {
    if (isUserLoggedIn()) {
        checkAndShowUpdates();
    }
}, 5 * 60 * 1000);

window.openGamesShowcase = openGamesShowcase;
window.openMyLibrary = openMyLibrary;
window.closeGamesCard = closeGamesCard;
window.closeLibraryCard = closeLibraryCard;
window.openRedeemModal = openRedeemModal;
window.closeRedeemModal = closeRedeemModal;
window.redeemKey = redeemKey;
window.openGameManagement = openGameManagement;
window.openKeyManagement = openKeyManagement;
window.openVersionManagement = openVersionManagement;
window.closeKeyManagementCard = closeKeyManagementCard;
window.closeVersionManagementCard = closeVersionManagementCard;
window.downloadGame = downloadGame;
window.cancelDownload = cancelDownload;
window.uninstallGame = uninstallGame;
window.launchGame = launchGame;
window.downloadUpdate = downloadUpdate;
window.downloadFilteredKeys = downloadFilteredKeys;
window.filterKeys = filterKeys;
window.generateKeys = generateKeys;
window.copyKey = copyKey;
window.publishVersion = publishVersion;
window.initGameEventListeners = initGameEventListeners;
async function loadGameKeys(gameId) {
    try {
        const response = await api.request(`/api/games/${gameId}/keys`);

        if (response.success) {
            gamesData.allKeys = response.keys;
            updateKeyStats();
            displayKeys(response.keys);
        }
    } catch (error) {
        console.error('Error loading keys:', error);
    }
}

function updateKeyStats() {
    const totalKeys = gamesData.allKeys.length;
    const usedKeys = gamesData.allKeys.filter(k => k.usedBy).length;
    const availableKeys = totalKeys - usedKeys;

    document.getElementById('total-keys').textContent = totalKeys;
    document.getElementById('used-keys').textContent = usedKeys;
    document.getElementById('available-keys').textContent = availableKeys;
}

function filterKeys(tag) {
    gamesData.currentKeyFilter = tag;

    document.querySelectorAll('.tag-filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');

    let filteredKeys = gamesData.allKeys;

    if (tag !== 'all') {
        filteredKeys = gamesData.allKeys.filter(key => {
            if (tag === '') return !key.tag || key.tag === null;
            return key.tag === tag;
        });
    }

    displayKeys(filteredKeys);
}

function displayKeys(keys) {
    const container = document.getElementById('keys-list');
    container.innerHTML = '';

    if (keys.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 20px; color: rgba(255, 255, 255, 0.6);">No keys found</div>';
        return;
    }

    VAPR.appendElements(container, 'game-key-item',
        keys.map(key => ({
            keyCode: key.key,
            tag: key.tag || '',
            isUsed: key.usedBy ? 'true' : 'false',
            ...(key.usedBy && key.userInfo && {
                usedByUsername: key.userInfo.username,
                usedById: key.userInfo.id,
                usedByAvatar: key.userInfo.avatar || '',
                usedAt: key.usedAt
            })
        }))
    );

    VAPR.refresh();
}

async function generateKeys() {
    if (!gamesData.currentManagingGame) return;

    const count = parseInt(document.getElementById('key-count').value) || 5;
    const tag = document.getElementById('key-tag').value || null;

    try {
        const response = await api.request(`/api/games/${gamesData.currentManagingGame.id}/generate-keys`, {
            method: 'POST',
            body: { count, tag }
        });

        if (response.success) {
            notify.success(`${count} keys generated successfully!`);
            await loadGameKeys(gamesData.currentManagingGame.id);
        }
    } catch (error) {
        console.error('Error generating keys:', error);
    }
}

function copyKey(key) {
    notify.copyToClipboard(key, "Key copied to clipboard!");
}

async function downloadFilteredKeys() {
    if (!gamesData.currentManagingGame) return;

    const tag = gamesData.currentKeyFilter === 'all' ? null : gamesData.currentKeyFilter;

    try {
        const url = `/api/games/${gamesData.currentManagingGame.id}/keys/download${tag !== null ? `?tag=${encodeURIComponent(tag)}` : ''}`;

        const response = await fetch(url, {
            method: 'GET',
            credentials: 'include'
        });

        if (!response.ok) {
            throw new Error('Failed to download keys');
        }

        const blob = await response.blob();
        const downloadUrl = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = downloadUrl;

        const filename = `${gamesData.currentManagingGame.title.replace(/[^a-z0-9]/gi, '_')}_keys${tag ? `_${tag}` : ''}.csv`;
        a.download = filename;

        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(downloadUrl);
        document.body.removeChild(a);

        notify.success("Keys downloaded successfully!");
    } catch (error) {
        console.error('Error downloading keys:', error);
        notify.error('Download Failed', 'Failed to download keys. Please try again.');
    }
}
async function openGameManagement(event, gameId) {
    event.stopPropagation();
    openKeyManagement(gameId);
}
function openRedeemModal() {
    document.getElementById('redeem-modal').style.display = 'flex';
    document.getElementById('game-key-input').value = '';
    document.getElementById('game-key-input').focus();
}

function closeRedeemModal() {
    document.getElementById('redeem-modal').style.display = 'none';
}

async function redeemKey(event) {
    event.preventDefault();

    const keyInput = document.getElementById('game-key-input');
    const key = keyInput.value.trim();

    try {
        const response = await api.request('/api/games/redeem-key', {
            method: 'POST',
            body: { key }
        });

        if (response.success) {
            closeRedeemModal();

            await notify.confirm(
                'Success!',
                `You now own ${response.game.title}!`,
                {
                    icon: 'success',
                    confirmButtonText: 'View Library',
                    showCancelButton: false
                }
            );

            closeGamesCard();
            openMyLibrary();
            await loadLibraryData();
        }
    } catch (error) {
        notify.error('Invalid Key', error.message || 'The key you entered is invalid or has already been used.');
    }
}
window.gamesData = {
    allGames: [],
    userGames: [],
    currentManagingGame: null,
    installedGames: [],
    downloadingGames: new Map(),
    currentKeyFilter: 'all',
    allKeys: [],
    updates: [],
    versions: [],
    updatingGames: new Map()
};
async function loadTebexGames() {
    try {
        const tebexResponse = await tebexAPI.getPackages();
        const tebexGames = tebexResponse.data || [];

        console.log({tebexGames});

        const transformedGames = transformTebexGames(tebexGames);

        gamesData.tebexGames = transformedGames;

        displayGames();
    } catch (error) {
        console.error('Error loading Tebex games:', error);
    }
}

function transformTebexGames(tebexPackages) {
    return tebexPackages.map(pkg => ({
        id: `tebex-${pkg.id}`,
        title: pkg.name,
        description: pkg.description,
        coverImage: pkg.image || 'https://via.placeholder.com/300x169',
        price: pkg.total_price,
        currency: pkg.currency,
        isTebexProduct: true,
        tebexId: pkg.id,
        category: pkg.category?.name || 'Games',
        onSale: pkg.discount > 0,
        originalPrice: pkg.base_price,
        salePrice: pkg.total_price,
        discount: pkg.discount
    }));
}
async function initializeTebexIntegration() {
    if (!window.tebexCart) {
        window.tebexCart = new TebexCart();
    }

    if (isUserLoggedIn()) {
        await tebexCart.initialize();
    }
}

async function addToCart(tebexPackageId) {
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }

    await tebexCart.addItem(tebexPackageId);
}

function openCart() {
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }

    cardManager.show('cart-modal');
    tebexCart.refreshCart();
}

function closeCart() {
    cardManager.hide('cart-modal');
}

function handleCheckoutSuccess() {
    tebexCart.clearCart();

    notify.success('Purchase completed successfully!');

    if (window.loadLibraryData) {
        loadLibraryData();
    }
}

function handleCheckoutCancel() {
    notify.info('Checkout cancelled');
}

document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);

    if (window.location.pathname === '/checkout/success') {
        handleCheckoutSuccess();
        window.history.replaceState({}, '', '/');
    } else if (window.location.pathname === '/checkout/cancel') {
        handleCheckoutCancel();
        window.history.replaceState({}, '', '/');
    }

    if (isUserLoggedIn()) {
        initializeTebexIntegration();
    }
});

cardManager.register('cart-modal', {
    onShow: () => {
        tebexCart.refreshCart();
    }
});

const originalLoadUserData = window.loadUserData;
window.loadUserData = function() {
    originalLoadUserData();
    setTimeout(() => {
        initializeTebexIntegration();
    }, 500);
};

window.addToCart = addToCart;
window.openCart = openCart;
window.closeCart = closeCart;
async function checkForGameUpdates() {
    return api.request('/api/updates/check');
}

async function markUpdateSeen(gameId) {
    return api.request(`/api/updates/${gameId}/seen`, {
        method: 'POST'
    });
}

async function markUpdateDownloaded(gameId, version) {
    return api.request(`/api/updates/${gameId}/downloaded`, {
        method: 'POST',
        body: { version }
    });
}

async function checkAndShowUpdates() {
    if (!isUserLoggedIn()) return;

    try {
        const response = await checkForGameUpdates();
        if (response.success && response.updates.length > 0) {
            gamesData.updates = response.updates;
            showUpdateNotification(response.updates.length);
        }
    } catch (error) {
        console.error('Error checking for updates:', error);
    }
}

function showUpdateNotification(count) {
    const libraryMenuItems = document.querySelectorAll('.menu-item');
    libraryMenuItems.forEach(item => {
        const icon = item.querySelector('.menu-item-icon.library');
        if (icon && !icon.querySelector('.update-badge')) {
            const badge = document.createElement('span');
            badge.className = 'update-badge';
            badge.textContent = count;
            icon.appendChild(badge);
        }
    });
}
function isRunningInTauri() {
    return typeof window.__TAURI__ !== 'undefined';
}

function isGameDeveloper() {
    if (!window.user) return false;

   
    return gamesData.allGames.some(game => game.ownerId === window.user.id);
}
async function createVersion(gameId, versionData) {
    return api.request(`/api/games/${gameId}/versions`, {
        method: 'POST',
        body: versionData
    });
}

async function getVersions(gameId) {
    return api.request(`/api/games/${gameId}/versions`);
}

function toggleUploadMethod(method) {
    const urlGroup = document.getElementById('url-input-group');
    const fileGroup = document.getElementById('file-input-group');
    const sizeGroup = document.getElementById('size-input-group');
    const methodBtns = document.querySelectorAll('.method-btn');

    methodBtns.forEach(btn => btn.classList.remove('active'));
    event.target.closest('.method-btn').classList.add('active');

    if (method === 'url') {
        urlGroup.style.display = 'block';
        fileGroup.style.display = 'none';
        sizeGroup.style.display = 'block';
    } else {
        urlGroup.style.display = 'none';
        fileGroup.style.display = 'block';
        sizeGroup.style.display = 'none';
    }
}

function clearFileUpload(event) {
    event.stopPropagation();
    const fileInput = document.getElementById('version-file');
    fileInput.value = '';
    document.getElementById('file-upload-placeholder').style.display = 'flex';
    document.getElementById('file-upload-preview').style.display = 'none';
}

async function publishVersion() {
    if (!gamesData.currentManagingGame) return;

    const versionNumber = document.getElementById('version-number').value;
    const changelog = document.getElementById('version-changelog').value;
    const isRequired = document.getElementById('version-required').checked;

    const isFileUpload = document.getElementById('file-input-group').style.display !== 'none';

    if (!versionNumber) {
        notify.warning('Missing Information', 'Please fill in version number');
        return;
    }

    const publishBtn = event.target;
    const originalText = publishBtn.innerHTML;
    publishBtn.disabled = true;
    publishBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Publishing...';

    try {
        let downloadUrl, size;

        if (isFileUpload) {
            const fileInput = document.getElementById('version-file');
            const file = fileInput.files[0];

            if (!file) {
                notify.warning('No file selected', 'Please select a ZIP file to upload');
                publishBtn.disabled = false;
                publishBtn.innerHTML = originalText;
                return;
            }

            publishBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Uploading file...';

            const formData = new FormData();
            formData.append('file', file);

            const uploadResponse = await fetch(`/api/games/${gamesData.currentManagingGame.id}/upload-update`, {
                method: 'POST',
                body: formData,
                credentials: 'include'
            });

            const uploadResult = await uploadResponse.json();

            if (!uploadResult.success) {
                throw new Error(uploadResult.error || 'Failed to upload file');
            }

            downloadUrl = uploadResult.downloadUrl;
            size = uploadResult.size;

            publishBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Creating version...';
        } else {
            downloadUrl = document.getElementById('version-url').value;
            size = document.getElementById('version-size').value;

            if (!downloadUrl) {
                notify.warning('Missing Information', 'Please fill in download URL');
                publishBtn.disabled = false;
                publishBtn.innerHTML = originalText;
                return;
            }
        }

        const response = await createVersion(gamesData.currentManagingGame.id, {
            version: versionNumber,
            downloadUrl,
            size: size ? parseInt(size) : null,
            changelog,
            isRequired
        });

        if (response.success) {
            notify.success('Version published successfully!');

            document.getElementById('version-number').value = '';
            document.getElementById('version-url').value = '';
            document.getElementById('version-size').value = '';
            document.getElementById('version-changelog').value = '';
            document.getElementById('version-required').checked = false;

            if (isFileUpload) {
                clearFileUpload({ stopPropagation: () => {} });
            }

            await loadGameVersions(gamesData.currentManagingGame.id);
        }
    } catch (error) {
        console.error('Error publishing version:', error);
        notify.error('Failed to publish version', error.message);
    } finally {
        publishBtn.disabled = false;
        publishBtn.innerHTML = originalText;
    }
}

async function loadGameVersions(gameId) {
    try {
        const response = await getVersions(gameId);
        if (response.success) {
            displayVersions(response.versions);
        }
    } catch (error) {
        console.error('Error loading versions:', error);
    }
}

function displayVersions(versions) {
    const container = document.getElementById('versions-list');
    if (!container) return;

    container.innerHTML = '<h4>Version History</h4>';

    if (versions.length === 0) {
        container.innerHTML += '<p class="no-versions">No versions published yet</p>';
        return;
    }

    VAPR.appendElements(container, 'version-item',
        versions.map(version => ({
            version: version.version,
            changelog: version.changelog || '',
            downloads: version.downloads || 0,
            isRequired: version.isRequired ? 'true' : '',
            createdAt: version.createdAt
        }))
    );

    VAPR.refresh();
}

function handleVersionFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    if (!file.name.toLowerCase().endsWith('.zip')) {
        notify.error('Invalid file type', 'Please select a ZIP file');
        event.target.value = '';
        return;
    }

    const maxSize = 500 * 1024 * 1024;
    if (file.size > maxSize) {
        notify.error('File too large', 'Maximum file size is 500MB');
        event.target.value = '';
        return;
    }

    document.getElementById('file-upload-placeholder').style.display = 'none';
    document.getElementById('file-upload-preview').style.display = 'flex';
    document.getElementById('file-name').textContent = file.name;
    document.getElementById('file-size').textContent = `(${(file.size / 1024 / 1024).toFixed(2)} MB)`;
}

function initVersionFileUpload() {
    const uploadArea = document.querySelector('.file-upload-area');
    if (!uploadArea) return;

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        uploadArea.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
        uploadArea.addEventListener(eventName, () => {
            uploadArea.classList.add('dragging');
        }, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
        uploadArea.addEventListener(eventName, () => {
            uploadArea.classList.remove('dragging');
        }, false);
    });

    uploadArea.addEventListener('drop', handleDrop, false);

    function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;

        if (files.length > 0) {
            const fileInput = document.getElementById('version-file');
            fileInput.files = files;
            handleVersionFileSelect({ target: fileInput });
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const fileInput = document.getElementById('version-file');
    if (fileInput) {
        fileInput.addEventListener('change', handleVersionFileSelect);
    }
});

VAPR.on('.version-form', 'mounted', () => {
    initVersionFileUpload();
});

window.toggleUploadMethod = toggleUploadMethod;
window.clearFileUpload = clearFileUpload;
window.handleVersionFileSelect = handleVersionFileSelect;
async function updateGithubStars(element) {
    try {
        const response = await fetch('https://api.github.com/repos/Vic92548/VAPR');
        if (!response.ok) throw new Error('GitHub API error');

        const data = await response.json();
        const stars = data.stargazers_count;

        element.innerHTML = `<i class="fa-solid fa-star"></i> ${stars}`;
    } catch (error) {
        console.error('Failed to fetch GitHub stars:', error);
        element.innerHTML = '<i class="fa-solid fa-star"></i> N/A';
    }
}

if (window.VAPR) {
    VAPR.on('#github_stars', 'mounted', (element) => {
        console.log({element});
        console.log(element.querySelector('.menu-badge'));
        updateGithubStars(element.querySelector('.menu-badge'));
    });
}
function makeImageBig(img) {
    img.classList.remove("normal_image");
    img.classList.add("big_image");
    window.analytics.track('image_zoom_out', { post: current_post });
}

function makeImageNormal(img) {
    img.classList.remove("big_image");
    img.classList.add("normal_image");
    window.analytics.track('image_zoom_in', { post: current_post });
}

function switchImage(img) {
    if(img.classList.contains("big_image")){
        makeImageNormal(img);
    }else{
        makeImageBig(img);
    }
}
function initPlayerPreferences() {
    if (!window.user) {
        const backgroundUrl = localStorage.getItem('background_url');

        if(backgroundUrl){
            equipBackground(backgroundUrl, false);
        }
    }
}

initPlayerPreferences();
let feed_posts = [];
let loading_steps = 2;
let post_seen = 0;
let creators = {};

function showInitialPost() {
    const path = window.location.pathname.split('/');

    if(path.length < 3){
        displayPost();
    }else if(path[1] === "post"){
        displayPost(path[2]);
    }
}

function isUserLoggedIn(){
    if(window.user){
        return true;
    }else{
        return false;
    }
}

function updateUsername() {
    const level_elements = document.getElementsByClassName("username");
    for (let i = 0; i < level_elements.length; i++) {
        level_elements[i].textContent = user.username;
        console.log("updated username : " + user.username);
    }
}

loadUserData();

function hideLoading(){
    console.log("steps:"+loading_steps);
}

function showLoading(){
}

function setupSocialLink(id, link){
    const link_bt = document.getElementById(id);
    link_bt.style.display = "inline-block";
    link_bt.href = link;
}

let current_post_id = undefined;
let current_post = undefined;

function hidePost() {
    showLoading();
    document.getElementById("post_video").children[0].src = "";
    document.getElementsByClassName("post")[0].style.transform = "translateY(100vh)";
}

cardManager.register('add-post-card', {
    onShow: () => {
        setTimeout(() => {
            const titleInput = document.getElementById('title');
            if (titleInput) titleInput.focus();
        }, 500);
    }
});

function opeNewPostModel() {
    if (isUserLoggedIn()) {
        cardManager.show('add-post-card');
    } else {
        openRegisterModal();
    }
}

function closeAddPostCard() {
    cardManager.hide('add-post-card');
}

function closeNewPostModel() {
    closeAddPostCard();
}

function openRegisterModal() {
    document.getElementById("register").style.display = "flex";
}

async function updateFollowButton() {
    const follow_bt = document.getElementById("follow");

    if(isUserLoggedIn()){
        let following;

        console.log("CURRENT POST");
        console.log(current_post);

        if(creators[current_post.userId]){
            following = creators[current_post.userId].following;
        }else{
            creators[current_post.userId] = {
                following: false
            }
        }

        if(following === undefined){
            following = await checkUserFollowsCreator(current_post.userId);
            creators[current_post.userId].following = following;
        }

        follow_bt.style.opacity = "0";
        follow_bt.style.display = "inline-block";

        if(following){
            follow_bt.innerHTML = '<i class="fa-solid fa-user-minus"></i>';
            follow_bt.onclick = unfollowPost;
            follow_bt.style.border = "1px solid rgb(206 220 247 / 42%)";
            follow_bt.style.backgroundColor = "rgb(190 213 255 / 40%)";
        }else{
            follow_bt.innerHTML = '<i class="fa-solid fa-user-plus"></i>';
            follow_bt.onclick = followPost;
            follow_bt.style.border = "1px solid rgb(77 137 245)";
            follow_bt.style.backgroundColor = "rgb(95 148 243)";
        }

        follow_bt.style.opacity = "1";

        if(current_post.userId === user.id){
            follow_bt.style.opacity = "0";
            follow_bt.style.display = "none";
        }
    }else{
        follow_bt.onclick = openRegisterModal;
    }
}

function followPost() {
    creators[current_post.userId].following = true;
    updateFollowButton();
    if(isUserLoggedIn()){
        APIHandler.handle(
            () => api.followPost(current_post.id),
            {
                errorMessage: 'Error when trying to follow. Please try again.'
            }
        );
    }else{
        openRegisterModal();
    }
}

function unfollowPost() {
    creators[current_post.userId].following = false;
    updateFollowButton();
    if(isUserLoggedIn()){
        APIHandler.handle(
            () => api.unfollowPost(current_post.id)
        );
    }else{
        openRegisterModal();
    }
}

async function checkUserFollowsCreator(creatorId) {
    try {
        const isFollowing = await api.checkFollowStatus(creatorId);
        console.log('Check follow status:', isFollowing);
        return isFollowing;
    } catch (error) {
        console.error('Error checking follow status:', error);
        return false;
    }
}

function openMenu() {
    document.getElementById("menu").style.display = 'flex';
}

function hideMenu() {
    if(window.innerWidth <= 768){
        document.getElementById("menu").style.display = 'none';
    }
}

if(MainPage){
    if(window.innerWidth >= 768){
        document.getElementById("menu").style.display = 'flex';
    }
}

function processJoinQueryParam() {
    const url = new URL(window.location.href);
    const params = url.searchParams;

    if (params.has('join')) {
        const joinValue = params.get('join');
        console.log("Join param found with value = " + joinValue);
        localStorage.setItem('referrerId', joinValue);
        params.delete('join');
        window.history.replaceState({}, '', url.toString());
    }
}

function handleReferral() {
    const referrerId = localStorage.getItem('referrerId');

    if (referrerId) {
        APIHandler.handle(
            () => api.acceptInvitation(referrerId),
            {
                onSuccess: (data) => {
                    console.log('Invitation processed:', data);
                    if(creators[referrerId]){
                        creators[referrerId].following = true;
                        updateFollowButton();
                    }
                    localStorage.removeItem('referrerId');
                },
                onError: (error) => {
                    localStorage.removeItem('referrerId');
                }
            }
        );
    }
}

function openTextModal(text) {
    document.getElementById("text_modal_text").textContent = text;
    document.getElementById("text_modal").style.display = 'block';
}

function closeTextModal() {
    document.getElementById("text_modal").style.display = 'none';
}

function copyReferrerId() {
    if(isUserLoggedIn()){
        const referralUrl = `https://vapr.club?join=${user.id}`;
        notify.copyToClipboard(referralUrl, "Invitation link copied to clipboard!");
    }else{
        openRegisterModal();
    }
}

processJoinQueryParam();

function hideWebOnly(){
    if(isRunningInTauri()){
        const webOnlyElements = document.getElementsByClassName('webOnly');
        for (let i = 0; i < webOnlyElements.length; i++) {
            webOnlyElements[i].style.display = 'none';
        }
    }
}

function navigateToMyProfile() {
    window.location.href = `/@${window.user.username}`;
}

if(MainPage){
    showInitialPost();

    hideWebOnly();
}
function initMenu() {
    if (!MainPage) return;

    if (isUserLoggedIn()) {
        updateMenuUserInfo();
        showMenuUserElements();
    }

    updateOnlineUsers();
    addMenuAnimations();

    if (window.innerWidth >= 769) {
        initMenuCollapseState();
        addCollapsedMenuInteractions();
    }
}

function updateDeveloperSection() {
    const devSection = document.querySelector('.menu-section[title="Developer"]');
    if (devSection) {
        devSection.style.display = isGameDeveloper() ? 'block' : 'none';
    }
}

function toggleMenuCollapse() {
    const menuContainer = document.querySelector('.menu-container');
    const mainElement = document.querySelector('main');
    const toggleButton = document.querySelector('.menu-toggle i');

    if (!menuContainer) return;

    menuContainer.classList.toggle('collapsed');

    if (mainElement) {
        mainElement.classList.toggle('menu-collapsed');
    }

    const isCollapsed = menuContainer.classList.contains('collapsed');
    localStorage.setItem('menuCollapsed', isCollapsed);

    updateMenuTooltips(isCollapsed);

    if (toggleButton) {
        toggleButton.style.transform = isCollapsed ? 'rotate(180deg)' : 'rotate(0deg)';
    }
}

function updateMenuTooltips(isCollapsed) {
    const menuItems = document.querySelectorAll('.menu-item');

    menuItems.forEach(item => {
        if (isCollapsed) {
            const title = item.querySelector('.menu-item-title');
            if (title) {
                item.setAttribute('data-tooltip', title.textContent);
            }
        } else {
            item.removeAttribute('data-tooltip');
        }
    });
}

function initMenuCollapseState() {
    const savedState = localStorage.getItem('menuCollapsed');
    const menuContainer = document.querySelector('.menu-container');
    const mainElement = document.querySelector('main');

    if (savedState === 'true' && menuContainer) {
        menuContainer.classList.add('collapsed');
        if (mainElement) {
            mainElement.classList.add('menu-collapsed');
        }
        updateMenuTooltips(true);

        const toggleButton = document.querySelector('.menu-toggle i');
        if (toggleButton) {
            toggleButton.style.transform = 'rotate(180deg)';
        }
    }
}

function addCollapsedMenuInteractions() {
    const menuContainer = document.querySelector('.menu-container');
    if (!menuContainer) return;
}

function updateMenuUserInfo() {
    if (!window.user) return;

    const menuAvatar = document.getElementById('menu_user_avatar');
    if (menuAvatar && window.user.avatar) {
        menuAvatar.src = `https://cdn.discordapp.com/avatars/${window.user.id}/${window.user.avatar}.png?size=128`;
    } else if (menuAvatar) {
        menuAvatar.src = 'https://vapr-club.b-cdn.net/default_vapr_avatar.png';
    }

    const menuUsername = document.getElementById('menu_username');
    if (menuUsername) {
        menuUsername.textContent = '@' + window.user.username;
    }

    const menuLevel = document.getElementById('menu_user_level');
    if (menuLevel) {
        menuLevel.textContent = window.user.level || 0;
    }

    updateMenuXPBar();
}

function updateMenuXPBar() {
    if (!window.user) return;

    const xp = window.user.xp || 0;
    const xpRequired = window.user.xp_required || 700;
    const xpPercentage = (xp / xpRequired) * 100;

    const xpBar = document.getElementById('menu_xp_bar');
    const xpText = document.getElementById('menu_xp_text');

    if (xpBar) {
        xpBar.style.width = xpPercentage + '%';
    }

    if (xpText) {
        xpText.textContent = `${xp} / ${xpRequired} XP`;
    }
}

function showMenuUserElements() {
    const userCard = document.getElementById('menu_user_info');
    const logoutBtn = document.getElementById('logout_btn');

    if (userCard) userCard.style.display = 'flex';
    if (logoutBtn) logoutBtn.style.display = 'flex';
}

async function updateOnlineUsers() {
    try {
        const data = await api.getUserCount();

        const onlineEl = document.getElementById('online_users');
        if (onlineEl && data.count) {
            onlineEl.textContent = data.count.toLocaleString() + ' users';
        }
    } catch (error) {
        console.error('Error fetching online users:', error);
    }
}

function addMenuAnimations() {
    const menuItems = document.querySelectorAll('.menu-item');

    menuItems.forEach((item, index) => {
        item.style.opacity = '0';
        item.style.transform = 'translateX(-20px)';

        setTimeout(() => {
            item.style.transition = 'all 0.3s ease';
            item.style.opacity = '1';
            item.style.transform = 'translateX(0)';
        }, index * 50);

        item.addEventListener('mouseenter', () => {
        });
    });
}

function isRunningInTauri() {
    return typeof window.__TAURI__ !== 'undefined';
}

function getLatestVersion() {
    const versionElement = document.querySelector('.menu-version span');
    if (versionElement) {
        const versionText = versionElement.textContent;
        const versionMatch = versionText.match(/v(\d+\.\d+\.\d+)/);
        if (versionMatch) {
            return versionMatch[1];
        }
    }
    return '1.1.19';
}

function downloadDesktopApp() {
    const version = getLatestVersion();
    const downloadUrl = `https://github.com/Vic92548/VAPR/releases/download/v${version}/VAPR_${version}_x64_en-US.msi`;

    if (window.analytics && window.analytics.track) {
        window.analytics.track('desktop_app_download_clicked', {
            version: version,
            platform: 'windows'
        });
    }

    window.open(downloadUrl, '_blank');

    notify.info("Download started!", `The VAPR desktop app download should begin shortly.<br><small>Windows 64-bit • v${version}</small>`, {
        timer: 5000
    });
}

function openMenu() {
    const menu = document.getElementById('menu');
    if (!menu) return;

    menu.style.display = 'flex';

    if (isUserLoggedIn()) {
        updateMenuUserInfo();
    }

    const menuContainer = menu.querySelector('.menu-container');
    if (menuContainer) {
        menuContainer.style.transform = 'translateX(-100%)';
        menuContainer.style.opacity = '0';

        setTimeout(() => {
            menuContainer.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
            menuContainer.style.transform = 'translateX(0)';
            menuContainer.style.opacity = '1';
        }, 10);
    }

    addMenuAnimations();
}

function hideMenu() {
    const menu = document.getElementById('menu');
    if (!menu) return;

    const menuContainer = menu.querySelector('.menu-container');
    if (menuContainer) {
        menuContainer.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        menuContainer.style.transform = 'translateX(-100%)';
        menuContainer.style.opacity = '0';

        setTimeout(() => {
            menu.style.display = 'none';
        }, 300);
    } else {
        menu.style.display = 'none';
    }
}

async function logout() {
    const confirmed = await notify.confirm('Logout', 'Are you sure you want to logout?');

    if (confirmed) {
        try {
            await fetch('/logout', {
                method: 'POST',
                credentials: 'include'
            });

            localStorage.removeItem('userData');

            if (window.clearSDKUserInfo) {
                window.clearSDKUserInfo();
            }

            window.user = null;
            window.location.href = '/';
        } catch (error) {
            console.error('Logout error:', error);
            window.location.href = '/';
        }
    }
}

let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        if (window.innerWidth < 769) {
            const menuContainer = document.querySelector('.menu-container');
            const mainElement = document.querySelector('main');

            if (menuContainer) {
                menuContainer.classList.remove('collapsed');
            }
            if (mainElement) {
                mainElement.classList.remove('menu-collapsed');
            }
        } else {
            initMenuCollapseState();
        }
    }, 250);
});

const originalOpenNewPostModel = window.opeNewPostModel;
window.opeNewPostModel = function() {
    hideMenu();
    originalOpenNewPostModel();
};

const originalOpenAnalytics = window.openAnalytics;
window.openAnalytics = function() {
    hideMenu();
    originalOpenAnalytics();
};

const originalOpenCustomizationMenu = window.openCustomizationMenu;
window.openCustomizationMenu = function() {
    hideMenu();
    originalOpenCustomizationMenu();
};

const originalOpenLeaderboardModal = window.openLeaderboardModal;
window.openLeaderboardModal = function() {
    hideMenu();
    originalOpenLeaderboardModal();
};

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        initMenu();

        if (window.innerWidth >= 769) {
            initMenuCollapseState();
        }

        if (window.user && window.VAPR) {
            insertVAPRUserInfo();
        }
    });

    const originalLoadUserData = window.loadUserData;
    window.loadUserData = function() {
        originalLoadUserData();
        setTimeout(() => {
            initMenu();
            if (window.user && window.VAPR) {
                insertVAPRUserInfo();
            }
        }, 500);
    };
}

function insertVAPRUserInfo() {
    const menuHeader = document.querySelector('.menu-header');
    if (!menuHeader) return;

    const container = menuHeader.parentElement;
    const menuNav = container.querySelector('.menu-nav');

    const existingUserInfo = document.getElementById('menu_user_info');
    if (existingUserInfo) existingUserInfo.remove();

    const avatarUrl = window.user.avatar
        ? `https://cdn.discordapp.com/avatars/${window.user.id}/${window.user.avatar}.png?size=128`
        : 'https://vapr-club.b-cdn.net/default_vapr_avatar.png';

    const xpPercent = ((window.user.xp || 0) / (window.user.xp_required || 700)) * 100;

    const userInfo = document.createElement('user-info-card');
    userInfo.setAttribute('id', 'menu_user_info');
    userInfo.setAttribute('avatar', avatarUrl);
    userInfo.setAttribute('username', '@' + window.user.username);
    userInfo.setAttribute('level', window.user.level || 0);
    userInfo.setAttribute('xp', window.user.xp || 0);
    userInfo.setAttribute('xp-required', window.user.xp_required || 700);
    userInfo.setAttribute('xp-percent', xpPercent.toFixed(1));

    container.insertBefore(userInfo, menuNav);
}

window.toggleMenuCollapse = toggleMenuCollapse;
window.openMenu = openMenu;
window.hideMenu = hideMenu;
window.logout = logout;
window.downloadDesktopApp = downloadDesktopApp;
function displayPage(type) {
    const post = document.getElementsByClassName("post")[0];
    const game = document.getElementsByClassName("game")[0];

    if(type === "post"){
        game.style.display = "none";
        post.style.display = "block";

        showPost();
    }else if(type === "game"){
        game.style.display = "block";
        post.style.display = "none";


    }
}
function drawPost(data){
    displayReactions();

    APIHandler.handle(
        () => api.registerView(data.id),
        {
            onSuccess: (data) => {
                console.log(data);
                console.log("Views updated");
            }
        }
    );

    post_seen++;
    showPost();
    console.log("Post DATA:");
    console.log(data);

    updateFollowButton();

    const titleEl = document.getElementById("post_title");
    const showMoreButtonEl = document.getElementById("post_title_show_more");
    titleEl.textContent = data.title;

    requestAnimationFrame(() => {
        const isClamped = titleEl.scrollHeight > titleEl.clientHeight;

        if (isClamped) {
            showMoreButtonEl.style.display = "inline-block";
            showMoreButtonEl.onclick = () => {
                titleEl.classList.toggle("expanded");
                const isExpanded = titleEl.classList.contains("expanded");
                showMoreButtonEl.innerHTML = isExpanded
                    ? `<i class="fa-solid fa-chevron-up"></i> Show less`
                    : `<i class="fa-solid fa-chevron-down"></i> Show more`;

                if (isExpanded) {
                    titleEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            };
        } else {
            showMoreButtonEl.style.display = "none";
        }
    });

    const username = data.username;
    document.getElementById("post_username").textContent = "@" + username;

    const avatarImg = document.getElementById("user_avatar_img");
    const avatarLetter = document.getElementById("avatar_letter");
    const avatarEl = document.getElementById("user_avatar");

    function showLetterAvatar() {
        avatarImg.style.display = "none";
        avatarLetter.style.display = "flex";
        avatarLetter.textContent = username.charAt(0).toUpperCase();

        const hue = username.charCodeAt(0) * 3 % 360;
        avatarEl.style.background = `linear-gradient(135deg, hsl(${hue}, 70%, 50%), hsl(${hue + 30}, 70%, 60%))`;
    }

    function showDiscordAvatar(avatarHash) {
        if (avatarHash) {
            avatarImg.src = `https://cdn.discordapp.com/avatars/${data.userId}/${avatarHash}.png?size=128`;
            avatarImg.style.display = "block";
            avatarLetter.style.display = "none";
            avatarEl.style.background = "none";

            avatarImg.onerror = () => {
                console.log("Failed to load Discord avatar, showing fallback");
                showLetterAvatar();
            };
        } else {
            showLetterAvatar();
        }
    }

    if (data.userAvatar !== undefined) {
        showDiscordAvatar(data.userAvatar);

        if (!window.creators) {
            window.creators = {};
        }
        if (!window.creators[data.userId]) {
            window.creators[data.userId] = {};
        }
        window.creators[data.userId].avatar = data.userAvatar;
        window.creators[data.userId].username = data.username;
        window.creators[data.userId].level = data.userLevel || 0;
    }
    else if (window.creators && window.creators[data.userId] && window.creators[data.userId].avatar !== undefined) {
        showDiscordAvatar(window.creators[data.userId].avatar);
    }
    else {
        APIHandler.handle(
            () => api.getUser(data.userId),
            {
                onSuccess: (userInfo) => {
                    if (!window.creators) {
                        window.creators = {};
                    }
                    if (!window.creators[data.userId]) {
                        window.creators[data.userId] = {};
                    }

                    window.creators[data.userId].avatar = userInfo.avatar || null;
                    window.creators[data.userId].username = userInfo.username;
                    window.creators[data.userId].level = userInfo.level || 0;

                    showDiscordAvatar(userInfo.avatar);
                },
                onError: (error) => {
                    console.error("Failed to fetch user info:", error);
                    showLetterAvatar();

                    if (!window.creators) {
                        window.creators = {};
                    }
                    if (!window.creators[data.userId]) {
                        window.creators[data.userId] = {};
                    }
                    window.creators[data.userId].avatar = null;
                }
            }
        );
    }

    document.getElementById("post_time").textContent = timeAgo(data.timestamp);

    animateViewCount(data.views);

    if(!data.content){
        data.content = "https://vapr.b-cdn.net/posts/200w.gif";
    }

    if(data.content.split("/posts/")[0] === "https://vapr-club.b-cdn.net"){
        document.getElementById("post_image").src = data.content;
        document.getElementById("post_image").style.display = "block";
        document.getElementById("post_content").style.display = "none";
        document.getElementById("post_video").style.display = "none";

        const imageEl = document.getElementById("post_image");
        imageEl.style.filter = "blur(10px)";
        imageEl.onload = () => {
            imageEl.style.filter = "none";
            imageEl.style.transition = "filter 0.3s ease";
        };
    }else if(data.content.includes("iframe.mediadelivery.net")){
        document.getElementById("post_video").style.display = "block";
        setTimeout(() => {
            document.getElementById("post_video").children[0].src = data.content;
        }, 100);
        document.getElementById("post_content").style.display = "none";
        document.getElementById("post_image").style.display = "none";
    }

    document.getElementById("post_image").onclick = function () {
        toggleImageZoom(document.getElementById("post_image"));
    }

    const headerLinkButton = document.getElementById("header_link_button");
    const links = document.getElementById("post_link").children;

    for(let i = 0; i < links.length; i++){
        links[i].style.display = "none";
    }

    headerLinkButton.style.display = "none";

    if(data.link){
        handlePostLinks(data.link);
    }
}

function navigateToProfile() {
    if (current_post && current_post.username) {
        window.location.href = `/@${current_post.username}`;
    }
}

function animateViewCount(targetViews) {
    const viewsEl = document.getElementById("post_views");
    const startViews = parseInt(viewsEl.textContent) || 0;
    const duration = 1000;
    const startTime = performance.now();

    function updateViews(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        const easeOutQuart = 1 - Math.pow(1 - progress, 4);

        const currentViews = Math.floor(startViews + (targetViews - startViews) * easeOutQuart);
        viewsEl.textContent = formatViews(currentViews);

        if (progress < 1) {
            requestAnimationFrame(updateViews);
        }
    }

    requestAnimationFrame(updateViews);
}

function toggleImageZoom(img) {
    if (img.classList.contains('zoomed')) {
        img.classList.remove('zoomed');
        document.querySelector('.image-overlay')?.remove();
    } else {
        const overlay = document.createElement('div');
        overlay.className = 'image-overlay';
        overlay.onclick = () => toggleImageZoom(img);

        const zoomedImg = img.cloneNode();
        zoomedImg.className = 'zoomed-image';

        overlay.appendChild(zoomedImg);
        document.body.appendChild(overlay);

        img.classList.add('zoomed');

        requestAnimationFrame(() => {
            overlay.classList.add('active');
        });
    }
}

function handlePostLinks(link) {
    try {
        const url = new URL(link);
        const hostname = url.hostname.toLowerCase();

        const linkMappings = {
            'discord.gg': { id: 'post_discord', icon: 'fa-brands fa-discord', label: 'Discord' },
            'reddit.com': { id: 'post_reddit', icon: 'fa-brands fa-reddit', label: 'Reddit' },
            'store.steampowered.com': { id: 'post_steam', icon: 'fa-brands fa-steam', label: 'Steam' },
            'x.com': { id: 'post_x', icon: 'fa-brands fa-x-twitter', label: 'X' },
            'twitter.com': { id: 'post_x', icon: 'fa-brands fa-x-twitter', label: 'X' },
            'threads.net': { id: 'post_threads', icon: 'fa-brands fa-threads', label: 'Threads' },
            'pinterest': { id: 'post_pinterest', icon: 'fa-brands fa-pinterest', label: 'Pinterest' },
            'twitch.tv': { id: 'post_twitch', icon: 'fa-brands fa-twitch', label: 'Twitch' },
            'youtube.com': { id: 'post_youtube', icon: 'fa-brands fa-youtube', label: 'YouTube' },
            'instagram.com': { id: 'post_instagram', icon: 'fa-brands fa-instagram', label: 'Instagram' },
            'store.epicgames.com': { id: 'post_epic', icon: 'fa-solid fa-gamepad', label: 'Epic Games' },
            'kickstarter.com': { id: 'post_kickstarter', icon: 'fa-brands fa-kickstarter', label: 'Kickstarter' },
            'kick.com': { id: 'post_kick', icon: 'fa-brands fa-kickstarter-k', label: 'Kick' },
            'patreon.com': { id: 'post_patreon', icon: 'fa-brands fa-patreon', label: 'Patreon' },
            'fortnite.com': { id: 'post_fortnite', icon: 'fa-solid fa-gamepad', label: 'Fortnite' },
            'nintendo.com': { id: 'post_nintendo', icon: 'fa-solid fa-gamepad', label: 'Nintendo' },
            'ubisoft.com': { id: 'post_ubisoft', icon: 'fa-solid fa-gamepad', label: 'Ubisoft' },
            'gumroad.com': { id: 'post_gumroad', icon: 'fa-solid fa-shopping-cart', label: 'Gumroad' },
            'garryhost.com': { id: 'post_garryhost', icon: 'fa-solid fa-server', label: "Garry's Host" },
            'itch.io': { id: 'post_itch', icon: 'fa-brands fa-itch-io', label: 'itch.io' }
        };

        let matchedLink = null;
        for (const [domain, linkInfo] of Object.entries(linkMappings)) {
            if (hostname.includes(domain)) {
                matchedLink = linkInfo;
                setupSocialLink(linkInfo.id, link);
                break;
            }
        }

        if (hostname === 'hayarobi-portfolio.carrd.co') {
            matchedLink = { id: 'post_hayarobi', icon: 'fa-solid fa-palette', label: 'Hayarobi' };
            setupSocialLink('post_hayarobi', link);
        }

        if (matchedLink) {
            const headerLinkButton = document.getElementById("header_link_button");
            headerLinkButton.style.display = "inline-flex";
            headerLinkButton.href = link;
            headerLinkButton.innerHTML = `<i class="${matchedLink.icon}"></i><span>${matchedLink.label}</span>`;

            headerLinkButton.style.opacity = '0';
            headerLinkButton.style.transform = 'translateY(10px)';

            setTimeout(() => {
                headerLinkButton.style.transition = 'all 0.3s ease';
                headerLinkButton.style.opacity = '1';
                headerLinkButton.style.transform = 'translateY(0)';
            }, 100);
        }

    } catch (error) {
        console.error('Invalid URL:', link);
    }
}
function showPost() {
    const post = document.getElementsByClassName("post")[0];
    post.style.transform = "translate(0px, 0px) rotate(0deg)";
    post.style.backgroundColor = "";
    post.style.boxShadow = "";
    post.style.animation = 'none';
}

function displayPost(postId = undefined){
    hidePost();
    if(!postId){
        if(feed_posts.length > 0){
            const data = feed_posts.shift();
            loading_steps--;
            hideLoading();
            current_post_id = data.id;
            current_post = data;
            drawPost(data);
            history.pushState(null, null, "/post/" + data.id);
        }else{
            APIHandler.handle(
                () => api.getFeed(),
                {
                    onSuccess: (data) => {
                        console.log(data);
                        feed_posts = data.sort((a, b) => 0.5 - Math.random());
                        console.log(data);
                        displayPost();
                    }
                }
            );
        }
    }else{
        APIHandler.handle(
            () => api.getPost(postId),
            {
                onSuccess: (data) => {
                    loading_steps--;
                    hideLoading();
                    current_post_id = data.id;
                    current_post = data;
                    drawPost(data);
                    history.pushState(null, null, "/post/" + data.id);
                }
            }
        );
    }
}
let user_previous_reaction = null;
let isProcessingReaction = false;

function initEnhancedReactions() {
    const reactionButtons = document.querySelectorAll('.reactions button');

    reactionButtons.forEach(btn => {
        btn.addEventListener('click', function(e) {
            createRipple(e, this);
        });
    });
}

function createRipple(event, button) {
    const ripple = document.createElement('span');
    const rect = button.getBoundingClientRect();
    const size = Math.max(rect.width, rect.height);
    const x = event.clientX - rect.left - size / 2;
    const y = event.clientY - rect.top - size / 2;

    ripple.style.cssText = `
        position: absolute;
        width: ${size}px;
        height: ${size}px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.5);
        pointer-events: none;
        transform: translate(${x}px, ${y}px) scale(0);
        animation: rippleEffect 0.6s ease-out;
    `;

    button.appendChild(ripple);
    setTimeout(() => ripple.remove(), 600);
}

function incrementEmoji(emoji) {
    const emoji_count = document.getElementById(emoji);
    const currentCount = parseInt(emoji_count.textContent);
    const newCount = currentCount + 1;

    emoji_count.style.transform = 'scale(1.5)';
    emoji_count.style.color = '#4ecdc4';

    setTimeout(() => {
        emoji_count.textContent = newCount;
        emoji_count.style.transform = 'scale(1)';
        emoji_count.style.color = '';
    }, 200);
}

function decrementEmoji(emoji) {
    const emoji_count = document.getElementById(emoji);
    const currentCount = parseInt(emoji_count.textContent);
    const newCount = Math.max(0, currentCount - 1);

    emoji_count.style.transform = 'scale(0.8)';
    emoji_count.style.color = '#e74c3c';

    setTimeout(() => {
        emoji_count.textContent = newCount;
        emoji_count.style.transform = 'scale(1)';
        emoji_count.style.color = '';
    }, 200);
}

function resetEmoji(emoji) {
    const emoji_count = document.getElementById(emoji);
    emoji_count.textContent = "0";
}

function addReaction(emoji) {
    if (!isUserLoggedIn()) {
        const reactionsContainer = document.querySelector('.reactions');
        reactionsContainer.style.animation = 'shake 0.5s ease';
        setTimeout(() => {
            reactionsContainer.style.animation = '';
            openRegisterModal();
        }, 500);
        return;
    }

    if (isProcessingReaction) return;

    isProcessingReaction = true;

    const currentBtn = document.querySelector(`[data-reaction="${emoji}"]`);
    const wasActive = currentBtn.classList.contains('active');

    if (user_previous_reaction && user_previous_reaction !== emoji) {
        const prevBtn = document.querySelector(`[data-reaction="${user_previous_reaction}"]`);
        prevBtn.classList.remove('active');
        decrementEmoji(user_previous_reaction);
    }

    if (!wasActive) {
        currentBtn.classList.add('active');
        incrementEmoji(emoji);
        animateReactionIcon(currentBtn.querySelector('.reaction_icon'));
        createFloatingReaction(emoji, currentBtn);
    } else {
        currentBtn.classList.remove('active');
        decrementEmoji(emoji);
        emoji = null;
    }

    APIHandler.handle(
        () => api.addReaction(current_post_id, emoji),
        {
            onSuccess: (data) => {
                console.log('Reaction added:', data);
                user_previous_reaction = emoji;
                isProcessingReaction = false;
            },
            onError: (error) => {
                console.error('Error adding reaction:', error);
                if (user_previous_reaction) {
                    incrementEmoji(user_previous_reaction);
                    decrementEmoji(emoji);
                }
                currentBtn.classList.toggle('active');
                isProcessingReaction = false;
            }
        }
    );
}

function animateReactionIcon(icon) {
    icon.style.animation = 'none';
    setTimeout(() => {
        icon.style.animation = 'bounce 0.5s ease';
    }, 10);
}

function createFloatingReaction(emoji, button) {
    const floater = document.createElement('div');
    floater.className = 'floating-reaction';
    floater.textContent = emoji;

    const rect = button.getBoundingClientRect();
    floater.style.cssText = `
        position: fixed;
        left: ${rect.left + rect.width / 2}px;
        top: ${rect.top}px;
        font-size: 30px;
        pointer-events: none;
        z-index: 1000;
        animation: floatUp 1s ease-out forwards;
    `;

    document.body.appendChild(floater);
    setTimeout(() => floater.remove(), 1000);
}

function displayReactions() {
    document.querySelectorAll('.reactions button').forEach(btn => {
        btn.classList.remove('active');
    });

    resetEmoji('💩');
    resetEmoji('👀');
    resetEmoji('😂');
    resetEmoji('💯');

    console.log("Post id : " + current_post_id);

    APIHandler.handle(
        () => api.getReactions(current_post_id),
        {
            onSuccess: (data) => {
                console.log('Reactions received:', data);
                user_previous_reaction = null;

                data.reactions.forEach((reaction, index) => {
                    setTimeout(() => {
                        incrementEmoji(reaction.emoji);

                        if (reaction.userId === window.user?.id) {
                            user_previous_reaction = reaction.emoji;
                            const btn = document.querySelector(`[data-reaction="${reaction.emoji}"]`);
                            btn.classList.add('active');
                        }
                    }, index * 50);
                });
            }
        }
    );
}

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', initEnhancedReactions);
}
function closeRegisterModal() {
    document.getElementById("register").style.display = "none";
}

document.addEventListener('DOMContentLoaded', function() {
    const userCountEl = document.getElementById('user_count');
    const userCountCtaEl = document.getElementById('user_count_cta');

    if (userCountEl && userCountCtaEl) {
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'childList' || mutation.type === 'characterData') {
                    userCountCtaEl.textContent = userCountEl.textContent;
                }
            });
        });

        observer.observe(userCountEl, { childList: true, characterData: true, subtree: true });
    }
});
function setXPProgress(old_user, disable_xp_notif = false, force_update = false) {
    if (!user.xp) user.xp = 0;
    if (!user.level) user.level = 0;

    const total_xp = user.xp;
    const xp = Math.min(total_xp - old_user.xp, old_user.xp_required);

    updateLevel();
    updateXPDisplay();

    if (xp > 0 || force_update) {
        const diff = (xp / old_user.xp_required) * 100;
        const new_value = (total_xp / old_user.xp_required) * 100;

        const xp_bar_progress_visual = document.getElementById("xp_bar_progress_visual");
        const xp_bar_progress = document.getElementById("xp_bar_progress");

        xp_bar_progress_visual.style.width = diff + "%";
        xp_bar_progress_visual.style.left = (new_value - diff) + "%";

        if (!disable_xp_notif) {
            notify.showXP(xp);

            setTimeout(() => {
                if (old_user.level < user.level) {
                    notify.levelUp(user.level);
                    setXPProgress(window.user, true, true);
                }
            }, 1500);
        }

        setTimeout(() => {
            xp_bar_progress.style.width = new_value + "%";
            xp_bar_progress_visual.style.width = "0%";
            xp_bar_progress_visual.style.left = new_value + "%";
        }, 300);
    }
}

function updateLevel() {
    const level_elements = document.getElementsByClassName("xp_level");
    for (let i = 0; i < level_elements.length; i++) {
        level_elements[i].textContent = user.level;
    }

    const xp_level_elements = document.getElementsByClassName("xp-level");
    for (let i = 0; i < xp_level_elements.length; i++) {
        xp_level_elements[i].textContent = user.level;
    }
}

function updateXPDisplay() {
    const username = document.querySelector('.xp-username');

    if (username) username.textContent = user.username || 'username';

    const oldUsername = document.querySelector('.username');
    if (oldUsername) oldUsername.textContent = user.username || 'username';
}
async function updateSDKUserInfo() {
    if (!isRunningInTauri() || !window.user) return;

    try {
        let avatarHash = null;
        if (window.user.avatar) {
            avatarHash = window.user.avatar;
        } else if (window.user.avatar_url) {
            const match = window.user.avatar_url.match(/avatars\/\d+\/([^.]+)/);
            if (match) {
                avatarHash = match[1];
            }
        }

        await window.__TAURI__.core.invoke('update_sdk_user_info', {
            userId: window.user.id,
            username: window.user.username,
            level: window.user.level || 0,
            xp: window.user.xp || 0,
            xpRequired: window.user.xp_required || 700,
            avatar: avatarHash
        });

        console.log('SDK user info updated');
    } catch (error) {
        console.error('Failed to update SDK user info:', error);
    }
}

async function clearSDKUserInfo() {
    if (!isRunningInTauri()) return;

    try {
        await window.__TAURI__.core.invoke('clear_sdk_user_info');
        console.log('SDK user info cleared');
    } catch (error) {
        console.error('Failed to clear SDK user info:', error);
    }
}

async function getSDKConnectedSessions() {
    if (!isRunningInTauri()) return [];

    try {
        const sessions = await window.__TAURI__.core.invoke('get_sdk_connected_sessions');
        return sessions;
    } catch (error) {
        console.error('Failed to get connected sessions:', error);
        return [];
    }
}

async function monitorSDKConnections() {
    if (!isRunningInTauri()) return;

    setInterval(async () => {
        const sessions = await getSDKConnectedSessions();
        if (sessions.length > 0) {
            console.log(`Games connected via SDK: ${sessions.length}`);
        }
    }, 30000);
}

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        monitorSDKConnections();
    });
}

window.updateSDKUserInfo = updateSDKUserInfo;
window.clearSDKUserInfo = clearSDKUserInfo;
window.getSDKConnectedSessions = getSDKConnectedSessions;
class TebexAPI {
    constructor(webstoreToken) {
        this.baseURL = 'https://headless.tebex.io/api';
        this.webstoreToken = webstoreToken;
    }

    async request(path, options = {}) {
        const url = `${this.baseURL}${path}`;

        try {
            const response = await fetch(url, {
                ...options,
                headers: {
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            });

            if (!response.ok) {
                throw new Error(`Tebex API error: ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Tebex API request failed:', error);
            throw error;
        }
    }

    async getCategories(includePackages = true) {
        return this.request(`/accounts/${this.webstoreToken}/categories${includePackages ? '?includePackages=1' : ''}`);
    }

    async getPackages() {
        return this.request(`/accounts/${this.webstoreToken}/packages`);
    }

    async getPackage(packageId) {
        return this.request(`/accounts/${this.webstoreToken}/packages/${packageId}`);
    }

    async createBasket(completeUrl, cancelUrl) {
        return this.request(`/accounts/${this.webstoreToken}/baskets`, {
            method: 'POST',
            body: JSON.stringify({
                complete_url: completeUrl,
                cancel_url: cancelUrl,
                complete_auto_redirect: true
            })
        });
    }

    async addToBasket(basketIdent, packageId, quantity = 1) {
        return this.request(`/baskets/${basketIdent}/packages`, {
            method: 'POST',
            body: JSON.stringify({
                package_id: packageId,
                quantity: quantity
            })
        });
    }

    async getBasket(basketIdent) {
        return this.request(`/accounts/${this.webstoreToken}/baskets/${basketIdent}`);
    }

    async applyCoupon(basketIdent, couponCode) {
        return this.request(`/accounts/${this.webstoreToken}/baskets/${basketIdent}/coupons`, {
            method: 'POST',
            body: JSON.stringify({
                coupon_code: couponCode
            })
        });
    }

    async removeCoupon(basketIdent) {
        return this.request(`/accounts/${this.webstoreToken}/baskets/${basketIdent}/coupons/remove`, {
            method: 'POST'
        });
    }

    async removeFromBasket(basketIdent, packageId) {
        return this.request(`/baskets/${basketIdent}/packages/remove`, {
            method: 'POST',
            body: JSON.stringify({
                package_id: packageId
            })
        });
    }
}

window.tebexAPI = new TebexAPI('vrvh-cc39f45169dbd59b22582030e84f4e13d69d29a3');
class TebexCart {
    constructor() {
        this.basketIdent = null;
        this.basketData = null;
        this.isProcessing = false;
    }

    async initialize() {
        try {
            const response = await tebexAPI.createBasket(
                `${window.location.origin}/checkout/success`,
                `${window.location.origin}/checkout/cancel`
            );

            this.basketIdent = response.data.ident;
            this.basketData = response.data;
            this.updateCartUI();
        } catch (error) {
            console.error('Failed to initialize cart:', error);
        }
    }

    async addItem(packageId, quantity = 1) {
        if (!this.basketIdent) {
            await this.initialize();
        }

        if (this.isProcessing) return;

        this.isProcessing = true;
        cardManager.showLoading('games-card');

        try {
            await tebexAPI.addToBasket(this.basketIdent, packageId, quantity);
            await this.refreshCart();

            notify.success('Item added to cart!');

            const cartButton = document.getElementById('cart-button');
            if (cartButton) {
                cartButton.style.display = 'flex';
            }

            setTimeout(() => {
                openCart();
            }, 300);

        } catch (error) {
            console.error('Failed to add item:', error);
            notify.error('Failed to add item to cart');
        } finally {
            this.isProcessing = false;
            cardManager.hideLoading('games-card');
        }
    }

    async removeItem(packageId) {
        if (!this.basketIdent || this.isProcessing) return;

        this.isProcessing = true;

        try {
            await tebexAPI.removeFromBasket(this.basketIdent, packageId);
            await this.refreshCart();
            notify.info('Item removed from cart');
        } catch (error) {
            console.error('Failed to remove item:', error);
            notify.error('Failed to remove item');
        } finally {
            this.isProcessing = false;
        }
    }

    async refreshCart() {
        if (!this.basketIdent) return;

        try {
            const response = await tebexAPI.getBasket(this.basketIdent);
            this.basketData = response.data;
            this.updateCartUI();
            this.renderCartItems();
        } catch (error) {
            console.error('Failed to refresh cart:', error);
        }
    }

    renderCartItems() {
        const container = document.getElementById('cart-items');
        if (!container) return;

        if (!this.basketData?.packages || this.basketData.packages.length === 0) {
            container.innerHTML = '<div class="empty-cart">Your cart is empty</div>';
            return;
        }

        container.innerHTML = this.basketData.packages.map(item => `
        <div class="cart-item">
            <div class="item-image-container">
                <img src="${item.image || 'https://via.placeholder.com/80'}" class="item-image" alt="${item.name}">
            </div>
            <div class="item-details">
                <h4>${item.name}</h4>
                <div class="item-price">${this.basketData.currency || 'EUR'} ${(item.in_basket.price || 0).toFixed(2)}</div>
            </div>
            <div class="item-quantity">
                <span>Qty: ${item.in_basket.quantity || 1}</span>
            </div>
            <button class="remove-item-btn" onclick="tebexCart.removeItem(${item.id})">
                <i class="fa-solid fa-trash"></i>
            </button>
        </div>
    `).join('');
    }

    updateCartUI() {
        const cartCount = document.getElementById('cart-count');
        const cartTotal = document.getElementById('cart-total');
        const cartButton = document.getElementById('cart-button');

        if (this.basketData) {
            const totalItems = this.basketData.packages?.reduce((sum, item) => sum + (item.in_basket?.quantity || 1), 0) || 0;

            if (cartCount) {
                cartCount.textContent = totalItems;
                cartCount.style.display = totalItems > 0 ? 'block' : 'none';
            }

            if (cartButton && isUserLoggedIn()) {
                cartButton.style.display = totalItems > 0 ? 'flex' : 'none';
            }
        }

        if (cartTotal && this.basketData) {
            cartTotal.textContent = `${this.basketData.currency || 'EUR'} ${(this.basketData.total_price || 0).toFixed(2)}`;
        }
    }

    async applyCoupon(code) {
        if (!this.basketIdent || !code) return;

        try {
            await tebexAPI.applyCoupon(this.basketIdent, code);
            await this.refreshCart();
            notify.success('Coupon applied successfully!');
        } catch (error) {
            notify.error('Invalid coupon code');
        }
    }

    async checkout() {
        if (!this.basketIdent || !this.basketData) return;

        if (!this.basketData.packages || this.basketData.packages.length === 0) {
            notify.warning('Your cart is empty');
            return;
        }

        try {
            const response = await tebexAPI.getBasket(this.basketIdent);
            const checkoutUrl = response.data.links.checkout;

            window.location.href = checkoutUrl;
        } catch (error) {
            console.error('Checkout failed:', error);
            notify.error('Failed to proceed to checkout');
        }
    }

    showCartPreview() {
        const cartPreview = document.getElementById('cart-preview');
        if (cartPreview) {
            cartPreview.classList.add('show');
            setTimeout(() => {
                cartPreview.classList.remove('show');
            }, 3000);
        }
    }

    clearCart() {
        this.basketIdent = null;
        this.basketData = null;
        this.updateCartUI();
        this.renderCartItems();
    }
}

window.tebexCart = new TebexCart();
async function initializeTebexIntegration() {
    if (!window.tebexCart) {
        window.tebexCart = new TebexCart();
    }

    if (isUserLoggedIn()) {
        await tebexCart.initialize();
    }
}

async function addToCart(tebexPackageId) {
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }

    await tebexCart.addItem(tebexPackageId);
}

function openCart() {
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }

    cardManager.show('cart-modal');
    tebexCart.refreshCart();
}

function closeCart() {
    cardManager.hide('cart-modal');
}

function handleCheckoutSuccess() {
    tebexCart.clearCart();

    notify.success('Purchase completed successfully!');

    if (window.loadLibraryData) {
        loadLibraryData();
    }
}

function handleCheckoutCancel() {
    notify.info('Checkout cancelled');
}

document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);

    if (window.location.pathname === '/checkout/success') {
        handleCheckoutSuccess();
        window.history.replaceState({}, '', '/');
    } else if (window.location.pathname === '/checkout/cancel') {
        handleCheckoutCancel();
        window.history.replaceState({}, '', '/');
    }

    if (isUserLoggedIn()) {
        initializeTebexIntegration();
    }
});

cardManager.register('cart-modal', {
    onShow: () => {
        tebexCart.refreshCart();
    }
});

window.addToCart = addToCart;
window.openCart = openCart;
window.closeCart = closeCart;
document.addEventListener('DOMContentLoaded', (event) => {
    if(!MainPage){
        return;
    }

    const post = document.getElementsByClassName("post")[0];
    let startX = 0;
    let startY = 0;
    let currentX = 0;
    let currentY = 0;
    let startTime = 0;

    post.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        currentX = startX;
        currentY = startY;
        startTime = new Date().getTime();
        post.style.transition = 'none';
        post.style.animation = 'none';
    });

    post.addEventListener('touchmove', (e) => {
        currentX = e.touches[0].clientX;
        currentY = e.touches[0].clientY;
        let changeX = currentX - startX;
        let changeY = currentY - startY;
        post.style.transform = `translate(${changeX}px, ${changeY}px) rotate(${changeX * 0.1}deg)`;
    });

    post.addEventListener('touchend', (e) => {
        let changeX = currentX - startX;
        let changeY = currentY - startY;
        let elapsedTime = new Date().getTime() - startTime;
        let velocity = Math.abs(changeX) / elapsedTime;
        let velocityy = Math.abs(changeY) / elapsedTime;

        if (velocity > 0.3 || Math.abs(changeX) > 100) {
            if (changeX < -100) {
                dislikePost();
            } else if (changeX > 100) {
                likePost();
            }
        }else if (velocityy > 0.3 || Math.abs(changeY) > 100) {
            if (changeY < -100) {
                skipPost();
            }
        } else {
            resetPostPosition();
        }
    });

    function resetPostPosition() {
        post.style.transition = 'transform 0.3s ease';
        post.style.transform = 'translate(0px, 0px) rotate(0deg)';
    }
});

function setInitialTransform(post) {
    const transform = post.style.transform;

    console.log(transform);
    let translateX = transform.split("translate(")[1].split("px,");
    let translateY = translateX[1].split('px)')
    const rotate = parseInt(translateY[1].split("rotate(")[1].split("deg)")[0]);
    translateY = parseInt(translateY[0]);
    translateX = parseInt(translateX[0]);

    console.log({
        translateX: translateX,
        translateY: translateY,
        rotate
    })

    post.style.setProperty('--start-translate-x', `${translateX}px`);
    post.style.setProperty('--start-translate-y', `${translateY}px`);
    post.style.setProperty('--start-rotate', `${rotate}deg`);

    post.style.transform = "translateY(100vh)";
    post.style.transition = 'all 1s ease-in-out';
}

function displayLikeAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'swipeRight 0.6s';
    post.style.transform = "translateY(100vh)";

    notify.showActionFeedback('liked');

    confetti({
        particleCount: 100,
        spread: 70,
        origin: { y: 0.6 },
        colors: ['#22c55e', '#10b981', '#059669']
    });
}

function displayDislikeAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'swipeLeft 0.6s';
    post.style.transform = "translateY(100vh)";

    notify.showActionFeedback('passed');
}

function displaySkipAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'skip 0.6s';
    post.style.transform = "translateY(100vh)";

    notify.showActionFeedback('skipped');
}

function likePost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displayLikeAnimation();
        APIHandler.handle(
            () => api.likePost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displayLikeAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}

function skipPost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displaySkipAnimation();
        APIHandler.handle(
            () => api.skipPost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displaySkipAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}

function dislikePost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displayDislikeAnimation();
        APIHandler.handle(
            () => api.dislikePost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displayDislikeAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}

if (!document.getElementById('action-feedback-styles')) {
    const style = document.createElement('style');
    style.id = 'action-feedback-styles';
    style.textContent = `
        .action-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 50px;
            font-size: 24px;
            font-weight: 700;
            z-index: 10000;
            animation: feedbackPulse 0.5s ease-out;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .action-feedback.liked {
            background: rgba(34, 197, 94, 0.9);
        }

        .action-feedback.passed {
            background: rgba(239, 68, 68, 0.9);
        }

        .action-feedback.skipped {
            background: rgba(59, 130, 246, 0.9);
        }

        @keyframes feedbackPulse {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.9;
            }
        }
    `;
    document.head.appendChild(style);
}
if(MainPage){
    const uploadArea = document.querySelector('.upload-area');
    const fileInput = document.getElementById('file');

    if (uploadArea) {
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.add('dragging');
            }, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.remove('dragging');
            }, false);
        });

        uploadArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                fileInput.files = files;
                handleFileSelect(files[0]);
            }
        }
    }

    if (fileInput) {
        fileInput.addEventListener('change', function() {
            if (this.files && this.files[0]) {
                handleFileSelect(this.files[0]);
            }
        });
    }

    function handleFileSelect(file) {
        const fileType = file.type;
        const placeholder = document.getElementById('upload-placeholder');
        const preview = document.getElementById('upload-preview');
        const previewImage = document.getElementById('preview_img');
        const previewVideo = document.getElementById('preview_video');

        if (file.size > 50 * 1024 * 1024) {
            notify.error('File too large', 'Please select a file under 50MB');
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            placeholder.style.display = 'none';
            preview.style.display = 'block';

            if (fileType.startsWith('video/')) {
                previewVideo.src = e.target.result;
                previewVideo.style.display = 'block';
                previewImage.style.display = 'none';
            } else if (fileType.startsWith('image/')) {
                previewImage.src = e.target.result;
                previewImage.style.display = 'block';
                previewVideo.style.display = 'none';
            } else {
                notify.error('Invalid file type', 'Please upload an image or video file');
                placeholder.style.display = 'flex';
                preview.style.display = 'none';
                return;
            }
        };
        reader.readAsDataURL(file);
    }

    const titleInput = document.getElementById('title');
    const titleCount = document.getElementById('title-count');

    if (titleInput && titleCount) {
        titleInput.addEventListener('input', function() {
            titleCount.textContent = this.value.length;
        });
    }
}

window.submitPost = async function(event) {
    event.preventDefault();

    const submitBtn = document.getElementById('submit-post-btn');
    const uploadProgress = document.getElementById('upload-progress');
    const progressFill = document.getElementById('progress-fill');

    const title = document.getElementById('title').value;
    const link = document.getElementById('link').value;
    const file = document.getElementById('file').files[0];

    if (!file) {
        notify.warning('No media selected', 'Please select an image or video to upload');
        return;
    }

    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> <span>Publishing...</span>';

    const formData = new FormData();
    formData.append('title', title);
    formData.append('link', link);

    if (file) {
        const fileExtension = file.name.split('.').pop();
        const fileName = `${new Date().getTime()}.${fileExtension}`;
        const fileContentType = file.type || 'application/octet-stream';
        const blob = new Blob([file], { type: fileContentType });
        formData.append("file", blob, fileName);
    }

    try {
        uploadProgress.style.display = 'block';

        let progress = 0;
        const progressInterval = setInterval(() => {
            progress += Math.random() * 15;
            if (progress > 90) progress = 90;
            progressFill.style.width = progress + '%';
        }, 200);

        const result = await api.createPost(formData);

        clearInterval(progressInterval);
        progressFill.style.width = '100%';

        if (result.success) {
            confetti({
                particleCount: 100,
                spread: 70,
                origin: { y: 0.6 }
            });

            closeAddPostCard();

            document.getElementById('title').value = '';
            document.getElementById('link').value = '';
            document.getElementById('file').value = '';
            document.getElementById('upload-placeholder').style.display = 'flex';
            document.getElementById('upload-preview').style.display = 'none';
            const titleCount = document.getElementById('title-count');
            if (titleCount) {
                titleCount.textContent = '0';
            }

            notify.success("Post published successfully!");

            if (window.user && result.user) {
                const oldUser = {
                    xp: window.user.xp,
                    level: window.user.level,
                    xp_required: window.user.xp_required
                };

                window.user = result.user;
                setXPProgress(oldUser);
            }

            setTimeout(() => {
                displayPost(result.id);
            }, 500);

        } else {
            throw new Error(result.error || 'Failed to create post');
        }

    } catch (error) {
        console.error('Failed to submit post:', error);

        notify.error('Upload failed', error.message || 'Failed to create post. Please try again.');

    } finally {
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="fa-solid fa-paper-plane"></i> <span>Publish Post</span>';
        uploadProgress.style.display = 'none';
        progressFill.style.width = '0%';
    }
}
function initProfilePage() {
    if (!window.profileData) return;

    if (isUserLoggedIn()) {
        addFollowButton();
    }

    makeProfilePostsInteractive();

    addProfileInteractions();

    console.log(profileData);
    if (window.profileData && window.profileData.backgroundId) {
        const background = background_images.find(bg => bg.id === window.profileData.backgroundId);
        if (background) {
            document.getElementById('profile-body').style.backgroundImage = 'url(' + background.image_url + ')';
        }
    }
}

function addFollowButton() {
    const profileHeader = document.querySelector('.profile-info');
    if (!profileHeader || !window.user || window.user.id === window.profileData.id) {
        return;
    }

    const followBtn = document.createElement('button');
    followBtn.className = 'glass_bt follow-profile-btn';
    followBtn.id = 'profile_follow_btn';

    checkProfileFollowStatus(window.profileData.id).then(isFollowing => {
        if (isFollowing) {
            followBtn.innerHTML = '<i class="fa-solid fa-user-minus"></i> Following';
            followBtn.classList.add('following');
        } else {
            followBtn.innerHTML = '<i class="fa-solid fa-user-plus"></i> Follow';
        }
    });

    followBtn.onclick = () => toggleProfileFollow();

    profileHeader.appendChild(followBtn);
}

async function checkProfileFollowStatus(profileUserId) {
    try {
        const isFollowing = await api.checkFollowStatus(profileUserId);
        return isFollowing;
    } catch (error) {
        console.error("Error checking follow status:", error);
        return false;
    }
}

async function toggleProfileFollow() {
    if (!isUserLoggedIn()) {
        window.location.href = '/login';
        return;
    }

    const followBtn = document.getElementById('profile_follow_btn');
    if (!followBtn) return;

    const isFollowing = followBtn.classList.contains('following');
    const action = isFollowing ? "unfollow" : "follow";

    try {
        const tempPost = { id: "profile_follow", userId: window.profileData.id };

        const response = action === 'follow'
            ? await api.followPost(tempPost.id)
            : await api.unfollowPost(tempPost.id);

        if (response) {
            const followerCountEl = document.querySelector('.stat-value[data-stat="followers"]');

            if (isFollowing) {
                followBtn.innerHTML = '<i class="fa-solid fa-user-plus"></i> Follow';
                followBtn.classList.remove('following');
                if (followerCountEl) {
                    const currentCount = parseInt(followerCountEl.textContent.replace(/[^0-9]/g, ''));
                    followerCountEl.textContent = formatNumber(Math.max(0, currentCount - 1));
                }
            } else {
                followBtn.innerHTML = '<i class="fa-solid fa-user-minus"></i> Following';
                followBtn.classList.add('following');
                if (followerCountEl) {
                    const currentCount = parseInt(followerCountEl.textContent.replace(/[^0-9]/g, ''));
                    followerCountEl.textContent = formatNumber(currentCount + 1);
                }
            }
        }
    } catch (error) {
        console.error("Error toggling follow:", error);
    }
}

function makeProfilePostsInteractive() {
    const postCards = document.querySelectorAll('.profile-post-card');

    postCards.forEach(card => {
        card.addEventListener('click', (e) => {
            e.preventDefault();
            const postId = card.href.split('/post/')[1];

            sessionStorage.setItem('previousPage', window.location.pathname);

            window.location.href = card.href;
        });
    });
}

function addProfileInteractions() {
    const style = document.createElement('style');
    style.textContent = `
        .follow-profile-btn {
            background-color: rgb(95, 148, 243);
            color: white;
            padding: 10px 20px;
            font-weight: 700;
            margin-top: 10px;
            border: none;
            cursor: pointer;
        }
        
        .follow-profile-btn.following {
            background-color: rgba(190, 213, 255, 0.4);
            border: 1px solid rgb(206, 220, 247, 0.42);
        }
        
        .follow-profile-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(95, 148, 243, 0.4);
        }
        
        .stat-value[data-stat="followers"] {
            transition: all 0.3s ease;
        }
    `;
    document.head.appendChild(style);
}

document.addEventListener('DOMContentLoaded', () => {
    initProfilePage();
});

if (typeof drawPost !== 'undefined') {
    const originalDrawPost = drawPost;
    drawPost = function(data) {
        originalDrawPost(data);

        const usernameElement = document.getElementById("post_username");
        if (usernameElement && data.username) {
            usernameElement.style.cursor = "pointer";
            usernameElement.onclick = (e) => {
                e.preventDefault();
                window.location.href = `/@${data.username}`;
            };
        }
    };
}
const AnimationUtils = {
    animateCounter(element, start, end, duration = 1000, formatter = null) {
        if (!element) return;

        const startTime = performance.now();
        const defaultFormatter = (val) => this.formatNumber(val);
        const format = formatter || defaultFormatter;

        const updateCounter = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            const easeOutQuart = 1 - Math.pow(1 - progress, 4);
            const currentValue = Math.floor(start + (end - start) * easeOutQuart);

            element.textContent = format(currentValue);

            if (progress < 1) {
                requestAnimationFrame(updateCounter);
            }
        };

        requestAnimationFrame(updateCounter);
    },

    formatNumber(num) {
        if (num < 1000) return num.toString();
        if (num < 1000000) return (num / 1000).toFixed(1) + 'K';
        if (num < 1000000000) return (num / 1000000).toFixed(1) + 'M';
        return (num / 1000000000).toFixed(1) + 'B';
    },

    timeAgo(dateParam) {
        if (!dateParam) return null;

        const date = typeof dateParam === 'object' ? dateParam : new Date(dateParam);
        const today = new Date();
        const seconds = Math.round((today - date) / 1000);
        const minutes = Math.round(seconds / 60);
        const hours = Math.round(minutes / 60);
        const days = Math.round(hours / 24);
        const months = Math.round(days / 30.4);
        const years = Math.round(days / 365);

        if (seconds < 60) {
            return `${seconds}s ago`;
        } else if (minutes < 60) {
            return `${minutes}m ago`;
        } else if (hours < 24) {
            return `${hours}h ago`;
        } else if (days < 30) {
            return `${days}d ago`;
        } else if (months < 12) {
            return `${months}mo ago`;
        } else {
            return `${years}y ago`;
        }
    },

    createRipple(event, button) {
        const ripple = document.createElement('span');
        const rect = button.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        const x = event.clientX - rect.left - size / 2;
        const y = event.clientY - rect.top - size / 2;

        ripple.style.cssText = `
            position: absolute;
            width: ${size}px;
            height: ${size}px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            transform: translate(${x}px, ${y}px) scale(0);
            animation: rippleEffect 0.6s ease-out;
        `;

        button.appendChild(ripple);
        setTimeout(() => ripple.remove(), 600);
    },

    addShimmerEffect(element) {
        element.classList.add('glass-shimmer');
    },

    formatViews(viewCount) {
        return this.formatNumber(viewCount);
    },

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
};

window.animateCounter = AnimationUtils.animateCounter.bind(AnimationUtils);
window.formatNumber = AnimationUtils.formatNumber;
window.timeAgo = AnimationUtils.timeAgo;
window.formatViews = AnimationUtils.formatViews;
window.escapeHtml = AnimationUtils.escapeHtml;
const NotificationUtils = {
    getToast() {
        if (typeof Swal === 'undefined') return null;

        return Swal.mixin({
            toast: true,
            position: "top-end",
            showConfirmButton: false,
            timer: 3000,
            timerProgressBar: true,
            didOpen: (toast) => {
                toast.onmouseenter = Swal.stopTimer;
                toast.onmouseleave = Swal.resumeTimer;
            }
        });
    },

    success(title, options = {}) {
        const Toast = this.getToast();
        if (!Toast) return;

        Toast.fire({
            icon: "success",
            title,
            ...options
        });
    },

    error(title, text = null, options = {}) {
        if (typeof Swal === 'undefined') return;

        if (text) {
            Swal.fire({
                icon: 'error',
                title,
                text,
                ...options
            });
        } else {
            const Toast = this.getToast();
            Toast?.fire({
                icon: "error",
                title,
                ...options
            });
        }
    },

    info(title, html = null, options = {}) {
        if (typeof Swal === 'undefined') return;

        if (html) {
            Swal.fire({
                icon: 'info',
                title,
                html,
                ...options
            });
        } else {
            const Toast = this.getToast();
            Toast?.fire({
                icon: "info",
                title,
                ...options
            });
        }
    },

    warning(title, text, options = {}) {
        if (typeof Swal === 'undefined') return;

        Swal.fire({
            icon: 'warning',
            title,
            text,
            ...options
        });
    },

    async confirm(title, text, options = {}) {
        if (typeof Swal === 'undefined') return false;

        const result = await Swal.fire({
            title,
            text,
            icon: 'question',
            showCancelButton: true,
            confirmButtonText: 'Yes',
            cancelButtonText: 'Cancel',
            confirmButtonColor: '#4ecdc4',
            ...options
        });

        return result.isConfirmed;
    },

    async confirmDanger(title, text, confirmText = 'Yes, delete it', options = {}) {
        if (typeof Swal === 'undefined') return false;

        const result = await Swal.fire({
            title,
            text,
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: confirmText,
            cancelButtonText: 'Cancel',
            confirmButtonColor: '#e74c3c',
            ...options
        });

        return result.isConfirmed;
    },

    levelUp(level) {
        if (typeof confetti !== 'undefined') {
            confetti({
                particleCount: 50,
                spread: 50,
                origin: { y: 0.3 },
                colors: ['#ffffff', '#4ecdc4', '#667eea']
            });
        }

        this.success(`Level ${level} reached! 🎉`);
    },

    showXP(amount) {
        const notification = document.getElementById('xp-notification');
        if (!notification) return;

        notification.style.animation = 'xpNotificationAnimation 1.5s';
        notification.textContent = `+${amount} XP`;

        setTimeout(() => {
            notification.style.animation = 'none';
        }, 1500);
    },

    showActionFeedback(action) {
        const feedback = document.createElement('div');
        feedback.className = 'action-feedback ' + action;
        feedback.innerHTML = `<i class="fa-solid fa-${action === 'liked' ? 'heart' : action === 'passed' ? 'heart-crack' : 'forward'}"></i> ${action.charAt(0).toUpperCase() + action.slice(1)}!`;

        document.body.appendChild(feedback);

        setTimeout(() => {
            feedback.remove();
        }, 1000);
    },

    desktopAppPrompt(onConfirm) {
        if (typeof Swal === 'undefined') return;

        Swal.fire({
            title: 'Desktop App Required',
            html: `
                <p>To download and play games, you need the VAPR desktop app.</p>
                <p style="margin-top: 20px; font-size: 14px; color: rgba(255, 255, 255, 0.7);">
                    The desktop app allows you to:
                </p>
                <ul style="text-align: left; margin: 10px 0; font-size: 14px; color: rgba(255, 255, 255, 0.7);">
                    <li>Download and install games directly</li>
                    <li>Launch games with one click</li>
                    <li>Track your playtime</li>
                    <li>Get automatic updates</li>
                </ul>
            `,
            icon: 'info',
            showCancelButton: true,
            confirmButtonText: '<i class="fa-solid fa-download"></i> Download Desktop App',
            cancelButtonText: 'Maybe Later',
            confirmButtonColor: '#4ecdc4',
            customClass: {
                container: 'download-prompt-container'
            }
        }).then((result) => {
            if (result.isConfirmed && onConfirm) {
                onConfirm();
            }
        });
    },

    copyToClipboard(text, successMessage = 'Copied to clipboard!') {
        navigator.clipboard.writeText(text).then(() => {
            this.success(successMessage);
        }).catch(() => {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'absolute';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            textArea.setSelectionRange(0, 99999);

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    this.success(successMessage);
                } else {
                    this.error('Failed to copy to clipboard');
                }
            } catch (err) {
                this.error('Failed to copy to clipboard');
            }

            document.body.removeChild(textArea);
        });
    }
};

window.notify = NotificationUtils;
window.showToast = (type, title, options) => NotificationUtils[type](title, options);
let versionCheckInterval = null;
let isVersionCheckModalOpen = false;
let hasSkippedVersion = null;

function getWebVersion() {
    const versionElement = document.querySelector('.menu-version span');
    if (versionElement) {
        const versionText = versionElement.textContent;
        const versionMatch = versionText.match(/v(\d+\.\d+\.\d+)/);
        if (versionMatch) {
            return versionMatch[1];
        }
    }
    return null;
}

function getDesktopVersion() {
    if (window.__TAURI__ && window.__TAURI__.app) {
        return window.__TAURI__.app.getVersion();
    }
    return null;
}

async function checkDesktopVersion() {
    if (!isRunningInTauri() || isVersionCheckModalOpen) {
        return;
    }

    try {
        const webVersion = getWebVersion();
        const desktopVersion = await getDesktopVersion();

        if (!webVersion || !desktopVersion) {
            console.error('Could not retrieve version information');
            return;
        }

        if (webVersion !== desktopVersion) {
            showVersionUpdateModal({
                current_version: desktopVersion,
                required_version: webVersion
            });
        }
    } catch (error) {
        console.error('Version check failed:', error);
    }
}

function showVersionUpdateModal(versionInfo) {
    if (isVersionCheckModalOpen) return;

    isVersionCheckModalOpen = true;

    if (versionCheckInterval) {
        clearInterval(versionCheckInterval);
        versionCheckInterval = null;
    }

    const downloadUrl = `https://github.com/Vic92548/VAPR/releases/download/v${versionInfo.required_version}/VAPR_${versionInfo.required_version}_x64_en-US.msi`;

    const modal = document.createElement('div');
    modal.id = 'version-update-modal';
    modal.className = 'version-modal-overlay';
    modal.innerHTML = `
        <div class="version-modal-content">
            <div class="version-modal-header">
                <i class="fa-solid fa-exclamation-triangle"></i>
                <h2>Update Available</h2>
            </div>
            <div class="version-modal-body">
                <p>A new version of VAPR desktop app is available. Update now for the latest features and improvements.</p>
                <div class="version-info">
                    <div class="version-item">
                        <span class="version-label">Your version:</span>
                        <span class="version-value outdated">v${versionInfo.current_version}</span>
                    </div>
                    <div class="version-item">
                        <span class="version-label">Latest version:</span>
                        <span class="version-value required">v${versionInfo.required_version}</span>
                    </div>
                </div>
                <p class="version-note">We recommend updating to ensure the best experience and compatibility.</p>
            </div>
            <div class="version-modal-actions">
                <button class="version-download-btn" onclick="downloadLatestDesktopVersion('${downloadUrl}')">
                    <i class="fa-solid fa-download"></i>
                    Download Latest Version
                </button>
                <button class="version-skip-btn" onclick="skipVersionUpdate('${versionInfo.required_version}')">
                    <i class="fa-solid fa-clock"></i>
                    Skip for now <span class="skip-warning">(not recommended, may cause bugs)</span>
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';
}

function skipVersionUpdate(skippedVersion) {
    const modal = document.getElementById('version-update-modal');
    if (modal) {
        modal.remove();
        document.body.style.overflow = '';
    }

    isVersionCheckModalOpen = false;
}

function downloadLatestDesktopVersion(downloadUrl) {
    window.open(downloadUrl, '_blank');

    setTimeout(() => {
        notify.info(
            'Download Started',
            `<p>The download should begin shortly.</p>
            <p style="margin-top: 15px; font-size: 14px; color: rgba(255, 255, 255, 0.7);">
                After installing the new version, please restart VAPR to continue.
            </p>`,
            {
                confirmButtonText: 'OK',
                confirmButtonColor: '#4ecdc4'
            }
        );
    }, 500);
}

function initVersionCheck() {
    if (!isRunningInTauri()) return;

    setTimeout(() => {
        checkDesktopVersion();
    }, 3000);
}

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        initVersionCheck();
    });

    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'childList' && document.querySelector('.menu-version span')) {
                observer.disconnect();
                checkDesktopVersion();
            }
        });
    });

    observer.observe(document.body, { childList: true, subtree: true });
}

window.checkDesktopVersion = checkDesktopVersion;
window.downloadLatestDesktopVersion = downloadLatestDesktopVersion;
window.skipVersionUpdate = skipVersionUpdate;
