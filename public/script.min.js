const cardManager = {
    currentCard: null,
    cards: new Map(),
    isNavigating: false,
    previousPath: null,

    register(cardId, options = {}) {
        this.cards.set(cardId, {
            onShow: options.onShow || (() => {}),
            onHide: options.onHide || (() => {}),
            onLoad: options.onLoad || null,
            route: options.route || null,
            ...options
        });
    },

    async show(cardId) {
        const card = document.getElementById(cardId);
        if (!card) {
            console.error(`Card ${cardId} not found`);
            return;
        }

        if (window.hideMenu) hideMenu();

        this.previousPath = window.location.pathname;

        if (this.currentCard && this.currentCard !== cardId) {
            await this.hideCard(this.currentCard, true);
            await new Promise(resolve => setTimeout(resolve, 50));
        }

        const post = document.querySelector('.post');
        if (post) {
            post.style.display = 'none';
        }

        card.style.display = 'block';

        setTimeout(() => {
            card.classList.add('show');
        }, 10);

        this.currentCard = cardId;

        const config = this.cards.get(cardId) || {};

        if (config.route && window.router && !this.isNavigating) {
            const currentPath = window.location.pathname;
            if (currentPath !== config.route) {
                this.isNavigating = true;
                window.history.pushState(null, null, config.route);
                this.isNavigating = false;
            }
        }

        if (config.onLoad) {
            this.showLoading(cardId);
            try {
                await config.onLoad();
            } catch (error) {
                console.error(`Error loading card ${cardId}:`, error);
            } finally {
                this.hideLoading(cardId);
            }
        }

        if(config.onShow) config.onShow();
    },

    hide(cardId) {
        return this.hideCard(cardId, false);
    },

    hideCard(cardId, skipPostRestore = false) {
        return new Promise((resolve) => {
            const card = document.getElementById(cardId);
            if (!card) {
                resolve();
                return;
            }

            const config = this.cards.get(cardId) || {};

            if (cardId === 'downloads-card' && window.downloadManager) {
                window.downloadManager.pauseEventProcessing();
            }

            card.classList.remove('show');

            setTimeout(() => {
                card.style.display = 'none';

                if(config.onHide) {
                    try {
                        config.onHide();
                    } catch (error) {
                        console.error('Error in onHide:', error);
                    }
                }

                if (this.currentCard === cardId) {
                    this.currentCard = null;
                }

                if (cardId === 'downloads-card' && window.downloadManager) {
                    setTimeout(() => {
                        window.downloadManager.resumeEventProcessing();
                    }, 100);
                }

                if (!skipPostRestore) {
                    const post = document.querySelector('.post');
                    if (post) {
                        post.style.display = 'block';
                        post.style.transform = 'translate(0px, 0px) rotate(0deg)';
                    }

                    if (window.router && !this.isNavigating) {
                        let targetPath = '/';

                        if (window.current_post_id) {
                            targetPath = `/post/${window.current_post_id}`;
                        } else if (this.previousPath && this.previousPath !== window.location.pathname) {
                            targetPath = this.previousPath;
                        }

                        this.isNavigating = true;
                        window.history.pushState(null, null, targetPath);

                        if (targetPath === '/' || targetPath.startsWith('/post/')) {
                            if (window.showPost) window.showPost();
                            if (window.displayPost) {
                                if (targetPath.startsWith('/post/')) {
                                    const postId = targetPath.split('/')[2];
                                    window.displayPost(postId);
                                } else {
                                    window.displayPost();
                                }
                            }
                        }

                        this.isNavigating = false;
                    }
                }

                resolve();
            }, 300);
        });
    },

    showLoading(cardId) {
        const card = document.getElementById(cardId);

        if (cardId === 'analytics-card') {
            const loading = document.getElementById('analytics-loading');
            const content = document.querySelector('.analytics-body');
            if (loading) loading.style.display = 'block';
            if (content) content.style.opacity = '0.3';
        }
        else if (cardId === 'backgrounds-card') {
            const loading = document.getElementById('backgrounds-loading');
            const content = document.getElementById('backgroundsContent');
            if (loading) loading.style.display = 'block';
            if (content) content.style.opacity = '0.3';
        }
        else if (cardId === 'games-card') {
            const loading = document.getElementById('games-loading');
            const content = document.getElementById('gamesContent');
            if (loading) loading.style.display = 'block';
            if (content) content.style.opacity = '0.3';
        }
    },

    hideLoading(cardId) {
        const card = document.getElementById(cardId);

        if (cardId === 'analytics-card') {
            const loading = document.getElementById('analytics-loading');
            const content = document.querySelector('.analytics-body');
            if (loading) loading.style.display = 'none';
            if (content) content.style.opacity = '1';
        }
        else if (cardId === 'backgrounds-card') {
            const loading = document.getElementById('backgrounds-loading');
            const content = document.getElementById('backgroundsContent');
            if (loading) loading.style.display = 'none';
            if (content) content.style.opacity = '1';
        }
        else if (cardId === 'games-card') {
            const loading = document.getElementById('games-loading');
            const content = document.getElementById('gamesContent');
            if (loading) loading.style.display = 'none';
            if (content) content.style.opacity = '1';
        }
    }
};

window.cardManager = cardManager;
const DOM = {
    get: (id) => document.getElementById(id),
    query: (sel) => document.querySelector(sel),
    queryAll: (sel) => document.querySelectorAll(sel),
    create: (tag, attrs = {}, content = '') => {
        const el = document.createElement(tag);
        Object.entries(attrs).forEach(([k, v]) => {
            if (k === 'style' && typeof v === 'object') {
                Object.assign(el.style, v);
            } else if (k === 'class') {
                el.className = v;
            } else if (k.startsWith('on')) {
                el[k] = v;
            } else {
                el.setAttribute(k, v);
            }
        });
        if (content) el.innerHTML = content;
        return el;
    },
    show: (el, display = 'block') => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.style.display = display;
    },
    hide: (el) => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.style.display = 'none';
    },
    toggle: (el, display = 'block') => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.style.display = el.style.display === 'none' ? display : 'none';
    },
    setText: (el, text) => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.textContent = text;
    },
    setHTML: (el, html) => {
        if (typeof el === 'string') el = DOM.get(el);
        if (el) el.innerHTML = html;
    }
};

window.DOM = DOM;
window.analytics = {};
class VAPRRouter {
    constructor() {
        this.routes = new Map();
        this.currentRoute = null;
        this.params = {};
        this.previousRoute = null;
    }

    register(pattern, handler) {
        this.routes.set(pattern, handler);
        console.log('ROUTE REGISTERED', {pattern, handler});
    }

    navigate(path, bIsFrontEndOnly = false) {
        if(bIsFrontEndOnly){
            history.pushState(null, null, path);
            this.handleRoute();
        }
        else{
            loading.show();
            window.location.href = path;
        }
    }

    handleRoute() {
        console.log('ROUTE');
        const path = window.location.pathname;
        this.previousRoute = this.currentRoute;

        if (cardManager.currentCard && !cardManager.isNavigating) {
            cardManager.hide(cardManager.currentCard);
        }

        if (path.startsWith('/@')) {
            this.currentRoute = '/@:username';
            const handler = this.routes.get('/@:username');
            if (handler) {
                handler(this.params);
                return;
            }
        }

        for (const [pattern, handler] of this.routes) {
            const match = this.matchRoute(pattern, path);
            if (match) {
                this.currentRoute = pattern;
                this.params = match.params;
                handler(match.params);
                return;
            }
        }

        this.handle404();
    }

    matchRoute(pattern, path) {
        const patternParts = pattern.split('/').filter(Boolean);
        const pathParts = path.split('/').filter(Boolean);

        if (patternParts.length !== pathParts.length) return null;

        const params = {};

        for (let i = 0; i < patternParts.length; i++) {
            if (patternParts[i].startsWith(':')) {
                const paramName = patternParts[i].slice(1);
                params[paramName] = decodeURIComponent(pathParts[i]);
            } else if (patternParts[i] !== pathParts[i]) {
                return null;
            }
        }

        return { params };
    }

    handle404() {
        this.currentRoute = '404';
        console.log('No route found for:', window.location.pathname);
       
        showPost();
        displayPost();
    }
}

window.router = new VAPRRouter();

window.addEventListener('popstate', () => {
    router.handleRoute();
});
router.register('/', () => {
    showInitialPost();
});

router.register('/post/:id', (params) => {
    showPost();
    displayPost(params.id);
});

router.register('/@:username', async (params) => {
    hidePost();
    cardManager.show('profile-card');
});

router.register('/library', async () => {
    hidePost();
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }
    await cardManager.show('library-card');
});

router.register('/new-post', async () => {
    hidePost();
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }
    await cardManager.show('add-post-card');
});

router.register('/downloads', async () => {

    if (!isRunningInTauri()) {
        notify.warning('Desktop App Required', 'The downloads manager requires the VAPR desktop app.');
        return;
    }
    hidePost();
    await cardManager.show('downloads-card');
});
class VAPRTemplateEngine {
    constructor() {
        this.templates = new Map();
        this.rendered = new WeakSet();
        this.hooks = new Map();
    }

    init() {
        this.loadTemplates();
        this.processDocument();
        this.observeDOM();
    }

    on(selector, event, callback) {
        const key = `${selector}:${event}`;
        if (!this.hooks.has(key)) {
            this.hooks.set(key, []);
        }
        this.hooks.get(key).push(callback);
    }

    emit(element, event) {
        const tagName = element.tagName.toLowerCase();
        const id = element.id;
        const classes = Array.from(element.classList);

        const selectors = [
            tagName,
            ...classes.map(c => `.${c}`),
            id ? `#${id}` : null
        ].filter(Boolean);

        selectors.forEach(selector => {
            const key = `${selector}:${event}`;
            if (this.hooks.has(key)) {
                this.hooks.get(key).forEach(callback => {
                    callback(element);
                });
            }
        });

        const customSelectors = element.getAttribute('data-hook');
        if (customSelectors) {
            customSelectors.split(' ').forEach(selector => {
                const key = `${selector}:${event}`;
                if (this.hooks.has(key)) {
                    this.hooks.get(key).forEach(callback => {
                        callback(element);
                    });
                }
            });
        }
    }

    loadTemplates() {
        const templates = document.querySelectorAll('template[data-vapr]');
        templates.forEach(template => {
            const name = template.dataset.vapr;
            this.templates.set(name.toLowerCase(), template.innerHTML.trim());
        });
        console.log(`VAPR: Loaded ${this.templates.size} templates`);
    }

    processDocument() {
        this.templates.forEach((template, name) => {
            this.processElements(name);
        });
    }

    processElements(tagName) {
        const elements = document.querySelectorAll(tagName);
        elements.forEach(element => {
            if (!this.rendered.has(element)) {
                this.renderElement(element, tagName);
            }
        });
    }

    processConditionals(html, attributes) {
        const processBlock = (text, isNegative) => {
            const regex = isNegative
                ? /\{\{\^([\w-]+)\}\}/g
                : /\{\{#([\w-]+)\}\}/g;

            let result = text;
            let match;

            const openings = [];
            while ((match = regex.exec(text)) !== null) {
                openings.push({
                    attr: match[1],
                    start: match.index,
                    end: match.index + match[0].length,
                    tag: match[0]
                });
            }

            for (let i = openings.length - 1; i >= 0; i--) {
                const opening = openings[i];
                const closingTag = `{{/${opening.attr}}}`;
                const closingIndex = result.indexOf(closingTag, opening.end);

                if (closingIndex !== -1) {
                    const content = result.substring(opening.end, closingIndex);
                    const value = attributes[opening.attr];

                    let shouldShow;
                    if (isNegative) {
                        shouldShow = !value || value === 'false' || value === '';
                    } else {
                        shouldShow = value && value !== 'false' && value !== '';
                    }

                    const replacement = shouldShow ? this.processConditionals(content, attributes) : '';

                    result = result.substring(0, opening.start) +
                        replacement +
                        result.substring(closingIndex + closingTag.length);
                }
            }

            return result;
        };

        html = processBlock(html, true);
        html = processBlock(html, false);

        return html;
    }

    renderElement(element, tagName) {
        const template = this.templates.get(tagName.toLowerCase());
        if (!template) return;

        const content = element.innerHTML;
        const attributes = {};

        for (let attr of element.attributes) {
            attributes[attr.name] = attr.value;
        }

        let html = template;

        html = html.replace(/<slot\s*\/?>/gi, content);

        html = this.processConditionals(html, attributes);

        html = html.replace(/\{\{([\w-]+)\}\}/g, (match, attrName) => {
            const value = attributes[attrName];
            return value !== undefined && value !== null ? value : '';
        });

        const wrapper = document.createElement('div');
        wrapper.innerHTML = html;

        let rootElement;
        let elementsToEmit = [];

        if (wrapper.children.length === 1) {
            const newElement = wrapper.firstElementChild;

            for (let attr of element.attributes) {
                if (!newElement.hasAttribute(attr.name)) {
                    newElement.setAttribute(attr.name, attr.value);
                }
            }

            element.replaceWith(newElement);
            rootElement = newElement;

            elementsToEmit = [newElement, ...newElement.querySelectorAll('*')];
        } else {
            element.innerHTML = wrapper.innerHTML;
            rootElement = element;

            elementsToEmit = [element, ...element.querySelectorAll('*')];
        }

        this.rendered.add(rootElement);

        elementsToEmit.forEach(el => {
            this.emit(el, 'created');
        });

        requestAnimationFrame(() => {
            if (rootElement.isConnected) {
                const connectedElements = wrapper.children.length === 1
                    ? [rootElement, ...rootElement.querySelectorAll('*')]
                    : [rootElement, ...rootElement.querySelectorAll('*')];

                connectedElements.forEach(el => {
                    if (el.isConnected) {
                        this.emit(el, 'mounted');
                    }
                });
            }
        });
    }

    observeDOM() {
        const observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === 1) {
                        const tagName = node.tagName?.toLowerCase();

                        if (tagName && this.templates.has(tagName)) {
                            if (!this.rendered.has(node)) {
                                this.renderElement(node, tagName);
                            }
                        }

                        this.templates.forEach((template, name) => {
                            const children = node.querySelectorAll(name);
                            children.forEach(child => {
                                if (!this.rendered.has(child)) {
                                    this.renderElement(child, name);
                                }
                            });
                        });
                    }
                });
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    }

    refresh() {
        this.rendered = new WeakSet();
        this.processDocument();
    }

    render(element) {
        const tagName = element.tagName.toLowerCase();
        if (this.templates.has(tagName)) {
            this.renderElement(element, tagName);
        }
    }

    querySelector(selector) {
        return document.querySelector(selector);
    }

    querySelectorAll(selector) {
        return document.querySelectorAll(selector);
    }

    createElement(tagName, attributes = {}) {
        const element = document.createElement(tagName);

        Object.entries(attributes).forEach(([key, value]) => {
            const attrName = key.replace(/([A-Z])/g, '-$1').toLowerCase();

            if (value === null || value === undefined) {
                return;
            } else if (typeof value === 'boolean') {
                element.setAttribute(attrName, value.toString());
            } else if (typeof value === 'object') {
                element.setAttribute(attrName, JSON.stringify(value));
            } else {
                element.setAttribute(attrName, value.toString());
            }
        });

        return element;
    }

    createElements(tagName, dataArray) {
        return dataArray.map(data => this.createElement(tagName, data));
    }

    appendElements(container, tagName, dataArray) {
        const elements = this.createElements(tagName, dataArray);
        elements.forEach(el => container.appendChild(el));
        return elements;
    }
}

window.VAPR = new VAPRTemplateEngine();
window.VAPR.init();

VAPR.on('.menu-section', 'mounted', (element) => {
    const title = element.querySelector('.menu-section-title');
    if (title && title.textContent === 'Desktop App' && typeof window.__TAURI__ !== 'undefined') {
        element.style.display = 'none';
    }
});
class API {
    constructor() {
        this.baseURL = '';
        this.defaultHeaders = {
            'Content-Type': 'application/json'
        };
    }

    clearAuth() {
        localStorage.removeItem('userData');
        window.user = null;
    }

    async request(path, options = {}) {
        const {
            method = 'GET',
            body = null,
            requireAuth = true,
            headers = {},
            isFormData = false
        } = options;

        const requestHeaders = {
            ...(!isFormData ? this.defaultHeaders : {}),
            ...headers
        };

        try {
            const response = await fetch(path, {
                method,
                headers: requestHeaders,
                body: isFormData ? body : (body ? JSON.stringify(body) : null),
                credentials: 'include'
            });

            if (!response.ok) {
                if (response.status === 401 && requireAuth) {
                    this.clearAuth();
                   
                    throw new Error('Unauthorized');
                }
                throw new Error(`Network response was not ok: ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            throw error;
        }
    }

    get(path, requireAuth = true) {
        return this.request(path, { requireAuth });
    }

    post(path, body, options = {}) {
        return this.request(path, {
            method: 'POST',
            body,
            ...options
        });
    }

    async getMe() {
        return this.get('/me');
    }

    async getFeed() {
        return this.get('/feed', false);
    }

    async getPost(id) {
        if (!/^[a-f0-9-]{36}$/.test(id)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/posts/${id}`, false);
    }

    async createPost(formData) {
        return this.request('/posts', {
            method: 'POST',
            body: formData,
            isFormData: true,
            requireAuth: true
        });
    }

    async likePost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/like/${postId}`);
    }

    async dislikePost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/dislike/${postId}`);
    }

    async skipPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/skip/${postId}`);
    }

    async followPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/manage-follow?action=follow&postId=${postId}`);
    }

    async unfollowPost(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/manage-follow?action=unfollow&postId=${postId}`);
    }

    async checkFollowStatus(creatorId) {
        const data = await this.get(`/check-follow/${creatorId}`);
        return data.isFollowing || false;
    }

    async addReaction(postId, emoji) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        const allowedEmojis = ['ðŸ’©', 'ðŸ‘€', 'ðŸ˜‚', 'â¤ï¸', 'ðŸ’¯', 'null'];
        if (!allowedEmojis.includes(emoji)) {
            throw new Error('Invalid emoji');
        }
        return this.get(`/add-reaction?postId=${postId}&emoji=${encodeURIComponent(emoji)}`);
    }

    async getReactions(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/get-reactions?postId=${postId}`, false);
    }

    async registerView(postId) {
        if (!/^[a-f0-9-]{36}$/.test(postId)) {
            throw new Error('Invalid post ID format');
        }
        return this.get(`/register-view?postId=${postId}`, false);
    }

    async getMyPosts() {
        return this.get('/me/posts');
    }

    async updateBackground(backgroundUrl) {
        return this.get(`/me/update-background?backgroundId=${encodeURIComponent(backgroundUrl)}`);
    }

    async acceptInvitation(ambassadorUserId) {
        return this.get(`/accept-invitation?ambassadorUserId=${ambassadorUserId}`);
    }

    async getUserCount() {
        const response = await fetch('/api/user-count', {
            credentials: 'include'
        });
        return response.json();
    }

    async getUser(userId) {
        return this.get(`/api/user/${userId}`, false);
    }

    async getUserPosts(userId) {
        if (!userId) {
            throw new Error('userId required');
        }
        return this.get(`/api/user/${userId}/posts`, false);
    }

    async resolvePost(input) {
        if (!input) {
            throw new Error('id or url required');
        }
        if (typeof input === 'object') {
            if (input.id) {
                return this.get(`/api/post/resolve?id=${encodeURIComponent(input.id)}`, false);
            }
            if (input.url) {
                return this.get(`/api/post/resolve?url=${encodeURIComponent(input.url)}`, false);
            }
        }
        const str = String(input);
        if (/^[a-f0-9-]{36}$/i.test(str)) {
            return this.get(`/api/post/resolve?id=${encodeURIComponent(str)}`, false);
        }
        return this.get(`/api/post/resolve?url=${encodeURIComponent(str)}`, false);
    }

    async recordPlaytimeSession({ gameId, startedAt, endedAt, durationSeconds, executablePath }) {
        return this.post('/api/playtime/session', { gameId, startedAt, endedAt, durationSeconds, executablePath });
    }

    async getPlaytimeTotals() {
        return this.get('/api/playtime/totals');
    }
}

class APIHandler {
    static async handle(apiCall, options = {}) {
        const {
            onSuccess = () => {},
            onError = null,
            showLoading = false,
            successMessage = null,
            errorMessage = 'An error occurred',
            updateXP = false
        } = options;

        if (showLoading) showLoading();

        try {
            const data = await apiCall();

            if (updateXP && window.user && data.user) {
                const oldUser = {
                    xp: window.user.xp,
                    level: window.user.level,
                    xp_required: window.user.xp_required
                };
                window.user = data.user;
                setXPProgress(oldUser);
            }

            if (successMessage && window.notify) {
                window.notify.success(successMessage);
            }

            await onSuccess(data);
            return data;

        } catch (error) {
            console.error(error);

            if (onError) {
                await onError(error);
            } else if (window.notify) {
                window.notify.error('Error', errorMessage);
            }

            throw error;
        } finally {
            if (showLoading) hideLoading();
        }
    }
}

const api = new API();
window.api = api;
window.APIHandler = APIHandler;

window.makeApiRequest = function(path, requireAuth = true) {
    return api.get(path, requireAuth);
};

if (typeof window !== 'undefined' && window.__TAURI__ && window.__TAURI__.event && window.__TAURI__.core) {
    try {
        window.__TAURI__.event.listen('sdk-request', async (event) => {
            const { id, name, payload } = event.payload || {};
            if (!id || !name) return;
            try {
                let data;
                switch (name) {
                    case 'getFeed':
                        data = await api.getFeed();
                        break;
                    case 'getUserPosts':
                        data = await api.getUserPosts(payload && payload.userId);
                        break;
                    case 'resolvePost':
                        data = await api.resolvePost(payload);
                        break;
                    default:
                        throw new Error('Unknown sdk-request: ' + name);
                }
                await window.__TAURI__.core.invoke('sdk_response', { id, ok: true, data });
            } catch (err) {
                await window.__TAURI__.core.invoke('sdk_response', { id, ok: false, error: String(err && err.message || err) });
            }
        });
    } catch (e) {
        console.error('Failed to setup Tauri sdk-request listener', e);
    }
}
function loadUserData(){
    DOM.hide("sign_in");
    DOM.hide("add_post");

    api.getMe().then(function(data){
        window.user = data;

        if (window.updateSDKUserInfo) {
            window.updateSDKUserInfo();
        }

        updateUsername();
        updateLevel();

        try {
            if (typeof updateApplyUIForAuth === 'function') updateApplyUIForAuth();
        } catch (e) { }

        const oldUser = {
            xp: 0,
            level: window.user.level,
            xp_required: window.user.xp_required
        };

        setXPProgress(oldUser, true);

        syncBackgroundFromBackend();

        DOM.hide("sign_in");
        if(window.innerWidth <= 768){
            DOM.show("add_post");
        }

        DOM.show("xp_bar");

        loading_steps--;

        handleReferral();

        loadGamesData().then(() => {
            updateDeveloperSection();
            const accountSection = DOM.get('account_section');
            if (accountSection) DOM.show(accountSection);
        });

        checkAndShowUpdates();
    }).catch(error => {

        DOM.show("sign_in");
        if(window.innerWidth <= 768){
            DOM.show("add_post");
        }
        DOM.get("add_post").onclick = openRegisterModal;
        loading_steps--;

        try {
            if (typeof updateApplyUIForAuth === 'function') updateApplyUIForAuth();
        } catch (e) { }

        const accountSection = DOM.get('account_section');
        if (accountSection) DOM.hide(accountSection);
    })
}

function syncBackgroundFromBackend() {
    console.log(window.user);
    if (window.user && window.user.backgroundId) {
        equipBackground(window.user.backgroundId, false);
        console.log('Background synchronized from backend:', window.user.backgroundId);
    } else {
        const background_id = localStorage.getItem('background_id');
        if (background_id) {
            equipBackground(background_id, false);
        } else {
            setDefaultBackground();
        }
    }
}
async function equipBackground(postId, save = true) {
    let imageUrl = null;

    if (window.currentPostId === postId && window.currentPostImageUrl) {
        imageUrl = window.currentPostImageUrl;
    } else {
        imageUrl = await loadBackgroundFromPost(postId);
    }

    if (imageUrl) {
        document.body.style.backgroundImage = 'url(' + imageUrl + ')';

        localStorage.setItem('background_url', imageUrl);
        localStorage.setItem('background_id', postId);

        if (save && isUserLoggedIn() && navigator.onLine) {
            api.updateBackground(postId)
                .then(response => {
                    console.log('Background synced successfully:', response);
                    if (window.user) {
                        window.user.backgroundId = postId;
                    }
                })
                .catch(error => {
                    console.error('Failed to sync background:', error);
                });
        }
    }
}

async function loadBackgroundFromPost(postId) {
    try {
        const post = await api.resolvePost(postId);
        if (post && post.media) {
            document.body.style.backgroundImage = 'url(' + post.media + ')';
            return post.media;
        }
    } catch (error) {
        console.error('Failed to load background from post:', error);
    }
    return null;
}

function setDefaultBackground() {
    const defaultBgUrl = "2133e675-b741-4da0-9bd9-d519bfb72e1e";
    equipBackground(defaultBgUrl, true);
}
class DownloadManager {
    constructor() {
        this.downloads = new Map();
        this.queue = [];
        this.activeDownloads = new Set();
        this.maxConcurrentDownloads = 3;
        this.listeners = new Map();
        this.isActive = true;

        if (isRunningInTauri()) {
            this.initTauriListeners();
        }
    }

    pauseEventProcessing() {
        this.isActive = false;
    }

    resumeEventProcessing() {
        this.isActive = true;
    }

    async initTauriListeners() {
        await window.__TAURI__.event.listen('download-progress', (event) => {
            if (this.isActive) {
                this.handleProgress(event.payload);
            }
        });

        await window.__TAURI__.event.listen('download-status', (event) => {
            this.handleStatusChange(event.payload);
        });

        await window.__TAURI__.event.listen('download-complete', (event) => {
            this.handleCompletion(event.payload);
        });

        await window.__TAURI__.event.listen('download-error', (event) => {
            this.handleError(event.payload);
        });
    }

    async processQueue() {
        while (this.activeDownloads.size < this.maxConcurrentDownloads && this.queue.length > 0) {
            const downloadId = this.queue.shift();
            const download = this.downloads.get(downloadId);

            if (download && download.status === 'queued') {
                await this.startDownload(downloadId);
            }
        }
    }

    async startDownload(downloadId) {
        const download = this.downloads.get(downloadId);
        if (!download) return;

        download.status = 'preparing';
        download.startTime = Date.now();
        this.activeDownloads.add(downloadId);

        this.emit('download-started', download);

        try {
            const result = await window.__TAURI__.core.invoke('start_download', {
                downloadId: downloadId,
                gameId: download.gameId,
                gameName: download.title,
                downloadUrl: download.downloadUrl
            });

            if (!result.success) {
                throw new Error(result.error || 'Download failed to start');
            }

            download.status = 'downloading';
            this.emit('download-status-changed', download);

        } catch (error) {
            download.status = 'error';
            download.error = error.message;
            this.activeDownloads.delete(downloadId);
            this.emit('download-error', download);
            this.processQueue();
        }
    }

    async pauseDownload(downloadId) {
        const download = this.downloads.get(downloadId);
        if (!download || download.status !== 'downloading') return;

        try {
            await window.__TAURI__.core.invoke('pause_download', { downloadId });
            download.status = 'paused';
            this.activeDownloads.delete(downloadId);
            this.emit('download-paused', download);
            this.processQueue();
        } catch (error) {
            console.error('Failed to pause download:', error);
        }
    }

    async resumeDownload(downloadId) {
        const download = this.downloads.get(downloadId);
        if (!download || download.status !== 'paused') return;

        if (this.activeDownloads.size >= this.maxConcurrentDownloads) {
            download.status = 'queued';
            this.queue.push(downloadId);
            this.emit('download-queued', download);
            return;
        }

        try {
            await window.__TAURI__.core.invoke('resume_download', { downloadId });
            download.status = 'downloading';
            this.activeDownloads.add(downloadId);
            this.emit('download-resumed', download);
        } catch (error) {
            console.error('Failed to resume download:', error);
        }
    }

    async cancelDownload(downloadId) {
        const download = this.downloads.get(downloadId);
        if (!download) return;

        try {
            await window.__TAURI__.core.invoke('cancel_download', { downloadId });

            this.activeDownloads.delete(downloadId);
            this.queue = this.queue.filter(id => id !== downloadId);

            if (download.status !== 'completed') {
                this.downloads.delete(downloadId);
                this.emit('download-cancelled', download);
            }

            this.processQueue();
        } catch (error) {
            console.error('Failed to cancel download:', error);
        }
    }

    handleProgress(payload) {
        const download = this.downloads.get(payload.download_id);
        if (!download) return;

        download.progress = payload.percentage;
        download.downloadedSize = payload.downloaded;
        download.totalSize = payload.total;
        download.speed = payload.speed;
        download.eta = payload.eta;
        download.status = 'downloading';

        this.emit('download-progress', download);
    }

    handleStatusChange(payload) {
        const download = this.downloads.get(payload.download_id);
        if (!download) return;

        download.status = payload.status;
        download.statusText = payload.message;

        this.emit('download-status-changed', download);
    }

    handleCompletion(payload) {
        const download = this.downloads.get(payload.download_id);
        if (!download) return;

        download.status = 'completed';
        download.progress = 100;
        download.endTime = Date.now();
        download.installPath = payload.install_path;
        download.executable = payload.executable;

        this.activeDownloads.delete(payload.download_id);
        this.emit('download-completed', download);

        this.processQueue();
    }

    handleError(payload) {
        const download = this.downloads.get(payload.download_id);
        if (!download) return;

        download.status = 'error';
        download.error = payload.error;

        this.activeDownloads.delete(payload.download_id);
        this.emit('download-error', download);

        this.processQueue();
    }

    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
    }

    off(event, callback) {
        if (!this.listeners.has(event)) return;

        const callbacks = this.listeners.get(event);
        const index = callbacks.indexOf(callback);
        if (index > -1) {
            callbacks.splice(index, 1);
        }
    }

    emit(event, data) {
        if (!this.listeners.has(event)) return;

        if (!this.isActive && !['download-completed', 'download-error'].includes(event)) {
            return;
        }

        this.listeners.get(event).forEach(callback => {
            try {
                callback(data);
            } catch (error) {
                console.error(`Error in download manager listener for ${event}:`, error);
            }
        });
    }

    getDownloads() {
        return Array.from(this.downloads.values());
    }

    getActiveDownloads() {
        return this.getDownloads().filter(d => d.status === 'downloading');
    }

    getQueuedDownloads() {
        return this.getDownloads().filter(d => d.status === 'queued');
    }

    getCompletedDownloads() {
        return this.getDownloads().filter(d => d.status === 'completed');
    }

    clearCompleted() {
        const completed = this.getCompletedDownloads();
        completed.forEach(download => {
            this.downloads.delete(download.id);
        });
        this.emit('downloads-cleared', completed);
    }
}

window.downloadManager = new DownloadManager();
async function openDownloadsPage() {
    if (!isRunningInTauri()) {
        notify.warning('Desktop App Required', 'The downloads manager requires the VAPR desktop app.');
        return;
    }

    hideMenu();

    try {
       
        await window.__TAURI__.core.invoke('open_downloads_window');
    } catch (error) {
        console.error('Failed to open downloads window:', error);
        notify.error('Failed to open downloads window');
    }
}
async function loadGamesData() {
    try {
        DOM.show('games-loading');

        const [gamesResponse, userGamesResponse, totalsResponse] = await Promise.all([
            api.request('/api/games'),
            isUserLoggedIn() ? api.request('/api/my-games') : Promise.resolve({ games: [] }),
            isUserLoggedIn() ? api.getPlaytimeTotals().catch(() => ({ success: false, totals: [] })) : Promise.resolve({ success: true, totals: [] })
        ]);

        gamesData.allGames = gamesResponse.games || [];
        gamesData.userGames = userGamesResponse.games || [];

       
        gamesData.playtimeTotals = {};
        if (totalsResponse && totalsResponse.totals) {
            for (const t of totalsResponse.totals) {
                gamesData.playtimeTotals[t.gameId] = t.totalSeconds || 0;
            }
        }

        if (isRunningInTauri()) {
            try {
                const installedGames = await window.__TAURI__.core.invoke('get_installed_games');
                gamesData.installedGames = installedGames || [];
            } catch (error) {
                console.error('Error loading installed games:', error);
                gamesData.installedGames = [];
            }
        }
    } catch (error) {
        console.error('Error loading games:', error);
    } finally {
        DOM.hide('games-loading');
    }
}

async function loadLibraryData() {
    try {
        DOM.show('library-loading');

        const [response, totalsResponse] = await Promise.all([
            api.request('/api/my-games'),
            isUserLoggedIn() ? api.getPlaytimeTotals().catch(() => ({ success: false, totals: [] })) : Promise.resolve({ success: true, totals: [] })
        ]);
        gamesData.userGames = response.games || [];

        gamesData.playtimeTotals = {};
        if (totalsResponse && totalsResponse.totals) {
            for (const t of totalsResponse.totals) {
                gamesData.playtimeTotals[t.gameId] = t.totalSeconds || 0;
            }
        }

        if (isRunningInTauri()) {
            try {
                const installedGames = await window.__TAURI__.core.invoke('get_installed_games');
                gamesData.installedGames = installedGames || [];
            } catch (error) {
                console.error('Error loading installed games:', error);
                gamesData.installedGames = [];
            }
        }

        displayLibrary();
    } catch (error) {
        console.error('Error loading library:', error);
    } finally {
        DOM.hide('library-loading');
    }
}
function formatDurationShort(totalSeconds) {
    const seconds = Math.max(0, Math.floor(Number(totalSeconds || 0)));
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    if (hours > 0) return `${hours}h ${minutes}m`;
    if (minutes > 0) return `${minutes}m`;
    return `${secs}s`;
}

function displayLibrary() {
    const container = DOM.get('library-grid');
    container.innerHTML = '';

    if (gamesData.userGames.length === 0) {
        container.innerHTML += '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: rgba(255, 255, 255, 0.6);">No games in your library yet. Redeem a key to get started!</div>';
        return;
    }

    VAPR.appendElements(container, 'library-game-item',
        gamesData.userGames.map(game => {
            const isInstalled = gamesData.installedGames.some(g => g.id === game.id);
            const isDownloading = gamesData.downloadingGames.has(game.id);
            const isUpdating = gamesData.updatingGames.has(game.id);
            const installedGame = isInstalled ? gamesData.installedGames.find(g => g.id === game.id) : null;
            const hasUpdate = gamesData.updates.some(u => u.gameId === game.id);
            const updateInfo = hasUpdate ? gamesData.updates.find(u => u.gameId === game.id) : null;
            const totalSeconds = Number(gamesData.playtimeTotals?.[game.id] || 0);
            const totalPlaytime = formatDurationShort(totalSeconds);

            return {
                gameId: game.id,
                title: game.title,
                description: game.description,
                coverImage: game.coverImage,
                downloadUrl: game.downloadUrl || '',
                ownedAt: game.ownedAt,
                isInstalled: isInstalled ? 'true' : '',
                isDownloading: isDownloading ? 'true' : '',
                isUpdating: isUpdating ? 'true' : '',
                hasUpdate: hasUpdate ? 'true' : '',
                installedVersion: installedGame?.version || game.installedVersion || '',
                latestVersion: updateInfo?.toVersion || game.currentVersion || '',
                ...(installedGame?.executable && { executable: installedGame.executable.replaceAll('\\','/') }),
                ...(isDownloading && { downloadProgress: gamesData.downloadingGames.get(game.id) || 0 }),
                totalPlaytime,
                totalPlaytimeSeconds: totalSeconds
            };
        })
    );

    VAPR.refresh();
}
async function downloadGame(event, gameId, gameTitle, gameCover, downloadUrl) {
    event.stopPropagation();

    if (!isRunningInTauri()) {
        notify.desktopAppPrompt(() => downloadDesktopApp());
        return;
    }

    try {
        const game = gamesData.userGames.find(g => g.id === gameId);
        if (!game) {
            throw new Error('Game not found');
        }

        const downloadId = `download-${Date.now()}-${gameId}`;

        await window.__TAURI__.core.invoke('start_download', {
            downloadId: downloadId,
            gameId: gameId,
            gameName: gameTitle,
            gameCover: gameCover,
            downloadUrl: downloadUrl
        });

        console.log({
            downloadId: downloadId,
            gameId: gameId,
            gameName: gameTitle,
            gameCover: gameCover,
            downloadUrl: downloadUrl
        });

        await window.__TAURI__.core.invoke('open_downloads_window');

        notify.success('Download started', `${gameTitle} has been added to your downloads.`);

    } catch (error) {
        console.error('Error starting download:', error);
        notify.error('Download Failed', error.message || 'Failed to start download');
    }
}

function updateGameDownloadProgress(gameId, progress) {
    const gameEl = DOM.get(`game-item-${gameId}`);
    if (!gameEl) return;

    const progressFill = DOM.get(`download-fill-${gameId}`);
    if (progressFill) {
        progressFill.style.width = `${progress.percentage}%`;
    }

    const progressEl = DOM.get(`download-progress-${gameId}`);
    if (progressEl) {
        progressEl.textContent = `${Math.round(progress.percentage)}%`;
    }

    const speedEl = DOM.get(`download-speed-${gameId}`);
    if (speedEl) {
        speedEl.textContent = `${progress.speed.toFixed(2)} MB/s`;
    }

    const sizeEl = DOM.get(`download-size-${gameId}`);
    if (sizeEl) {
        const downloaded = (progress.downloaded / 1024 / 1024).toFixed(2);
        const total = (progress.total / 1024 / 1024).toFixed(2);
        sizeEl.textContent = `${downloaded} MB / ${total} MB`;
    }

    const etaEl = DOM.get(`download-eta-${gameId}`);
    if (etaEl) {
        etaEl.textContent = formatTime(progress.eta);
    }
}

function updateGameDownloadStatus(gameId, statusText) {
    const gameEl = DOM.get(`game-item-${gameId}`);
    if (!gameEl) return;

    const subtitleEl = gameEl.querySelector('.download-progress-subtitle');
    if (subtitleEl) DOM.setText(subtitleEl, statusText);
}

function cancelDownload(gameId) {
    gamesData.downloadingGames.delete(gameId);
    gamesData.updatingGames.delete(gameId);
    displayLibrary();
}

async function uninstallGame(event, gameId, gameTitle) {
    event.stopPropagation();

    const confirmed = await notify.confirmDanger(
        'Uninstall Game?',
        `Are you sure you want to uninstall ${gameTitle}? This will remove all game files from your computer.`,
        'Yes, uninstall'
    );

    if (confirmed) {
        try {
            await window.__TAURI__.core.invoke('uninstall_game', { gameId });
            notify.success(`${gameTitle} uninstalled successfully`);
            await loadLibraryData();
        } catch (error) {
            console.error('Error uninstalling game:', error);
            notify.error('Uninstall Failed', error.message || 'Failed to uninstall the game. Please try again.');
        }
    }
}

async function launchGame(event, executablePath) {
    event.stopPropagation();

    if (!isRunningInTauri()) return;

    const button = event.target.closest('button');
    const originalContent = button.innerHTML;
    button.disabled = true;
    button.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Launching...';

    try {
        console.log({executablePath});
        await window.__TAURI__.core.invoke('launch_game', {
            executablePath: executablePath
        });
        notify.success("Game launched!");
    } catch (error) {
        console.error('Error launching game:', error);
        notify.error('Launch Failed', error.message || 'Failed to launch the game. Please try again.');
    } finally {
        button.disabled = false;
        button.innerHTML = originalContent;
    }
}

async function downloadUpdate(gameId, version, gameTitle, gameCover, downloadUrl) {
    if (!isRunningInTauri()) {
        notify.desktopAppPrompt(() => downloadDesktopApp());
        return;
    }

    try {
        const downloadId = `update-${Date.now()}-${gameId}`;

        await window.__TAURI__.core.invoke('start_download', {
            downloadId: downloadId,
            gameId: gameId,
            gameName: gameTitle,
            gameCover: gameCover,
            downloadUrl: downloadUrl
        });

        await markUpdateSeen(gameId);

        await window.__TAURI__.core.invoke('open_downloads_window');

        notify.success('Update started', `${gameTitle} update has been added to your downloads.`);

        gamesData.updatingGames.set(gameId, true);
        displayLibrary();

    } catch (error) {
        console.error('Error starting update:', error);
        notify.error('Update Failed', error.message || 'Failed to start update');
    }
}

function formatTime(seconds) {
    if (seconds === 0) return 'Calculating...';

    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
        return `${hours}h ${minutes}m remaining`;
    } else if (minutes > 0) {
        return `${minutes}m ${secs}s remaining`;
    } else {
        return `${secs}s remaining`;
    }
}

let __vaprPlaytimeUnlisten = null;
async function initPlaytimeListener() {
    if (!isRunningInTauri() || __vaprPlaytimeUnlisten) return;
    __vaprPlaytimeUnlisten = await window.__TAURI__.event.listen('playtime-session', async (event) => {
        try {
            const p = event.payload || {};
           
            const startedAt = p.started_at || p.startedAt;
            const endedAt = p.ended_at || p.endedAt;
            const durationSeconds = Number(p.duration_seconds ?? p.durationSeconds ?? 0);
            const executablePath = p.executable_path || p.executablePath || '';

            let gameId = p.game_id || p.gameId || null;
            if (!gameId && Array.isArray(gamesData.installedGames)) {
                const norm = (s) => String(s || '').replaceAll('\\','/').toLowerCase();
                const match = gamesData.installedGames.find(g => norm(g.executable) === norm(executablePath));
                if (match && match.id) gameId = match.id;
            }

            if (!gameId || !durationSeconds || durationSeconds <= 0) {
                console.warn('Skipping playtime session post due to missing data', p);
                return;
            }

            await APIHandler.handle(
                () => api.recordPlaytimeSession({ gameId, startedAt, endedAt, durationSeconds, executablePath }),
                {
                    onSuccess: async () => {
                        try {
                            const res = await api.getPlaytimeTotals();
                            if (res && res.totals) {
                                gamesData.playtimeTotals = {};
                                for (const t of res.totals) {
                                    gamesData.playtimeTotals[t.gameId] = t.totalSeconds || 0;
                                }
                               
                                if (typeof displayLibrary === 'function') displayLibrary();
                            }
                        } catch (e) {
                            console.error('Failed to refresh playtime totals:', e);
                        }
                    },
                    onError: (e) => console.error('Failed to record playtime session:', e),
                    showLoading: false,
                }
            );
        } catch (err) {
            console.error('Error handling playtime-session event:', err);
        }
    });
}

if (isRunningInTauri()) {
    initPlaytimeListener();
}

window.downloadGame = downloadGame;
window.updateGameDownloadProgress = updateGameDownloadProgress;
window.updateGameDownloadStatus = updateGameDownloadStatus;
window.cancelDownload = cancelDownload;
window.uninstallGame = uninstallGame;
window.launchGame = launchGame;
window.downloadUpdate = downloadUpdate;
cardManager.register('library-card', {
    route: '/library',
    onLoad: async () => {
        await loadLibraryData();
    }
});

function initGameEventListeners() {
    const gamesGrid = DOM.get('games-grid');
    if (gamesGrid) {
        gamesGrid.addEventListener('click', (e) => {
            const gameItem = e.target.closest('.game-item');
            if (gameItem && !e.target.closest('button')) {
                const gameId = gameItem.id.replace('game-item-', '');
                const game = gamesData.allGames.find(g => g.id === gameId);
                if (game && game.externalLink) {
                    window.open(game.externalLink, '_blank');
                }
            }
        });
    }
}

async function openMyLibrary() {
    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }
    hideMenu();
    router.navigate('/library', true);
}

function closeLibraryCard() {
    cardManager.hide('library-card');
}

function openRedeemModal() {
    DOM.show('redeem-modal', 'flex');
    DOM.get('game-key-input').value = '';
    DOM.get('game-key-input').focus();
}

function closeRedeemModal() {
    DOM.hide('redeem-modal');
}

async function redeemKey(event) {
    event.preventDefault();

    const keyInput = DOM.get('game-key-input');
    const key = keyInput.value.trim();

    try {
        const response = await api.request('/api/games/redeem-key', {
            method: 'POST',
            body: { key }
        });

        if (response.success) {
            closeRedeemModal();

            await notify.confirm(
                'Success!',
                `You now own ${response.game.title}!`,
                {
                    icon: 'success',
                    confirmButtonText: 'View Library',
                    showCancelButton: false
                }
            );
            openMyLibrary();
            await loadLibraryData();
        }
    } catch (error) {
        notify.error('Invalid Key', error.message || 'The key you entered is invalid or has already been used.');
    }
}

VAPR.on('.game-tag-item', 'mounted', (element) => {
    const titleEl = element.querySelector('.game-tag-item-title');
    if (titleEl) {
        const gameTitle = titleEl.textContent;
        const toSlug = (s) => String(s)
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
        const slug = toSlug(gameTitle);

        element.onclick = (e) => {
            e.preventDefault();
            router.navigate(`/games/${slug}`, true);
        };
    }
});

window.openTaggedGame = async function() {
    loading.show();
    if (window.currentPostTaggedGame && window.currentPostTaggedGame.id) {
        if (current_post && current_post.id) {
            try {
                const gameId = window.currentPostTaggedGame.id;
                console.log('Tracking game click for game:', gameId, 'post:', current_post.id);

                await api.request('/api/creators/track-game-click', {
                    method: 'POST',
                    body: {
                        gameId: gameId,
                        postId: current_post.id
                    }
                });
                console.log('Successfully tracked game click for creator attribution');
            } catch (error) {
                console.error('Failed to track game click:', error);
            }
        }

        if (!gamesData.tebexGames || gamesData.tebexGames.length === 0) {
            await loadTebexGames();
        }

        const toSlug = (s) => String(s)
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
        const slug = toSlug(window.currentPostTaggedGame.title);

        loading.hide();
        router.navigate(`/games/${slug}`, true);
    }
};

document.addEventListener('DOMContentLoaded', () => {
    initGameEventListeners();
    if (isUserLoggedIn()) {
        setTimeout(checkAndShowUpdates, 3000);
    }
});

setInterval(() => {
    if (isUserLoggedIn()) {
        checkAndShowUpdates();
    }
}, 5 * 60 * 1000);
function openRedeemModal() {
    document.getElementById('redeem-modal').style.display = 'flex';
    document.getElementById('game-key-input').value = '';
    document.getElementById('game-key-input').focus();
}

function closeRedeemModal() {
    document.getElementById('redeem-modal').style.display = 'none';
}

async function redeemKey(event) {
    event.preventDefault();

    const keyInput = document.getElementById('game-key-input');
    const key = keyInput.value.trim();

    try {
        const response = await api.request('/api/games/redeem-key', {
            method: 'POST',
            body: { key }
        });

        if (response.success) {
            closeRedeemModal();

            await notify.confirm(
                'Success!',
                `You now own ${response.game.title}!`,
                {
                    icon: 'success',
                    confirmButtonText: 'View Library',
                    showCancelButton: false
                }
            );

            closeGamesCard();
            openMyLibrary();
            await loadLibraryData();
        }
    } catch (error) {
        notify.error('Invalid Key', error.message || 'The key you entered is invalid or has already been used.');
    }
}
window.gamesData = {
    allGames: [],
    userGames: [],
    currentManagingGame: null,
    installedGames: [],
    downloadingGames: new Map(),
    currentKeyFilter: 'all',
    allKeys: [],
    updates: [],
    versions: [],
    updatingGames: new Map(),
   
    playtimeTotals: {}
};
async function loadTebexGames() {
    try {
       
        const tebexResponse = await tebexAPI.getAllPackages();
        const tebexGames = tebexResponse.data || [];

        console.log('Loaded games from multiple Tebex stores:', tebexGames);

        const transformedGames = transformTebexGames(tebexGames);

        gamesData.tebexGames = transformedGames;

        displayGames();
    } catch (error) {
        console.error('Error loading Tebex games:', error);
    }
}

function transformTebexGames(tebexPackages) {
    return tebexPackages.map(pkg => ({
        id: `tebex-${pkg.id}`,
        title: pkg.name,
        description: pkg.description,
        coverImage: pkg.image || 'https://via.placeholder.com/300x169',
        price: pkg.total_price,
        currency: pkg.currency,
        isTebexProduct: true,
        tebexId: pkg.id,
        category: pkg.category?.name || 'Games',
        onSale: pkg.discount > 0,
        originalPrice: pkg.base_price,
        salePrice: pkg.total_price,
        discount: pkg.discount,
       
        storeInfo: pkg.storeInfo,
        developer: pkg.storeInfo?.username || 'Unknown'
    }));
}
async function findGameIdFromPackageId(packageId) {
    const tebexGame = gamesData.tebexGames?.find(g => g.tebexId === packageId);
    if (tebexGame) {
        const vaprGameId = await findVAPRGameIdByTitle(tebexGame.title);
        return vaprGameId;
    }
    return null;
}

function handleCheckoutSuccess() {
    notify.success('Purchase completed successfully!');

    if (window.loadLibraryData) {
        loadLibraryData();
    }
}

function handleCheckoutCancel() {
    notify.info('Checkout cancelled');
}

document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);

    if (window.location.pathname === '/checkout/success') {
        handleCheckoutSuccess();
        window.history.replaceState({}, '', '/');
    } else if (window.location.pathname === '/checkout/cancel') {
        handleCheckoutCancel();
        window.history.replaceState({}, '', '/');
    }
});

const originalLoadUserData = window.loadUserData;
window.loadUserData = function() {
    originalLoadUserData();
};
async function checkForGameUpdates() {
    return api.request('/api/updates/check');
}

async function markUpdateSeen(gameId) {
    return api.request(`/api/updates/${gameId}/seen`, {
        method: 'POST'
    });
}

async function markUpdateDownloaded(gameId, version) {
    return api.request(`/api/updates/${gameId}/downloaded`, {
        method: 'POST',
        body: { version }
    });
}

async function checkAndShowUpdates() {
    if (!isUserLoggedIn()) return;

    try {
        const response = await checkForGameUpdates();
        if (response.success && response.updates.length > 0) {
            gamesData.updates = response.updates;
            showUpdateNotification(response.updates.length);
        }
    } catch (error) {
        console.error('Error checking for updates:', error);
    }
}

function showUpdateNotification(count) {
    const libraryMenuItems = DOM.queryAll('.menu-item');
    libraryMenuItems.forEach(item => {
        const icon = item.querySelector('.menu-item-icon.library');
        if (icon && !icon.querySelector('.update-badge')) {
            const badge = DOM.create('span', {
                class: 'update-badge'
            }, count);
            icon.appendChild(badge);
        }
    });
}
function isRunningInTauri() {
    return typeof window.__TAURI__ !== 'undefined';
}

function isGameDeveloper() {
    if (!window.user) return false;

    return gamesData.allGames.some(game => game.ownerId === window.user.id);
}

async function findVAPRGameIdByTitle(title) {
    if (!title) return null;

    try {
        let vaprGames = gamesData.allGames;

        if (!vaprGames || vaprGames.length === 0) {
            const response = await api.request('/api/games');
            if (response.success) {
                vaprGames = response.games;
            } else {
                return null;
            }
        }

        const matchedGame = vaprGames.find(g =>
            g.title.toLowerCase() === title.toLowerCase()
        );

        return matchedGame?.id || null;
    } catch (error) {
        console.error('Error finding VAPR game by title:', error);
        return null;
    }
}

window.findVAPRGameIdByTitle = findVAPRGameIdByTitle;
async function updateGithubStars(element) {
    try {
        const response = await fetch('https://api.github.com/repos/Vic92548/VAPR');
        if (!response.ok) throw new Error('GitHub API error');

        const data = await response.json();
        const stars = data.stargazers_count;

        element.innerHTML = `<i class="fa-solid fa-star"></i> ${stars}`;
    } catch (error) {
        console.error('Failed to fetch GitHub stars:', error);
        element.innerHTML = '<i class="fa-solid fa-star"></i> N/A';
    }
}

if (window.VAPR) {
    VAPR.on('#github_stars', 'mounted', (element) => {
        console.log({element});
        console.log(element.querySelector('.menu-badge'));
        updateGithubStars(element.querySelector('.menu-badge'));
    });
}
function initPlayerPreferences() {
    if (!window.user) {
        const backgroundUrl = localStorage.getItem('background_url');

        if(backgroundUrl){
            equipBackground(backgroundUrl, false);
        }
    }
}

initPlayerPreferences();
let feed_posts = [];
let loading_steps = 2;
let post_seen = 0;
let creators = {};

function showInitialPost() {
    const path = window.location.pathname.split('/');
    showPost();
    if(path.length < 3){
        displayPost();
    }else if(path[1] === "post"){
        displayPost(path[2]);
    }
}

function isUserLoggedIn(){
    if(window.user){
        return true;
    }else{
        return false;
    }
}

function updateUsername() {
    const level_elements = document.getElementsByClassName("username");
    for (let i = 0; i < level_elements.length; i++) {
        level_elements[i].textContent = user.username;
        console.log("updated username : " + user.username);
    }
}

loadUserData();

let current_post_id = undefined;
let current_post = undefined;

function hidePost() {
    DOM.get("post_video").children[0].src = "";
    document.getElementsByClassName("post")[0].style.transform = "translateY(100vh)";
}

cardManager.register('add-post-card', {
    route: '/new-post',
    onShow: () => {
        setTimeout(() => {
            const titleInput = DOM.get('title');
            if (titleInput) titleInput.focus();
        }, 500);
    }
});

function opeNewPostModel() {
    if (isUserLoggedIn()) {
        hideMenu();
        router.navigate('/new-post', true);
    } else {
        openRegisterModal();
    }
}

function closeAddPostCard() {
    cardManager.hide('add-post-card');
}

function openRegisterModal() {
    DOM.show("register", "flex");
}

async function updateFollowButton() {
    const follow_bt = DOM.get("follow");

    if(isUserLoggedIn()){
        let following;

        console.log("CURRENT POST");
        console.log(current_post);

        if(creators[current_post.userId]){
            following = creators[current_post.userId].following;
        }else{
            creators[current_post.userId] = {
                following: false
            }
        }

        if(following === undefined){
            following = await checkUserFollowsCreator(current_post.userId);
            creators[current_post.userId].following = following;
        }

        follow_bt.style.opacity = "0";
        follow_bt.style.display = "inline-block";

        if(following){
            follow_bt.innerHTML = '<i class="fa-solid fa-user-minus"></i>';
            follow_bt.onclick = unfollowPost;
            follow_bt.style.border = "1px solid rgb(206 220 247 / 42%)";
            follow_bt.style.backgroundColor = "rgb(190 213 255 / 40%)";
        }else{
            follow_bt.innerHTML = '<i class="fa-solid fa-user-plus"></i>';
            follow_bt.onclick = followPost;
            follow_bt.style.border = "1px solid rgb(77 137 245)";
            follow_bt.style.backgroundColor = "rgb(95 148 243)";
        }

        follow_bt.style.opacity = "1";

        if(current_post.userId === user.id){
            follow_bt.style.opacity = "0";
            follow_bt.style.display = "none";
        }
    }else{
        follow_bt.onclick = openRegisterModal;
    }
}

function followPost() {
    creators[current_post.userId].following = true;
    updateFollowButton();
    if(isUserLoggedIn()){
        APIHandler.handle(
            () => api.followPost(current_post.id),
            {
                errorMessage: 'Error when trying to follow. Please try again.'
            }
        );
    }else{
        openRegisterModal();
    }
}

function unfollowPost() {
    creators[current_post.userId].following = false;
    updateFollowButton();
    if(isUserLoggedIn()){
        APIHandler.handle(
            () => api.unfollowPost(current_post.id)
        );
    }else{
        openRegisterModal();
    }
}

async function checkUserFollowsCreator(creatorId) {
    try {
        const isFollowing = await api.checkFollowStatus(creatorId);
        console.log('Check follow status:', isFollowing);
        return isFollowing;
    } catch (error) {
        console.error('Error checking follow status:', error);
        return false;
    }
}

function openMenu() {
    DOM.show("menu", 'flex');
}

function hideMenu() {
    if(window.innerWidth <= 768){
        DOM.hide("menu");
    }
}

if(window.innerWidth >= 768){
    DOM.show("menu", 'flex');
}

function processJoinQueryParam() {
    const url = new URL(window.location.href);
    const params = url.searchParams;

    if (params.has('join')) {
        const joinValue = params.get('join');
        console.log("Join param found with value = " + joinValue);
        localStorage.setItem('referrerId', joinValue);
        params.delete('join');
        window.history.replaceState({}, '', url.toString());
    }
}

function handleReferral() {
    const referrerId = localStorage.getItem('referrerId');

    if (referrerId) {
        APIHandler.handle(
            () => api.acceptInvitation(referrerId),
            {
                onSuccess: (data) => {
                    console.log('Invitation processed:', data);
                    if(creators[referrerId]){
                        creators[referrerId].following = true;
                        updateFollowButton();
                    }
                    localStorage.removeItem('referrerId');
                },
                onError: (error) => {
                    localStorage.removeItem('referrerId');
                }
            }
        );
    }
}

function closeTextModal() {
    DOM.hide("text_modal");
}

function copyReferrerId() {
    if(isUserLoggedIn()){
        const referralUrl = `https://vapr.club?join=${user.id}`;
        notify.copyToClipboard(referralUrl, "Invitation link copied to clipboard!");
    }else{
        openRegisterModal();
    }
}

processJoinQueryParam();

function navigateToMyProfile() {
    router.navigate(`/@${window.user.username}`, false);
}

window.closeProfileCard = function() {
    cardManager.hide('profile-card');
};

router.handleRoute();
function initMenu() {
    if (isUserLoggedIn()) {
        updateMenuUserInfo();
        showMenuUserElements();
    }

    updateOnlineUsers();
    addMenuAnimations();

    if (window.innerWidth >= 769) {
        initMenuCollapseState();
        addCollapsedMenuInteractions();
    }
}

function updateDeveloperSection() {
    const devSection = DOM.query('.menu-section[title="Developer"]');
    if (devSection) {
        devSection.style.display = isGameDeveloper() ? 'block' : 'none';
    }
}

function toggleMenuCollapse() {
    const menuContainer = DOM.query('.menu-container');
    const mainElement = DOM.query('main');
    const toggleButton = DOM.query('.menu-toggle i');

    if (!menuContainer) return;

    menuContainer.classList.toggle('collapsed');

    if (mainElement) {
        mainElement.classList.toggle('menu-collapsed');
    }

    const isCollapsed = menuContainer.classList.contains('collapsed');
    localStorage.setItem('menuCollapsed', isCollapsed);

    updateMenuTooltips(isCollapsed);

    if (toggleButton) {
        toggleButton.style.transform = isCollapsed ? 'rotate(180deg)' : 'rotate(0deg)';
    }
}

function updateMenuTooltips(isCollapsed) {
    const menuItems = DOM.queryAll('.menu-item');

    menuItems.forEach(item => {
        if (isCollapsed) {
            const title = item.querySelector('.menu-item-title');
            if (title) {
                item.setAttribute('data-tooltip', title.textContent);
            }
        } else {
            item.removeAttribute('data-tooltip');
        }
    });
}

function initMenuCollapseState() {
    const savedState = localStorage.getItem('menuCollapsed');
    const menuContainer = DOM.query('.menu-container');
    const mainElement = DOM.query('main');

    if (savedState === 'true' && menuContainer) {
        menuContainer.classList.add('collapsed');
        if (mainElement) {
            mainElement.classList.add('menu-collapsed');
        }
        updateMenuTooltips(true);

        const toggleButton = DOM.query('.menu-toggle i');
        if (toggleButton) {
            toggleButton.style.transform = 'rotate(180deg)';
        }
    }
}

function addCollapsedMenuInteractions() {
    const menuContainer = DOM.query('.menu-container');
    if (!menuContainer) return;
}

function updateMenuUserInfo() {
    if (!window.user) return;

    const menuAvatar = DOM.get('menu_user_avatar');
    if (menuAvatar && window.user.avatar) {
        menuAvatar.src = `https://cdn.discordapp.com/avatars/${window.user.id}/${window.user.avatar}.png?size=128`;
    } else if (menuAvatar) {
        menuAvatar.src = 'https://vapr-club.b-cdn.net/default_vapr_avatar.png';
    }

    const menuUsername = DOM.get('menu_username');
    if (menuUsername) {
        menuUsername.textContent = '@' + window.user.username;
    }

    const menuLevel = DOM.get('menu_user_level');
    if (menuLevel) {
        menuLevel.textContent = window.user.level || 0;
    }

    updateMenuXPBar();
}

function updateMenuXPBar() {
    if (!window.user) return;

    const xp = window.user.xp || 0;
    const xpRequired = window.user.xp_required || 700;
    const xpPercentage = (xp / xpRequired) * 100;

    const xpBar = DOM.get('menu_xp_bar');
    const xpText = DOM.get('menu_xp_text');

    if (xpBar) {
        xpBar.style.width = xpPercentage + '%';
    }

    if (xpText) {
        xpText.textContent = `${xp} / ${xpRequired} XP`;
    }
}

function showMenuUserElements() {
    const userCard = DOM.get('menu_user_info');
    const accountSection = DOM.get('account_section');

    if (userCard) DOM.show(userCard, 'flex');
    if (accountSection) DOM.show(accountSection);
}

async function updateOnlineUsers() {
    try {
        const data = await api.getUserCount();

        const onlineEl = DOM.get('online_users');
        if (onlineEl && data.count) {
            onlineEl.textContent = data.count.toLocaleString() + ' users';
        }
    } catch (error) {
        console.error('Error fetching online users:', error);
    }
}

function addMenuAnimations() {
    const menuItems = DOM.queryAll('.menu-item');

    menuItems.forEach((item, index) => {
        item.style.opacity = '0';
        item.style.transform = 'translateX(-20px)';

        setTimeout(() => {
            item.style.transition = 'all 0.3s ease';
            item.style.opacity = '1';
            item.style.transform = 'translateX(0)';
        }, index * 50);

        item.addEventListener('mouseenter', () => {
        });
    });
}

function isRunningInTauri() {
    return typeof window.__TAURI__ !== 'undefined';
}

function getLatestVersion() {
    const versionElement = DOM.query('.menu-version span');
    if (versionElement) {
        const versionText = versionElement.textContent;
        const versionMatch = versionText.match(/v(\d+\.\d+\.\d+)/);
        if (versionMatch) {
            return versionMatch[1];
        }
    }
    return '1.1.19';
}

function downloadDesktopApp() {
    const version = getLatestVersion();
    const downloadUrl = `https://github.com/Vic92548/VAPR/releases/download/v${version}/VAPR_${version}_x64_en-US.msi`;

    if (window.analytics && window.analytics.track) {
        window.analytics.track('desktop_app_download_clicked', {
            version: version,
            platform: 'windows'
        });
    }

    window.open(downloadUrl, '_blank');

    notify.info("Download started!", `The VAPR desktop app download should begin shortly.<br><small>Windows 64-bit â€¢ v${version}</small>`, {
        timer: 5000
    });
}

function openMenu() {
    const menu = DOM.get('menu');
    if (!menu) return;

    DOM.show(menu, 'flex');

    if (isUserLoggedIn()) {
        updateMenuUserInfo();
        showMenuUserElements();
    } else {
        const accountSection = DOM.get('account_section');
        if (accountSection) DOM.hide(accountSection);
    }

    const menuContainer = menu.querySelector('.menu-container');
    if (menuContainer) {
        menuContainer.style.transform = 'translateX(-100%)';
        menuContainer.style.opacity = '0';

        setTimeout(() => {
            menuContainer.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
            menuContainer.style.transform = 'translateX(0)';
            menuContainer.style.opacity = '1';
        }, 10);
    }

    addMenuAnimations();
}

function hideMenu() {
    const menu = DOM.get('menu');
    if (!menu) return;

    const menuContainer = menu.querySelector('.menu-container');
    if (menuContainer) {
        menuContainer.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        menuContainer.style.transform = 'translateX(-100%)';
        menuContainer.style.opacity = '0';

        setTimeout(() => {
            DOM.hide(menu);
        }, 300);
    } else {
        DOM.hide(menu);
    }
}

async function logout() {
    const confirmed = await notify.confirm('Logout', 'Are you sure you want to logout?');

    if (confirmed) {
        try {
            await fetch('/logout', {
                method: 'POST',
                credentials: 'include'
            });

            localStorage.removeItem('userData');

            if (window.clearSDKUserInfo) {
                window.clearSDKUserInfo();
            }

            window.user = null;
            window.location.href = '/';
        } catch (error) {
            console.error('Logout error:', error);
            window.location.href = '/';
        }
    }
}

let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        if (window.innerWidth < 769) {
            const menuContainer = DOM.query('.menu-container');
            const mainElement = DOM.query('main');

            if (menuContainer) {
                menuContainer.classList.remove('collapsed');
            }
            if (mainElement) {
                mainElement.classList.remove('menu-collapsed');
            }
        } else {
            initMenuCollapseState();
        }
    }, 250);
});

const originalOpenNewPostModel = window.opeNewPostModel;
window.opeNewPostModel = function() {
    hideMenu();
    originalOpenNewPostModel();
};

const originalOpenAnalytics = window.openAnalytics;
window.openAnalytics = function() {
    hideMenu();
    originalOpenAnalytics();
};

const originalOpenLeaderboardModal = window.openLeaderboardModal;
window.openLeaderboardModal = function() {
    hideMenu();
    originalOpenLeaderboardModal();
};

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        initMenu();

        if (window.innerWidth >= 769) {
            initMenuCollapseState();
        }

        if (window.user && window.VAPR) {
            insertVAPRUserInfo();
        }
    });

    const originalLoadUserData = window.loadUserData;
    window.loadUserData = function() {
        originalLoadUserData();
        setTimeout(() => {
            initMenu();
            if (window.user && window.VAPR) {
                insertVAPRUserInfo();
            }
        }, 500);
    };
}

if (window.VAPR && typeof window.VAPR.on === 'function') {
    const toggleAccountSection = (el) => {
        if (isUserLoggedIn()) {
            DOM.show(el);
        } else {
            DOM.hide(el);
        }
    };

    window.VAPR.on('#account_section', 'created', toggleAccountSection);
    window.VAPR.on('#account_section', 'mounted', toggleAccountSection);
}

function insertVAPRUserInfo() {
    const menuHeader = DOM.query('.menu-header');
    if (!menuHeader) return;

    const container = menuHeader.parentElement;
    const menuNav = container.querySelector('.menu-nav');

    const existingUserInfo = DOM.get('menu_user_info');
    if (existingUserInfo) existingUserInfo.remove();

    const avatarUrl = window.user.avatar
        ? `https://cdn.discordapp.com/avatars/${window.user.id}/${window.user.avatar}.png?size=128`
        : 'https://vapr-club.b-cdn.net/default_vapr_avatar.png';

    const xpPercent = ((window.user.xp || 0) / (window.user.xp_required || 700)) * 100;

    const userInfo = DOM.create('user-info-card', {
        id: 'menu_user_info',
        avatar: avatarUrl,
        username: '@' + window.user.username,
        level: window.user.level || 0,
        xp: window.user.xp || 0,
        'xp-required': window.user.xp_required || 700,
        'xp-percent': xpPercent.toFixed(1)
    });

    container.insertBefore(userInfo, menuNav);
}
function drawPost(data){
    displayReactions();

    APIHandler.handle(
        () => api.registerView(data.id),
        {
            onSuccess: (data) => {
                console.log(data);
                console.log("Views updated");
            }
        }
    );

    post_seen++;
    showPost();
    console.log("Post DATA:");
    console.log(data);

    updateFollowButton();

    const titleEl = DOM.get("post_title");
    const showMoreButtonEl = DOM.get("post_title_show_more");
    titleEl.textContent = data.title;

    requestAnimationFrame(() => {
        const isClamped = titleEl.scrollHeight > titleEl.clientHeight;

        if (isClamped) {
            showMoreButtonEl.style.display = "inline-block";
            showMoreButtonEl.onclick = () => {
                titleEl.classList.toggle("expanded");
                const isExpanded = titleEl.classList.contains("expanded");
                showMoreButtonEl.innerHTML = isExpanded
                    ? `<i class="fa-solid fa-chevron-up"></i> Show less`
                    : `<i class="fa-solid fa-chevron-down"></i> Show more`;

                if (isExpanded) {
                    titleEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            };
        } else {
            showMoreButtonEl.style.display = "none";
        }
    });

    const username = data.username;
    DOM.setText("post_username", "@" + username);

    const avatarImg = DOM.get("user_avatar_img");
    const avatarLetter = DOM.get("avatar_letter");
    const avatarEl = DOM.get("user_avatar");

    function showLetterAvatar() {
        DOM.hide(avatarImg);
        DOM.show(avatarLetter, "flex");
        avatarLetter.textContent = username.charAt(0).toUpperCase();

        const hue = username.charCodeAt(0) * 3 % 360;
        avatarEl.style.background = `linear-gradient(135deg, hsl(${hue}, 70%, 50%), hsl(${hue + 30}, 70%, 60%))`;
    }

    function showDiscordAvatar(avatarHash) {
        if (avatarHash) {
            avatarImg.src = `https://cdn.discordapp.com/avatars/${data.userId}/${avatarHash}.png?size=128`;
            DOM.show(avatarImg);
            DOM.hide(avatarLetter);
            avatarEl.style.background = "none";

            avatarImg.onerror = () => {
                console.log("Failed to load Discord avatar, showing fallback");
                showLetterAvatar();
            };
        } else {
            showLetterAvatar();
        }
    }

    if (data.userAvatar !== undefined) {
        showDiscordAvatar(data.userAvatar);

        if (!window.creators) {
            window.creators = {};
        }
        if (!window.creators[data.userId]) {
            window.creators[data.userId] = {};
        }
        window.creators[data.userId].avatar = data.userAvatar;
        window.creators[data.userId].username = data.username;
        window.creators[data.userId].level = data.userLevel || 0;
    }
    else if (window.creators && window.creators[data.userId] && window.creators[data.userId].avatar !== undefined) {
        showDiscordAvatar(window.creators[data.userId].avatar);
    }
    else {
        APIHandler.handle(
            () => api.getUser(data.userId),
            {
                onSuccess: (userInfo) => {
                    if (!window.creators) {
                        window.creators = {};
                    }
                    if (!window.creators[data.userId]) {
                        window.creators[data.userId] = {};
                    }

                    window.creators[data.userId].avatar = userInfo.avatar || null;
                    window.creators[data.userId].username = userInfo.username;
                    window.creators[data.userId].level = userInfo.level || 0;

                    showDiscordAvatar(userInfo.avatar);
                },
                onError: (error) => {
                    console.error("Failed to fetch user info:", error);
                    showLetterAvatar();

                    if (!window.creators) {
                        window.creators = {};
                    }
                    if (!window.creators[data.userId]) {
                        window.creators[data.userId] = {};
                    }
                    window.creators[data.userId].avatar = null;
                }
            }
        );
    }

    DOM.setText("post_time", timeAgo(data.timestamp));

    animateViewCount(data.views);

    if(!data.content){
        data.content = "https://vapr.b-cdn.net/posts/200w.gif";
    }

    if(data.content.split("/posts/")[0] === "https://vapr-club.b-cdn.net"){
        DOM.get("post_image").src = data.content;
        DOM.show("post_image");
        DOM.hide("post_content");
        DOM.hide("post_video");

        const imageEl = DOM.get("post_image");
        imageEl.style.filter = "blur(10px)";
        imageEl.onload = () => {
            imageEl.style.filter = "none";
            imageEl.style.transition = "filter 0.3s ease";
        };

        window.currentPostImageUrl = data.content;
        window.currentPostId = data.id;
        updateSetBackgroundButton();
    }else if(data.content.includes("iframe.mediadelivery.net")){
        DOM.show("post_video");
        setTimeout(() => {
            DOM.get("post_video").children[0].src = data.content;
        }, 100);
        DOM.hide("post_content");
        DOM.hide("post_image");
        window.currentPostImageUrl = null;
        window.currentPostId = null;
        updateSetBackgroundButton();
    }

    DOM.get("post_image").onclick = function () {
        toggleImageZoom(DOM.get("post_image"));
    }

    const headerGameButton = DOM.get("header_game_button");

    DOM.hide(headerGameButton);

    if(data.taggedGame && data.taggedGame.id) {
        window.currentPostTaggedGame = data.taggedGame;
        DOM.show(headerGameButton, 'inline-flex');
        headerGameButton.innerHTML = `<i class="fa-solid fa-gamepad"></i><span>${data.taggedGame.title}</span>`;

        headerGameButton.style.opacity = '0';
        headerGameButton.style.transform = 'translateY(10px)';

        setTimeout(() => {
            headerGameButton.style.transition = 'all 0.3s ease';
            headerGameButton.style.opacity = '1';
            headerGameButton.style.transform = 'translateY(0)';
        }, 100);
    } else {
        window.currentPostTaggedGame = null;
    }
}

function updateSetBackgroundButton() {
    let setBackgroundBtn = DOM.get("set_background_btn");

    if (!setBackgroundBtn) {
        setBackgroundBtn = DOM.create('button', {
            id: 'set_background_btn',
            class: 'glass-button set-background-btn',
            onclick: () => setPostAsBackground()
        });
        setBackgroundBtn.innerHTML = '<i class="fa-solid fa-image"></i><span>Set as Background</span>';

        const actionBar = DOM.query('.action-bar');
        if (actionBar) {
            actionBar.appendChild(setBackgroundBtn);
        }
    }

    if (window.currentPostImageUrl && window.currentPostId) {
        DOM.show(setBackgroundBtn, 'inline-flex');

        const currentBackgroundId = localStorage.getItem('background_id');
        if (currentBackgroundId === window.currentPostId) {
            setBackgroundBtn.innerHTML = '<i class="fa-solid fa-check"></i><span>Current Background</span>';
            setBackgroundBtn.classList.add('active');
            setBackgroundBtn.disabled = true;
        } else {
            setBackgroundBtn.innerHTML = '<i class="fa-solid fa-image"></i><span>Set as Background</span>';
            setBackgroundBtn.classList.remove('active');
            setBackgroundBtn.disabled = false;
        }
    } else {
        DOM.hide(setBackgroundBtn);
    }
}

function setPostAsBackground() {
    if (!window.currentPostImageUrl || !window.currentPostId) return;

    if (!isUserLoggedIn()) {
        openRegisterModal();
        return;
    }

   
    equipBackground(window.currentPostId, true);

    updateSetBackgroundButton();
    notify.success("Background updated!");

    if (typeof confetti !== 'undefined') {
        confetti({
            particleCount: 50,
            spread: 50,
            origin: { y: 0.6 },
            colors: ['#4ecdc4', '#44a3aa', '#3d9a92']
        });
    }
}

window.openTaggedGame = async function() {
    loading.show();
    if (window.currentPostTaggedGame && window.currentPostTaggedGame.id) {
        if (current_post && current_post.id) {
            try {
                const gameId = window.currentPostTaggedGame.id;
                console.log('Tracking game click for game:', gameId, 'post:', current_post.id);

                await api.request('/api/creators/track-game-click', {
                    method: 'POST',
                    body: {
                        gameId: gameId,
                        postId: current_post.id
                    }
                });
                console.log('Successfully tracked game click for creator attribution');
            } catch (error) {
                console.error('Failed to track game click:', error);
            }
        }

        if (!gamesData.tebexGames || gamesData.tebexGames.length === 0) {
            await loadTebexGames();
        }

        const toSlug = (s) => String(s)
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
        const slug = toSlug(window.currentPostTaggedGame.title);

        loading.hide();
        router.navigate(`/games/${slug}`, true);
    }
}

function navigateToProfile() {
    if (current_post && current_post.username) {
        router.navigate(`/@${current_post.username}`);
    }
}

function animateViewCount(targetViews) {
    const viewsEl = DOM.get("post_views");
    const startViews = parseInt(viewsEl.textContent) || 0;
    const duration = 1000;
    const startTime = performance.now();

    function updateViews(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        const easeOutQuart = 1 - Math.pow(1 - progress, 4);

        const currentViews = Math.floor(startViews + (targetViews - startViews) * easeOutQuart);
        viewsEl.textContent = formatViews(currentViews);

        if (progress < 1) {
            requestAnimationFrame(updateViews);
        }
    }

    requestAnimationFrame(updateViews);
}

function toggleImageZoom(img) {
    if (img.classList.contains('zoomed')) {
        img.classList.remove('zoomed');
        DOM.query('.image-overlay')?.remove();
    } else {
        const overlay = DOM.create('div', {
            class: 'image-overlay',
            onclick: () => toggleImageZoom(img)
        });

        const zoomedImg = img.cloneNode();
        zoomedImg.className = 'zoomed-image';

        overlay.appendChild(zoomedImg);
        document.body.appendChild(overlay);

        img.classList.add('zoomed');

        requestAnimationFrame(() => {
            overlay.classList.add('active');
        });
    }
}
function showPost() {
    const post = document.getElementsByClassName("post")[0];
    post.style.transform = "translate(0px, 0px) rotate(0deg)";
    post.style.backgroundColor = "";
    post.style.boxShadow = "";
    post.style.animation = 'none';
}

function displayPost(postId = undefined){
    hidePost();
    if(!postId){
        if(feed_posts.length > 0){
            const data = feed_posts.shift();
            loading_steps--;
            current_post_id = data.id;
            current_post = data;
            drawPost(data);
            if (!cardManager.isNavigating) {
                history.pushState(null, null, "/post/" + data.id);
            }
        }else{
            APIHandler.handle(
                () => api.getFeed(),
                {
                    onSuccess: (data) => {
                        console.log(data);
                        feed_posts = data.sort((a, b) => 0.5 - Math.random());
                        console.log(data);
                        displayPost();
                    }
                }
            );
        }
    }else{
        APIHandler.handle(
            () => api.getPost(postId),
            {
                onSuccess: (data) => {
                    loading_steps--;
                    current_post_id = data.id;
                    current_post = data;
                    drawPost(data);
                    if (!cardManager.isNavigating) {
                        history.pushState(null, null, "/post/" + data.id);
                    }
                }
            }
        );
    }
}
let user_previous_reaction = null;
let isProcessingReaction = false;

function initEnhancedReactions() {
    const reactionButtons = DOM.queryAll('.reactions button');

    reactionButtons.forEach(btn => {
        btn.addEventListener('click', function(e) {
            createRipple(e, this);
        });
    });
}

function createRipple(event, button) {
    const rect = button.getBoundingClientRect();
    const size = Math.max(rect.width, rect.height);
    const x = event.clientX - rect.left - size / 2;
    const y = event.clientY - rect.top - size / 2;

    const ripple = DOM.create('span', {
        style: {
            position: 'absolute',
            width: `${size}px`,
            height: `${size}px`,
            borderRadius: '50%',
            background: 'rgba(255, 255, 255, 0.5)',
            pointerEvents: 'none',
            transform: `translate(${x}px, ${y}px) scale(0)`,
            animation: 'rippleEffect 0.6s ease-out'
        }
    });

    button.appendChild(ripple);
    setTimeout(() => ripple.remove(), 600);
}

function incrementEmoji(emoji) {
    const emoji_count = DOM.get(emoji);
    const currentCount = parseInt(emoji_count.textContent);
    const newCount = currentCount + 1;

    emoji_count.style.transform = 'scale(1.5)';
    emoji_count.style.color = '#4ecdc4';

    setTimeout(() => {
        emoji_count.textContent = newCount;
        emoji_count.style.transform = 'scale(1)';
        emoji_count.style.color = '';
    }, 200);
}

function decrementEmoji(emoji) {
    const emoji_count = DOM.get(emoji);
    const currentCount = parseInt(emoji_count.textContent);
    const newCount = Math.max(0, currentCount - 1);

    emoji_count.style.transform = 'scale(0.8)';
    emoji_count.style.color = '#e74c3c';

    setTimeout(() => {
        emoji_count.textContent = newCount;
        emoji_count.style.transform = 'scale(1)';
        emoji_count.style.color = '';
    }, 200);
}

function resetEmoji(emoji) {
    const emoji_count = DOM.get(emoji);
    emoji_count.textContent = "0";
}

function addReaction(emoji) {
    if (!isUserLoggedIn()) {
        const reactionsContainer = DOM.query('.reactions');
        reactionsContainer.style.animation = 'shake 0.5s ease';
        setTimeout(() => {
            reactionsContainer.style.animation = '';
            openRegisterModal();
        }, 500);
        return;
    }

    if (isProcessingReaction) return;

    isProcessingReaction = true;

    const currentBtn = DOM.query(`[data-reaction="${emoji}"]`);
    const wasActive = currentBtn.classList.contains('active');

    if (user_previous_reaction && user_previous_reaction !== emoji) {
        const prevBtn = DOM.query(`[data-reaction="${user_previous_reaction}"]`);
        prevBtn.classList.remove('active');
        decrementEmoji(user_previous_reaction);
    }

    if (!wasActive) {
        currentBtn.classList.add('active');
        incrementEmoji(emoji);
        animateReactionIcon(currentBtn.querySelector('.reaction_icon'));
        createFloatingReaction(emoji, currentBtn);
    } else {
        currentBtn.classList.remove('active');
        decrementEmoji(emoji);
        emoji = null;
    }

    APIHandler.handle(
        () => api.addReaction(current_post_id, emoji),
        {
            onSuccess: (data) => {
                console.log('Reaction added:', data);
                user_previous_reaction = emoji;
                isProcessingReaction = false;
            },
            onError: (error) => {
                console.error('Error adding reaction:', error);
                if (user_previous_reaction) {
                    incrementEmoji(user_previous_reaction);
                    decrementEmoji(emoji);
                }
                currentBtn.classList.toggle('active');
                isProcessingReaction = false;
            }
        }
    );
}

function animateReactionIcon(icon) {
    icon.style.animation = 'none';
    setTimeout(() => {
        icon.style.animation = 'bounce 0.5s ease';
    }, 10);
}

function createFloatingReaction(emoji, button) {
    const rect = button.getBoundingClientRect();

    const floater = DOM.create('div', {
        class: 'floating-reaction',
        style: {
            position: 'fixed',
            left: `${rect.left + rect.width / 2}px`,
            top: `${rect.top}px`,
            fontSize: '30px',
            pointerEvents: 'none',
            zIndex: '1000',
            animation: 'floatUp 1s ease-out forwards'
        }
    }, emoji);

    document.body.appendChild(floater);
    setTimeout(() => floater.remove(), 1000);
}

function displayReactions() {
    DOM.queryAll('.reactions button').forEach(btn => {
        btn.classList.remove('active');
    });

    resetEmoji('ðŸ’©');
    resetEmoji('ðŸ‘€');
    resetEmoji('ðŸ˜‚');
    resetEmoji('ðŸ’¯');

    console.log("Post id : " + current_post_id);

    APIHandler.handle(
        () => api.getReactions(current_post_id),
        {
            onSuccess: (data) => {
                console.log('Reactions received:', data);
                user_previous_reaction = null;

                data.reactions.forEach((reaction, index) => {
                    setTimeout(() => {
                        incrementEmoji(reaction.emoji);

                        if (reaction.userId === window.user?.id) {
                            user_previous_reaction = reaction.emoji;
                            const btn = DOM.query(`[data-reaction="${reaction.emoji}"]`);
                            btn.classList.add('active');
                        }
                    }, index * 50);
                });
            }
        }
    );
}

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', initEnhancedReactions);
}
function closeRegisterModal() {
    DOM.hide("register");
}

document.addEventListener('DOMContentLoaded', function() {
    const userCountEl = DOM.get('user_count');
    const userCountCtaEl = DOM.get('user_count_cta');

    if (userCountEl && userCountCtaEl) {
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'childList' || mutation.type === 'characterData') {
                    userCountCtaEl.textContent = userCountEl.textContent;
                }
            });
        });

        observer.observe(userCountEl, { childList: true, characterData: true, subtree: true });
    }
});
function setXPProgress(old_user, disable_xp_notif = false, force_update = false) {
    if (!user.xp) user.xp = 0;
    if (!user.level) user.level = 0;

    const total_xp = user.xp;
    const xp = Math.min(total_xp - old_user.xp, old_user.xp_required);

    updateLevel();
    updateXPDisplay();

    if (xp > 0 || force_update) {
        const diff = (xp / old_user.xp_required) * 100;
        const new_value = (total_xp / old_user.xp_required) * 100;

        const xp_bar_progress_visual = DOM.get("xp_bar_progress_visual");
        const xp_bar_progress = DOM.get("xp_bar_progress");

        xp_bar_progress_visual.style.width = diff + "%";
        xp_bar_progress_visual.style.left = (new_value - diff) + "%";

        if (!disable_xp_notif) {
            notify.showXP(xp);

            setTimeout(() => {
                if (old_user.level < user.level) {
                    notify.levelUp(user.level);
                    setXPProgress(window.user, true, true);
                }
            }, 1500);
        }

        setTimeout(() => {
            xp_bar_progress.style.width = new_value + "%";
            xp_bar_progress_visual.style.width = "0%";
            xp_bar_progress_visual.style.left = new_value + "%";
        }, 300);
    }
}

function updateLevel() {
    const level_elements = document.getElementsByClassName("xp_level");
    for (let i = 0; i < level_elements.length; i++) {
        level_elements[i].textContent = user.level;
    }

    const xp_level_elements = document.getElementsByClassName("xp-level");
    for (let i = 0; i < xp_level_elements.length; i++) {
        xp_level_elements[i].textContent = user.level;
    }
}

function updateXPDisplay() {
    const username = DOM.query('.xp-username');

    if (username) username.textContent = user.username || 'username';

    const oldUsername = DOM.query('.username');
    if (oldUsername) oldUsername.textContent = user.username || 'username';
}
async function updateSDKUserInfo() {
    if (!isRunningInTauri() || !window.user) return;

    try {
        let avatarHash = null;
        if (window.user.avatar) {
            avatarHash = window.user.avatar;
        } else if (window.user.avatar_url) {
            const match = window.user.avatar_url.match(/avatars\/\d+\/([^.]+)/);
            if (match) {
                avatarHash = match[1];
            }
        }

        await window.__TAURI__.core.invoke('update_sdk_user_info', {
            userId: window.user.id,
            username: window.user.username,
            level: window.user.level || 0,
            xp: window.user.xp || 0,
            xpRequired: window.user.xp_required || 700,
            avatar: avatarHash
        });

        console.log('SDK user info updated');
    } catch (error) {
        console.error('Failed to update SDK user info:', error);
    }
}

async function clearSDKUserInfo() {
    if (!isRunningInTauri()) return;

    try {
        await window.__TAURI__.core.invoke('clear_sdk_user_info');
        console.log('SDK user info cleared');
    } catch (error) {
        console.error('Failed to clear SDK user info:', error);
    }
}

async function getSDKConnectedSessions() {
    if (!isRunningInTauri()) return [];

    try {
        const sessions = await window.__TAURI__.core.invoke('get_sdk_connected_sessions');
        return sessions;
    } catch (error) {
        console.error('Failed to get connected sessions:', error);
        return [];
    }
}

async function monitorSDKConnections() {
    if (!isRunningInTauri()) return;

    setInterval(async () => {
        const sessions = await getSDKConnectedSessions();
        if (sessions.length > 0) {
            console.log(`Games connected via SDK: ${sessions.length}`);
        }
    }, 30000);
}

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        monitorSDKConnections();
    });
}
class TebexAPI {
    constructor() {
        this.baseURL = 'https://headless.tebex.io/api';
        this.configs = [];
    }

    async loadConfigs() {
        try {
            const response = await fetch('/api/tebex-configs', {
                credentials: 'include'
            });
            const data = await response.json();
            if (data.success) {
                this.configs = data.configs;
            }
        } catch (error) {
            console.error('Failed to load Tebex configurations:', error);
        }
    }

    async request(path, options = {}, webstoreToken = null) {
        const url = `${this.baseURL}${path}`;

        try {
            const response = await fetch(url, {
                ...options,
                headers: {
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            });

            if (!response.ok) {
                throw new Error(`Tebex API error: ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Tebex API request failed:', error);
            throw error;
        }
    }

    async getAllPackages() {
        await this.loadConfigs();

        const allPackages = [];

        for (const config of this.configs) {
            try {
                const response = await this.request(`/accounts/${config.webstoreToken}/packages`);
                const packages = response.data || [];

                const packagesWithStore = packages.map(pkg => ({
                    ...pkg,
                    storeInfo: {
                        userId: config.userId,
                        username: config.username,
                        storeName: config.storeName,
                        webstoreToken: config.webstoreToken
                    }
                }));

                allPackages.push(...packagesWithStore);
            } catch (error) {
                console.error(`Failed to load packages for store ${config.storeName}:`, error);
            }
        }

        return { data: allPackages };
    }

    async applyCreatorCode(basketIdent, creatorCode, webstoreToken) {
        return this.request(`/accounts/${webstoreToken}/baskets/${basketIdent}/creator-codes`, {
            method: 'POST',
            body: JSON.stringify({
                creator_code: creatorCode
            })
        });
    }
}

window.tebexAPI = new TebexAPI();
function handleCheckoutSuccess() {
    notify.success('Purchase completed successfully!');

    if (window.loadLibraryData) {
        loadLibraryData();
    }
}

function handleCheckoutCancel() {
    notify.info('Checkout cancelled');
}

document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);

    if (window.location.pathname === '/checkout/success') {
        handleCheckoutSuccess();
        window.history.replaceState({}, '', '/');
    } else if (window.location.pathname === '/checkout/cancel') {
        handleCheckoutCancel();
        window.history.replaceState({}, '', '/');
    }
});
document.addEventListener('DOMContentLoaded', (event) => {
    const post = document.getElementsByClassName("post")[0];
    let startX = 0;
    let startY = 0;
    let currentX = 0;
    let currentY = 0;
    let startTime = 0;

    post.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        currentX = startX;
        currentY = startY;
        startTime = new Date().getTime();
        post.style.transition = 'none';
        post.style.animation = 'none';
    });

    post.addEventListener('touchmove', (e) => {
        currentX = e.touches[0].clientX;
        currentY = e.touches[0].clientY;
        let changeX = currentX - startX;
        let changeY = currentY - startY;
        post.style.transform = `translate(${changeX}px, ${changeY}px) rotate(${changeX * 0.1}deg)`;
    });

    post.addEventListener('touchend', (e) => {
        let changeX = currentX - startX;
        let changeY = currentY - startY;
        let elapsedTime = new Date().getTime() - startTime;
        let velocity = Math.abs(changeX) / elapsedTime;
        let velocityy = Math.abs(changeY) / elapsedTime;

        if (velocity > 0.3 || Math.abs(changeX) > 100) {
            if (changeX < -100) {
                dislikePost();
            } else if (changeX > 100) {
                likePost();
            }
        }else if (velocityy > 0.3 || Math.abs(changeY) > 100) {
            if (changeY < -100) {
                skipPost();
            }
        } else {
            resetPostPosition();
        }
    });

    function resetPostPosition() {
        post.style.transition = 'transform 0.3s ease';
        post.style.transform = 'translate(0px, 0px) rotate(0deg)';
    }
});

function setInitialTransform(post) {
    const transform = post.style.transform || '';

    let translateX = 0;
    let translateY = 0;
    let rotate = 0;

    if (transform) {
        const translateMatch = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
        if (translateMatch) {
            translateX = parseInt(translateMatch[1]) || 0;
            translateY = parseInt(translateMatch[2]) || 0;
        }

        const rotateMatch = transform.match(/rotate\(([^)]+)\)/);
        if (rotateMatch) {
            rotate = parseInt(rotateMatch[1]) || 0;
        }
    }

    console.log({
        translateX: translateX,
        translateY: translateY,
        rotate: rotate
    });

    post.style.setProperty('--start-translate-x', `${translateX}px`);
    post.style.setProperty('--start-translate-y', `${translateY}px`);
    post.style.setProperty('--start-rotate', `${rotate}deg`);

    post.style.transform = "translateY(100vh)";
    post.style.transition = 'all 1s ease-in-out';
}

function displayLikeAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'swipeRight 0.6s';
    post.style.transform = "translateY(100vh)";

    notify.showActionFeedback('liked');

    confetti({
        particleCount: 100,
        spread: 70,
        origin: { y: 0.6 },
        colors: ['#22c55e', '#10b981', '#059669']
    });
}

function displayDislikeAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'swipeLeft 0.6s';
    post.style.transform = "translateY(100vh)";

    notify.showActionFeedback('passed');
}

function displaySkipAnimation() {
    const post = document.getElementsByClassName("post")[0];
    post.style.animation = 'skip 0.6s';
    post.style.transform = "translateY(100vh)";

    notify.showActionFeedback('skipped');
}

function likePost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displayLikeAnimation();
        APIHandler.handle(
            () => api.likePost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displayLikeAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}

function skipPost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displaySkipAnimation();
        APIHandler.handle(
            () => api.skipPost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displaySkipAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}

function dislikePost() {
    const post = document.getElementsByClassName("post")[0];
    setInitialTransform(post);
    if (isUserLoggedIn()) {
        displayDislikeAnimation();
        APIHandler.handle(
            () => api.dislikePost(current_post_id),
            {
                updateXP: true,
                onSuccess: () => setTimeout(displayPost, 600)
            }
        );
    } else {
        if (post_seen > 3) {
            openRegisterModal();
        } else {
            displayDislikeAnimation();
            setTimeout(displayPost, 1000);
        }
    }
}
const uploadArea = DOM.query('.upload-area');
const fileInput = DOM.get('file');

if (uploadArea) {
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        uploadArea.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
        uploadArea.addEventListener(eventName, () => {
            uploadArea.classList.add('dragging');
        }, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
        uploadArea.addEventListener(eventName, () => {
            uploadArea.classList.remove('dragging');
        }, false);
    });

    uploadArea.addEventListener('drop', handleDrop, false);

    function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;

        if (files.length > 0) {
            fileInput.files = files;
            handleFileSelect(files[0]);
        }
    }
}

if (fileInput) {
    fileInput.addEventListener('change', function() {
        if (this.files && this.files[0]) {
            handleFileSelect(this.files[0]);
        }
    });
}

function handleFileSelect(file) {
    const fileType = file.type;
    const placeholder = DOM.get('upload-placeholder');
    const preview = DOM.get('upload-preview');
    const previewImage = DOM.get('preview_img');
    const previewVideo = DOM.get('preview_video');

    if (file.size > 50 * 1024 * 1024) {
        notify.error('File too large', 'Please select a file under 50MB');
        return;
    }

    const reader = new FileReader();
    reader.onload = function(e) {
        DOM.hide(placeholder);
        DOM.show(preview);

        if (fileType.startsWith('video/')) {
            previewVideo.src = e.target.result;
            DOM.show(previewVideo);
            DOM.hide(previewImage);
        } else if (fileType.startsWith('image/')) {
            previewImage.src = e.target.result;
            DOM.show(previewImage);
            DOM.hide(previewVideo);
        } else {
            notify.error('Invalid file type', 'Please upload an image or video file');
            DOM.show(placeholder, 'flex');
            DOM.hide(preview);
            return;
        }
    };
    reader.readAsDataURL(file);
}

const titleInput = DOM.get('title');
const titleCount = DOM.get('title-count');

if (titleInput && titleCount) {
    titleInput.addEventListener('input', function() {
        titleCount.textContent = this.value.length;
    });
}

let selectedGameForTag = null;

window.openGameTagModal = async function() {
    DOM.show('game-tag-modal', 'flex');
    await loadGamesForTagging();
}

window.closeGameTagModal = function() {
    DOM.hide('game-tag-modal');
}

window.selectGameForTag = function(gameId, gameTitle, gameCover) {
    selectedGameForTag = {
        id: gameId,
        title: gameTitle,
        coverImage: gameCover
    };

    DOM.hide('game-tag-button');
    DOM.show('selected-game', 'flex');
    DOM.get('selected-game-title').textContent = gameTitle;
    DOM.get('selected-game-cover').src = gameCover;

    closeGameTagModal();
}

window.removeGameTag = function() {
    selectedGameForTag = null;
    DOM.show('game-tag-button', 'inline-flex');
    DOM.hide('selected-game');
}

async function loadGamesForTagging() {
    try {
        const response = await api.request('/api/games');
        if (response.success) {
            displayGamesForTagging(response.games);
        }
    } catch (error) {
        console.error('Error loading games:', error);
    }
}

function displayGamesForTagging(games) {
    const container = DOM.get('game-tag-list');
    container.innerHTML = '';

    games.forEach(game => {
        const gameItem = DOM.create('div', {
            class: 'game-tag-item',
            onclick: () => selectGameForTag(game.id, game.title, game.coverImage)
        });

        gameItem.innerHTML = `
            <img src="${game.coverImage}" alt="${game.title}" class="game-tag-item-cover">
            <span class="game-tag-item-title">${game.title}</span>
        `;

        container.appendChild(gameItem);
    });
}

window.searchGamesForTag = function() {
    const searchTerm = DOM.get('game-tag-search').value.toLowerCase();
    const items = DOM.queryAll('.game-tag-item');

    items.forEach(item => {
        const title = item.querySelector('.game-tag-item-title').textContent.toLowerCase();
        if (title.includes(searchTerm)) {
            DOM.show(item, 'flex');
        } else {
            DOM.hide(item);
        }
    });
}

window.submitPost = async function(event) {
    event.preventDefault();

    const submitBtn = DOM.get('submit-post-btn');
    const uploadProgress = DOM.get('upload-progress');
    const progressFill = DOM.get('progress-fill');

    const title = DOM.get('title').value;
    const file = DOM.get('file').files[0];

    if (!file) {
        notify.warning('No media selected', 'Please select an image or video to upload');
        return;
    }

    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> <span>Publishing...</span>';

    const formData = new FormData();
    formData.append('title', title);

    if (selectedGameForTag) {
        formData.append('taggedGameId', selectedGameForTag.id);
    }

    if (file) {
        const fileExtension = file.name.split('.').pop();
        const fileName = `${new Date().getTime()}.${fileExtension}`;
        const fileContentType = file.type || 'application/octet-stream';
        const blob = new Blob([file], { type: fileContentType });
        formData.append("file", blob, fileName);
    }

    try {
        DOM.show(uploadProgress);

        let progress = 0;
        const progressInterval = setInterval(() => {
            progress += Math.random() * 15;
            if (progress > 90) progress = 90;
            progressFill.style.width = progress + '%';
        }, 200);

        const result = await api.createPost(formData);

        clearInterval(progressInterval);
        progressFill.style.width = '100%';

        if (result.success || result.id) { 
            confetti({
                particleCount: 100,
                spread: 70,
                origin: { y: 0.6 }
            });

           
            DOM.get('title').value = '';
            DOM.get('file').value = '';
            DOM.show('upload-placeholder', 'flex');
            DOM.hide('upload-preview');
            const titleCount = DOM.get('title-count');
            if (titleCount) {
                titleCount.textContent = '0';
            }

            removeGameTag();

            notify.success("Post published successfully!");

           
            if (window.user && result.user) {
                const oldUser = {
                    xp: window.user.xp,
                    level: window.user.level,
                    xp_required: window.user.xp_required
                };

                window.user = result.user;
                setXPProgress(oldUser);
            }

           
            closeAddPostCard();

           
            setTimeout(() => {
                router.navigate(`/post/${result.id}`, true);
            }, 300);

        } else {
            throw new Error(result.error || 'Failed to create post');
        }

    } catch (error) {
        console.error('Failed to submit post:', error);
        notify.error('Upload failed', error.message || 'Failed to create post. Please try again.');

    } finally {
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="fa-solid fa-paper-plane"></i> <span>Publish Post</span>';
        DOM.hide(uploadProgress);
        progressFill.style.width = '0%';
    }
}
const AnimationUtils = {
    animateCounter(element, start, end, duration = 1000, formatter = null) {
        if (!element) return;

        const startTime = performance.now();
        const defaultFormatter = (val) => this.formatNumber(val);
        const format = formatter || defaultFormatter;

        const updateCounter = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            const easeOutQuart = 1 - Math.pow(1 - progress, 4);
            const currentValue = Math.floor(start + (end - start) * easeOutQuart);

            element.textContent = format(currentValue);

            if (progress < 1) {
                requestAnimationFrame(updateCounter);
            }
        };

        requestAnimationFrame(updateCounter);
    },

    formatNumber(num) {
        if (num < 1000) return num.toString();
        if (num < 1000000) return (num / 1000).toFixed(1) + 'K';
        if (num < 1000000000) return (num / 1000000).toFixed(1) + 'M';
        return (num / 1000000000).toFixed(1) + 'B';
    },

    timeAgo(dateParam) {
        if (!dateParam) return null;

        const date = typeof dateParam === 'object' ? dateParam : new Date(dateParam);
        const today = new Date();
        const seconds = Math.round((today - date) / 1000);
        const minutes = Math.round(seconds / 60);
        const hours = Math.round(minutes / 60);
        const days = Math.round(hours / 24);
        const months = Math.round(days / 30.4);
        const years = Math.round(days / 365);

        if (seconds < 60) {
            return `${seconds}s ago`;
        } else if (minutes < 60) {
            return `${minutes}m ago`;
        } else if (hours < 24) {
            return `${hours}h ago`;
        } else if (days < 30) {
            return `${days}d ago`;
        } else if (months < 12) {
            return `${months}mo ago`;
        } else {
            return `${years}y ago`;
        }
    },

    formatViews(viewCount) {
        return this.formatNumber(viewCount);
    },

    escapeHtml(text) {
        const div = DOM.create('div');
        div.textContent = text;
        return div.innerHTML;
    }
};

window.animateCounter = AnimationUtils.animateCounter.bind(AnimationUtils);
window.formatNumber = AnimationUtils.formatNumber;
window.timeAgo = AnimationUtils.timeAgo;
window.formatViews = AnimationUtils.formatViews;
window.escapeHtml = AnimationUtils.escapeHtml;
const LoadingUtils = {
    loadingElement: null,
    loadingCount: 0,

    init() {
        if (!this.loadingElement) {
            const loading = document.createElement('div');
            loading.id = 'global-loading';
            loading.className = 'global-loading';
            loading.innerHTML = `
                <div class="loading-spinner">
                    <i class="fa-solid fa-spinner fa-spin"></i>
                </div>
            `;
            document.body.appendChild(loading);
            this.loadingElement = loading;
        }
    },

    show() {
        this.init();
        this.loadingElement.style.display = 'flex';
        document.body.style.overflow = 'hidden';
    },

    hide() {
        if (this.loadingElement) {
            this.loadingElement.style.display = 'none';
            document.body.style.overflow = '';
        }
    }
};

window.loading = LoadingUtils;
const NotificationUtils = {
    getToast() {
        if (typeof Swal === 'undefined') return null;

        return Swal.mixin({
            toast: true,
            position: "top-end",
            showConfirmButton: false,
            timer: 3000,
            timerProgressBar: true,
            didOpen: (toast) => {
                toast.onmouseenter = Swal.stopTimer;
                toast.onmouseleave = Swal.resumeTimer;
            }
        });
    },

    success(title, options = {}) {
        const Toast = this.getToast();
        if (!Toast) return;

        Toast.fire({
            icon: "success",
            title,
            ...options
        });
    },

    error(title, text = null, options = {}) {
        if (typeof Swal === 'undefined') return;

        if (text) {
            Swal.fire({
                icon: 'error',
                title,
                text,
                ...options
            });
        } else {
            const Toast = this.getToast();
            Toast?.fire({
                icon: "error",
                title,
                ...options
            });
        }
    },

    info(title, text = null, options = {}) {
        if (typeof Swal === 'undefined') {
            console.error('SweetAlert2 not loaded');
            return Promise.resolve({ isConfirmed: false });
        }

        if (text) {
            return Swal.fire({
                icon: 'info',
                title,
                text,
                ...options
            });
        } else {
            const Toast = this.getToast();
            if (Toast) {
                Toast.fire({
                    icon: "info",
                    title,
                    ...options
                });
            }
            return Promise.resolve({ isConfirmed: false });
        }
    },

    warning(title, text, options = {}) {
        if (typeof Swal === 'undefined') return;

        Swal.fire({
            icon: 'warning',
            title,
            text,
            ...options
        });
    },

    async confirm(title, text, options = {}) {
        if (typeof Swal === 'undefined') return false;

        const result = await Swal.fire({
            title,
            text,
            icon: 'question',
            showCancelButton: true,
            confirmButtonText: 'Yes',
            cancelButtonText: 'Cancel',
            confirmButtonColor: '#4ecdc4',
            ...options
        });

        return result.isConfirmed;
    },

    async confirmDanger(title, text, confirmText = 'Yes, delete it', options = {}) {
        if (typeof Swal === 'undefined') return false;

        const result = await Swal.fire({
            title,
            text,
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: confirmText,
            cancelButtonText: 'Cancel',
            confirmButtonColor: '#e74c3c',
            ...options
        });

        return result.isConfirmed;
    },

    levelUp(level) {
        if (typeof confetti !== 'undefined') {
            confetti({
                particleCount: 50,
                spread: 50,
                origin: { y: 0.3 },
                colors: ['#ffffff', '#4ecdc4', '#667eea']
            });
        }

        this.success(`Level ${level} reached! ðŸŽ‰`);
    },

    showXP(amount) {
        const notification = DOM.get('xp-notification');
        if (!notification) return;

        notification.style.animation = 'xpNotificationAnimation 1.5s';
        notification.textContent = `+${amount} XP`;

        setTimeout(() => {
            notification.style.animation = 'none';
        }, 1500);
    },

    showActionFeedback(action) {
        const feedback = DOM.create('div', {
            class: 'action-feedback ' + action
        });
        feedback.innerHTML = `<i class="fa-solid fa-${action === 'liked' ? 'heart' : action === 'passed' ? 'heart-crack' : 'forward'}"></i> ${action.charAt(0).toUpperCase() + action.slice(1)}!`;

        document.body.appendChild(feedback);

        setTimeout(() => {
            feedback.remove();
        }, 1000);
    },

    desktopAppPrompt(onConfirm) {
        if (typeof Swal === 'undefined') return;

        Swal.fire({
            title: 'Desktop App Required',
            html: `
                <p>To download and play games, you need the VAPR desktop app.</p>
                <p style="margin-top: 20px; font-size: 14px; color: rgba(255, 255, 255, 0.7);">
                    The desktop app allows you to:
                </p>
                <ul style="text-align: left; margin: 10px 0; font-size: 14px; color: rgba(255, 255, 255, 0.7);">
                    <li>Download and install games directly</li>
                    <li>Launch games with one click</li>
                    <li>Track your playtime</li>
                    <li>Get automatic updates</li>
                </ul>
            `,
            icon: 'info',
            showCancelButton: true,
            confirmButtonText: '<i class="fa-solid fa-download"></i> Download Desktop App',
            cancelButtonText: 'Maybe Later',
            confirmButtonColor: '#4ecdc4',
            customClass: {
                container: 'download-prompt-container'
            }
        }).then((result) => {
            if (result.isConfirmed && onConfirm) {
                onConfirm();
            }
        });
    },

    copyToClipboard(text, successMessage = 'Copied to clipboard!') {
        navigator.clipboard.writeText(text).then(() => {
            this.success(successMessage);
        }).catch(() => {
            const textArea = DOM.create('textarea', {
                value: text,
                style: {
                    position: 'absolute',
                    left: '-9999px'
                }
            });
            document.body.appendChild(textArea);
            textArea.select();
            textArea.setSelectionRange(0, 99999);

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    this.success(successMessage);
                } else {
                    this.error('Failed to copy to clipboard');
                }
            } catch (err) {
                this.error('Failed to copy to clipboard');
            }

            document.body.removeChild(textArea);
        });
    }
};

window.notify = NotificationUtils;
window.showToast = (type, title, options) => NotificationUtils[type](title, options);
let versionCheckInterval = null;
let isVersionCheckModalOpen = false;

function getWebVersion() {
    const versionElement = DOM.query('.menu-version span');
    if (versionElement) {
        const versionText = versionElement.textContent;
        const versionMatch = versionText.match(/v(\d+\.\d+\.\d+)/);
        if (versionMatch) {
            return versionMatch[1];
        }
    }
    return null;
}

function getDesktopVersion() {
    if (window.__TAURI__ && window.__TAURI__.app) {
        return window.__TAURI__.app.getVersion();
    }
    return null;
}

async function checkDesktopVersion() {
    if (!isRunningInTauri() || isVersionCheckModalOpen) {
        return;
    }

    try {
        const webVersion = getWebVersion();
        const desktopVersion = await getDesktopVersion();

        if (!webVersion || !desktopVersion) {
            console.error('Could not retrieve version information');
            return;
        }

        if (webVersion !== desktopVersion) {
            showVersionUpdateModal({
                current_version: desktopVersion,
                required_version: webVersion
            });
        }
    } catch (error) {
        console.error('Version check failed:', error);
    }
}

function showVersionUpdateModal(versionInfo) {
    if (isVersionCheckModalOpen) return;

    isVersionCheckModalOpen = true;

    if (versionCheckInterval) {
        clearInterval(versionCheckInterval);
        versionCheckInterval = null;
    }

    const downloadUrl = `https://github.com/Vic92548/VAPR/releases/download/v${versionInfo.required_version}/VAPR_${versionInfo.required_version}_x64_en-US.msi`;

    const modal = DOM.create('div', {
        id: 'version-update-modal',
        class: 'version-modal-overlay'
    });

    modal.innerHTML = `
        <div class="version-modal-content">
            <div class="version-modal-header">
                <i class="fa-solid fa-exclamation-triangle"></i>
                <h2>Update Available</h2>
            </div>
            <div class="version-modal-body">
                <p>A new version of VAPR desktop app is available. Update now for the latest features and improvements.</p>
                <div class="version-info">
                    <div class="version-item">
                        <span class="version-label">Your version:</span>
                        <span class="version-value outdated">v${versionInfo.current_version}</span>
                    </div>
                    <div class="version-item">
                        <span class="version-label">Latest version:</span>
                        <span class="version-value required">v${versionInfo.required_version}</span>
                    </div>
                </div>
                <p class="version-note">We recommend updating to ensure the best experience and compatibility.</p>
            </div>
            <div class="version-modal-actions">
                <button class="version-download-btn" onclick="downloadLatestDesktopVersion('${downloadUrl}')">
                    <i class="fa-solid fa-download"></i>
                    Download Latest Version
                </button>
                <button class="version-skip-btn" onclick="skipVersionUpdate('${versionInfo.required_version}')">
                    <i class="fa-solid fa-clock"></i>
                    Skip for now <span class="skip-warning">(not recommended, may cause bugs)</span>
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';
}

function skipVersionUpdate(skippedVersion) {
    const modal = DOM.get('version-update-modal');
    if (modal) {
        modal.remove();
        document.body.style.overflow = '';
    }

    isVersionCheckModalOpen = false;
}

function downloadLatestDesktopVersion(downloadUrl) {
    window.open(downloadUrl, '_blank');

    setTimeout(() => {
        notify.info(
            'Download Started',
            `<p>The download should begin shortly.</p>
            <p style="margin-top: 15px; font-size: 14px; color: rgba(255, 255, 255, 0.7);">
                After installing the new version, please restart VAPR to continue.
            </p>`,
            {
                confirmButtonText: 'OK',
                confirmButtonColor: '#4ecdc4'
            }
        );
    }, 500);
}

function initVersionCheck() {
    if (!isRunningInTauri()) return;

    setTimeout(() => {
        checkDesktopVersion();
    }, 3000);
}

if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        initVersionCheck();
    });

    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'childList' && DOM.query('.menu-version span')) {
                observer.disconnect();
                checkDesktopVersion();
            }
        });
    });

    observer.observe(document.body, { childList: true, subtree: true });
}
